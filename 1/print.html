<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Memory Leaks are Memory Safe - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="intro.html"><strong>1.</strong> Introduction</a></li><li><a href="authors.html"><strong>2.</strong> About the Authors</a></li><li><strong>3.</strong> Why Rust?</li><li><ul class="section"><li><a href="understanding-over-guesswork.html"><strong>3.1.</strong> Understanding Over Guesswork</a></li><li><strong>3.2.</strong> An Alternative Introduction to Rust</li><li><strong>3.3.</strong> Learning Rust</li><li><strong>3.4.</strong> Rust and CSV Parsing</li></ul></li><li><strong>4.</strong> Ownership</li><li><ul class="section"><li><a href="where-rust-really-shines.html"><strong>4.1.</strong> Where Rust Really Shines</a></li><li><a href="the-problem-with-shared-mutability.html"><strong>4.2.</strong> The Problem With Single-threaded Shared Mutability</a></li><li><a href="strategies-for-solving-borrowing-errors.html"><strong>4.3.</strong> Strategies for Solving 'cannot move out of' Borrowing Errors</a></li><li><strong>4.4.</strong> Interior Mutability In Rust</li><li><strong>4.5.</strong> Wrapper Types in Rust: Choosing Your Guarantees</li></ul></li><li><strong>5.</strong> Concurrency</li><li><ul class="section"><li><a href="fearless-concurrency.html"><strong>5.1.</strong> Fearless Concurrency</a></li><li><a href="how-rust-achieves-thread-safety.html"><strong>5.2.</strong> How Rust Achieves Thread Safety</a></li><li><strong>5.3.</strong> Rayon: Data Parallelism in Rust</li></ul></li><li><strong>6.</strong> Traits</li><li><ul class="section"><li><a href="abstraction-without-overhead.html"><strong>6.1.</strong> Abstraction Without Overhead</a></li><li><a href="all-about-trait-objects.html"><strong>6.2.</strong> All About Trait Objects</a></li></ul></li><li><strong>7.</strong> The Rust Language</li><li><ul class="section"><li><a href="rust-reuse-and-recycle.html"><strong>7.1.</strong> The Many Kinds of Code Reuse in Rust</a></li><li><a href="enums-match-mutation-and-moves.html"><strong>7.2.</strong> Mixing Matching, Mutation, and Moves</a></li><li><a href="reading-rust-function-signatures.html"><strong>7.3.</strong> Reading Rust Function Signatures</a></li><li><a href="finding-closure-in-rust.html"><strong>7.4.</strong> Finding Closure in Rust</a></li><li><a href="rusts-built-in-traits.html"><strong>7.5.</strong> Rust's Built-in Traits, the When, How &amp; Why</a></li><li><a href="myths-and-legends-about-integer-overflow.html"><strong>7.6.</strong> Myths and Legends About Integer Overflow</a></li></ul></li><li><strong>8.</strong> Rust in Practice</li><li><ul class="section"><li><a href="effectively-using-iterators.html"><strong>8.1.</strong> Effectively Using Iterators</a></li></ul></li><li><strong>9.</strong> Unsafe Rust</li><li><ul class="section"><li><a href="what-does-rusts-unsafe-mean.html"><strong>9.1.</strong> What Does Rust's <code>unsafe</code> Mean</a></li><li><a href="memory-leaks-are-memory-safe.html"><strong>9.2.</strong> Memory Leaks are Memory Safe</a></li></ul></li><li><strong>10.</strong> The Rust Toolbox</li><li><strong>11.</strong> Async I/O</li><li><strong>12.</strong> Rust Culture</li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#rust-anthology-1" id="rust-anthology-1"><h1>Rust Anthology 1</h1></a>
<p><em>This is a work in progress draft</em>.</p>
<p>TODO: 1 paragraph intro.</p>
<p>Something, something <a href="authors.html">about the authors</a>.</p>
<a class="header" href="print.html#why-rust" id="why-rust"><h2>Why Rust?</h2></a>
<p><a href="understanding-over-guesswork.html"><strong>Understanding Over Guesswork</strong></a>
★ <a href="authors.html#Andrew%20Hobden">Andrew Hobden</a>.
Some bugs are just that — a one off. A wayward moth that just
happens to be innocently fluttering through the wrong relay at the
wrong time. But some kinds of bugs aren't like that. Instead, they
have risen to superstar status, plaguing veterans and newcomers alike.
But what if these aren't bugs at all? What if they are actual
deficiencies in safety and robustness offered by the C programming
language as a consequence of the degree to which guesswork is
introduced? This chapter, a proposal to teach an operating systems
course in Rust at the University of Victoria, shows why Rust
is a superior language for writing reliable systems software.</p>
<a class="header" href="print.html#ownership" id="ownership"><h2>Ownership</h2></a>
<p><a href="where-rust-really-shines.html"><strong>Where Rust Really Shines</strong></a>
★ <a href="authors.html#Manish%20Goregaokar">Manish Goregaokar</a>.
A tale of hacking that illustrates how Rust's strong type system and
memory safety makes it simple to modify difficult code. Don't
understand how this pointer is accessed? That's fine. The compiler
won't let you do anything bogus, and it's going to guide you to the
correct solution.</p>
<p><a href="the-problem-with-shared-mutability.html"><strong>The Problem With Single-threaded Shared Mutability</strong></a>
★ <a href="authors.html#Manish%20Goregaokar">Manish Goregaokar</a>.
In Rust, <code>&amp;mut T</code> is a mutable reference, but it might be better
considered an <em>unaliased</em> reference, guaranteeing that there are no
other live pointers to that data, and no other code will access
it. The only way to write memory in Rust (without atomics) is through
an unaliased reference. This provides clear benefits in multithreaded
programs, where simultaneous access to data can result in bogus
data. But isn't this too strict for single-threaded programs? Actually,
mutable references solve subtle problems for those too.</p>
<a class="header" href="print.html#concurrency" id="concurrency"><h2>Concurrency</h2></a>
<p><a href="fearless-concurrency.html"><strong>Fearless Concurrency with Rust</strong></a>
★ <a href="authors.html#Aaron%20Turon">Aaron Turon</a>.
Memory safety bugs and concurrency bugs often come down to code
accessing data when it shouldn't. And the same feature that makes Rust
memory safe - ownership - also let the compiler statically prevent
common errors with conncurrent code.</p>
<p><a href="how-rust-achieves-thread-safety.html"><strong>How Rust Achieves Thread Safety</strong></a>
★ <a href="authors.html#Manish%20Goregaokar">Manish Goregaokar</a>.
Ownership is the secret, unifying, sauce of Rust. Among other things
it creates a simple conceptual framework for reasoning about
concurrency. But under the hood there are mysterious things afoot in
the type system to make it all work. Two simple traits are telling the
compiler everything it needs to know about concurrency: <code>Send</code> and
<code>Sync</code>. This is their story.</p>
<a class="header" href="print.html#traits" id="traits"><h2>Traits</h2></a>
<p><a href="abstraction-without-overhead.html"><strong>Abstraction Without Overhead</strong></a>
★ <a href="authors.html#Aaron%20Turon">Aaron Turon</a>.
The cornerstone of the Rust design philosophy is to enable &quot;zero-cost abstractions&quot;.
That is, the high-level abstractions in Rust optimize into the best low-level
code you could write by hand. And Rust, perhaps more than any other language,
comes close to achieving this ideal. This is how.</p>
<p><a href="all-about-trait-objects.html"><strong>All About Trait Objects</strong></a>
★ <a href="authors.html#Huon%20Wilson">Huon Wilson</a>.
One of the most powerful parts of the Rust programming language is the trait
system. They form the basis of Rust generics via polymorphic functions and
types, and as so-called &quot;trait objects&quot;, they allow for dynamic polymorphism and
heterogeneous uses of types. This chapter motivates trait objects and takes a
peek under the hood to see how they are implemented at runtime; then explains
the important advanced concepts of dynamically sized types and the <code>Sized</code>
trait; finally, it explains in which situations traits can be used as trait
objects, what is known as &quot;object safety&quot;.</p>
<a class="header" href="print.html#the-rust-language" id="the-rust-language"><h2>The Rust Language</h2></a>
<p><a href="rusts-built-in-traits.html"><strong>Rust's Built-in Traits, the When, How &amp; Why</strong></a>
★ <a href="authors.html#Andre%20Bogus">Andre Bogus</a>.
Traits make all kinds of magic happen in Rust, from operator
overloading, to thread-safety. Traits are shared vocabulary between
Rust types, so the standard library defines a bunch of them, and you
need to know them. Unravel the mystery of <code>PartialEq</code>, <code>Eq</code>,
<code>PartialOrd</code>, <code>Ord</code>, <code>Add</code>, <code>Sub</code> and other operators, <code>Index</code>,
<code>IndexMut</code>, the closure types <code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>, formatting with
<code>Display</code> and <code>Debug</code>, <code>Copy</code> and <code>Clone</code>, <code>Drop</code>, <code>Default</code>, <code>Error</code>,
<code>Hash</code>, <code>Iterator</code>, <code>From</code>, <code>Into</code>, the pointer conversions <code>Deref</code>,
<code>DerefMut</code>, <code>AsRef</code>, <code>AsMut</code>, <code>Borrow</code>, <code>BorrowMut</code>, <code>ToOwned</code>,
and thread-safety markers <code>Send</code>, <code>Sync</code>.</p>
<p><a href="finding-closure-in-rust.html"><strong>Finding Closure in Rust</strong></a>
★ <a href="authors.html#Huon%20Wilson">Huon Wilson</a>.
Closures are functions that can directly use variables from their
enclosing scope. They are a powerful tool in Rust, and come in several
forms, reflecting Rust's ownership-based design. This chapter covers
all the details, including the <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> traits,
captures and the <code>move</code> keyword.</p>
<a class="header" href="print.html#unsafe-rust" id="unsafe-rust"><h2>Unsafe Rust</h2></a>
<a class="header" href="print.html#rust-in-practice" id="rust-in-practice"><h2>Rust in Practice</h2></a>
<a class="header" href="print.html#the-rust-toolbox" id="the-rust-toolbox"><h2>The Rust Toolbox</h2></a>
<a class="header" href="print.html#async-io" id="async-io"><h2>Async I/O</h2></a>
<a class="header" href="print.html#rust-culture" id="rust-culture"><h2>Rust Culture</h2></a>
<a class="header" href="print.html#about-the-authors" id="about-the-authors"><h1>About the Authors</h1></a>
<a class="header" href="print.html#aaron-turon" id="aaron-turon"><h2>Aaron Turon</h2></a>
<a class="header" href="print.html#alexis-beingessner" id="alexis-beingessner"><h2>Alexis Beingessner</h2></a>
<a class="header" href="print.html#andre-bogus" id="andre-bogus"><h2>Andre Bogus</h2></a>
<a class="header" href="print.html#andrew-hobden" id="andrew-hobden"><h2>Andrew Hobden</h2></a>
<a class="header" href="print.html#felix-s-klock-ii" id="felix-s-klock-ii"><h2>Felix S. Klock II</h2></a>
<a class="header" href="print.html#herman-j-radtke-iii" id="herman-j-radtke-iii"><h2>Herman J. Radtke III</h2></a>
<a class="header" href="print.html#huon-wilson" id="huon-wilson"><h2>Huon Wilson</h2></a>
<a class="header" href="print.html#manish-goregaokar" id="manish-goregaokar"><h2>Manish Goregaokar</h2></a>
<a class="header" href="print.html#rust-anthology-editors" id="rust-anthology-editors"><h2>Rust Anthology Editors</h2></a>
<p>Rust Anthology is collaboratively edited by these fine folks: TODO</p>
<a class="header" href="print.html#understanding-over-guesswork" id="understanding-over-guesswork"><h1>Understanding Over Guesswork</h1></a>
<p>Or, Evolving How We Learn Systems with Lessons from Programming in the Large.</p>
<blockquote>
<p>Some bugs are just that---a one off.  A wayward moth that just happens to be innocently fluttering through the wrong relay at the wrong time.  But some kinds of bugs aren't like that.  Instead, they have risen to superstar status, plaguing veterans and newcomers alike.  But what if these aren't bugs at all?  What if they are actual deficiencies in safety and robustness offered by the C programming language as a consequence of the degree to which guesswork is introduced.  Here we explore a more explicit approach to systems level programming supported by Rust, which we believe will better promote understanding of design intent, and eliminate some of the guesswork.  Guided by a set of classic, but still relevant, bugs identified almost 15 years ago by Engler, we consider this in the context of the new generation of students learning about systems in a typical OS course, where students often first encounter these deficiencies.</p>
</blockquote>
<a class="header" href="print.html#1-introduction" id="1-introduction"><h1>1. Introduction</h1></a>
<p>Concurrency, parallelism, memory management, process scheduling, deadlocks, mutexes, system calls, filesystems, and architectural considerations are all commonly taught concepts in Operating Systems courses. These topics can be a struggle to understand, even for determined students, due to their complex, low-level characteristics.</p>
<p>Instructors may also find themselves struggling, as these assignments can be difficult to create, and at times nearly impossible to evaluate effectively. Instructors and their markers desire assignments which are simple enough to fit into a few files, demonstrate understanding of failure modes, can be tested effectively in an automated fashion, and show students the caveats of their attempts to solve the problem. In many cases, a trade-off is necessary. For example, building an interactive shell is a common, and much loved, assignment in which instructors must balance the number of features required with the time provided. Features such as pipes, background tasks, tab-completion, and environment variables are all desirable and interesting to implement, but contribute greatly to the complexity of the code, as well as the amount of time it takes to evaluate.</p>
<p>On top of the complexity, the ambiguity of language features means that year after year new students hit the same old bugs---eventually.  Engler et al. <a href="https://web.stanford.edu/%7Eengler/deviant-sosp-01.pdf" title="Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code"><em>(ref)</em></a> identified a number of problem classes in their work in static analysis that has served as a foundation for many tools in systems <a href="http://doi.acm.org/10.1145/2039239.2039241" title="Finding Resource-release Omission Faults in Linux"><em>(ref)</em></a>, <a href="http://doi.acm.org/10.1145/1133373.1133405" title="Applying Source-code Verification to a Microkernel: The VFiasco Project"><em>(ref)</em></a>, applications <a href="http://dl.acm.org/citation.cfm?id=1883978.1883982" title="Detecting Missing Method Calls in Object-oriented Software"><em>(ref)</em></a>, <a href="http://dl.acm.org/citation.cfm?id=1883978.1883982" title="Statically Checking API Protocol Conformance with Mined Multi-object Specifications"><em>(ref)</em></a>  and even compiler extensions derived from hardware specifications <a href="http://doi.acm.org/10.1145/2666357.2597823" title="em-SPADE: A Compiler Extension for Checking Rules Extracted from Processor Specifications"><em>(ref)</em></a>.  Students and professionals alike are perplexed by seemingly simple questions such as:</p>
<ul>
<li>Can routine <code>F</code> fail?</li>
<li>Must <code>A</code> be paired with <code>B</code>?</li>
<li>Does security check <code>Y</code> protect <code>X</code>?</li>
<li>Can <code>A</code> be done after <code>B</code>?</li>
<li>Does lock <code>L</code> protect <code>V</code>?</li>
</ul>
<p>In this short paper we demonstrate precisely how Rust addresses these potential bugs in a clear, clean, safe and robust manner. After introducing Rust (Section 2), we discuss how Rust approaches and helps solve to these common bug categories (Section 3). We also discuss the goals of &quot;Safety&quot;, the state of tooling, and the Rust community (Section 4), before closing with Future Work (Section 5).</p>
<a class="header" href="print.html#2-introducing-rust" id="2-introducing-rust"><h1>2. Introducing Rust</h1></a>
<p>Rust <a href="http://rust-lang.org/" title="Rust"><em>(ref)</em></a> is a systems oriented ML-family language supported by Mozilla Research. It was originally conceived by Graydon Hoare and reached its first stable release on May 15, 2015 <a href="http://blog.rust-lang.org/2015/05/15/Rust-1.0.html" title="Announcing Rust 1.0"><em>(ref)</em></a>. It is dual licensed Apache and MIT, fully open source, and governed through an extensive Request For Comment (RFC) process.</p>
<p>Rust offers a robust set of desirable features for systems code: ahead-of-time compilation, zero-cost abstractions, move semantics, guaranteed memory safety, threads without data races, trait-based generics, pattern matching, type inference, minimal runtime (removable, <a href="http://doc.rust-lang.org/book/no-stdlib.html" title="libcore"><em>(ref)</em></a>), no garbage collector or VM necessary, efficient C bindings and robust static analysis</p>
<p>It accomplishes these features through a number of novel techniques largely built off its type system and the borrow checker. The Rust community has been working to firmly position Rust as a powerful tool for programming in ultra-large, <a href="https://www.sei.cmu.edu/uls/" title="Ultra-Large-Scale Systems: The Software Challenge of the Future"><em>(ref)</em></a>, embedded, and networking systems.</p>
<a class="header" href="print.html#21-rust-basics" id="21-rust-basics"><h2>2.1 Rust Basics</h2></a>
<p>To someone familiar with C/C++ the syntax of Rust will appear reasonably familiar. Rust differs in many ways though, believing in that it is better to be explicit and promote understanding of what is occurring, than to expect the programmer to maintain all of this information in their head and engage in guesswork.</p>
<p>This is a key motivating factor behind our proposed adoption of Rust in OS courses, we believe this quality does not do away with conciseness or elegance of code. Community members have developed bindings for well-known tools like Redis <a href="http://redis.io/" title="Redis"><em>(ref)</em></a> and found the APIs for equivalent Rust and Python actions of relatively similar &quot;feel&quot;, despite the benefits of Rust's type system providing an additional safety net <a href="http://lucumr.pocoo.org/2014/10/1/a-fresh-look-at-rust/#designing-apis" title="A Fresh Look at Rust"><em>(ref)</em></a>.</p>
<p>Rust does, however, have significant semantic differences compared to C-like languages. For variable declaration, Rust has the <code>let</code> keyword which is <em>immutable by default</em>, mutability is opt-in via <code>let mut</code>. This opt-in mutability was found by the community to encourage better code. Instead of the programmer needing to remember to use <code>const</code> the compiler informs them of any variables they might have forgotten to make mutable or if it is unnecessarily mutable.</p>
<p>As well, function definitions differ from C-like languages. This change makes function definitions easier to comprehend when dealing with complex parameters, generics, and return values. Numerous reasoning for why C's declaration syntax is inadequate were well explained by Rob Pike <a href="https://blog.golang.org/gos-declaration-syntax" title="Go Blog: Function Declaration"><em>(ref)</em></a>.</p>
<pre><code class="language-rust ignore">fn example_simple()
fn example_params(x: u64, y: &amp;u64, z: &amp;mut u64)
fn example_returns(x: u64) -&gt; u64
fn example_generic&lt;U: Read&gt;(reader: U) -&gt; u64
fn example_generic_alt&lt;U&gt;(reader: U) -&gt; u64
    where U: Read
</code></pre>
<a class="header" href="print.html#22-a-strong-type-system" id="22-a-strong-type-system"><h2>2.2 A Strong Type System</h2></a>
<p>While a dynamic type system is desirable in some areas, particularly in higher level code, things like implicit, possibly lossy data conversions can often be dangerous in system code. In our experience, many operating systems students also struggle with the mental concepts of pointers and their uses. This can lead to taking pointers as values and performing pointer arithmetic.</p>
<p>The programmer is not <em>prevented</em> from doing these things in Rust, it only ensures that it is actually the intended action. For many students though, attempting to cast pointers into a value is actually a mistake in their intention. Rust helps users with this by automatically dereferencing pointers when necessary, and providing stronger tools for common places where these mistakes crop up, like string indexing or dynamic array access.</p>
<p>Types can be created easily, and there are three basic compound data structures, <code>struct</code>, <code>enum</code>, and tuples. <code>struct</code>s and tuples are similar to other languages. Rust's <code>enum</code>s are able to represent variants with encapsulated values, generics, and even <code>struct</code>s!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Structure with generic
struct One&lt;T&gt; {
    foo: usize,
    bar: T
}
// 2-tuple
struct Two(usize, usize);
// Enum
enum Three {
    // Plain.
    Foo,
    // Variant with Tuple.
    Bar(usize),
    // Variant with Struct.
    Baz { x: u64, y: u64, z: u64, },
}

#}</code></pre></pre>
<a class="header" href="print.html#23-we-dont-need-a-null" id="23-we-dont-need-a-null"><h2>2.3 We Don't Need A <code>null</code></h2></a>
<p>Cited by its creator <a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" title="The Billion Dollar Mistake"><em>(ref)</em></a> as a 'billion-dollar mistake' <code>null</code> is one of the most dangerous thorns in a programmers toolbox. What's more is that these errors happen at <em>runtime</em> and may take down live systems.</p>
<p>In languages like C, C++, and Java a tremendous amount of research and development time has gone into developing products like Coverity <a href="https://www.coverity.com/" title="Coverity"><em>(ref)</em></a> and PVS-Studio <a href="http://www.viva64.com/en/pvs-studio/" title="PVS-Studio"><em>(ref)</em></a> to help discover possible null pointer inconsistencies. Engler et al suggest heuristic methods to determine the 'null state' of a variable throughout the control flow of a program. What if programmers could just stop worrying about <code>null</code> all together?</p>
<p>Many functional languages like Haskell and F# have the concept of an <code>Option</code>, a concept that Rust shares. Instead of needing to be aware of and check for <code>null</code> at every occurrence, the language semantics require the programmer to explicitly decide on the control flow for all values.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Create a `Some(T)` and a None.
let maybe_foo = Some(0);
let not_foo = None;
// Unwrapping.
let foo = maybe_foo.unwrap();
let default = not_foo.unwrap_or(1);
let matched = match maybe_foo {
    Some(x) =&gt; x,
    None =&gt; -1,
};
// Mapping
let mapped = maybe_foo.map(|x| x as f64);

#}</code></pre></pre>
<a class="header" href="print.html#3-rust-reducing-bugs-through-linguistic-features" id="3-rust-reducing-bugs-through-linguistic-features"><h1>3. Rust: Reducing Bugs through Linguistic Features</h1></a>
<p>In Rust, many common bugs can be prevented because: routines with the potential for failure carry it explicitly in their function signature (Section 3.1), RAII is used to ensure allocations are followed by frees (Section 3.2), security checks can be required by the type system or through marker traits for 'tainted' data (Section 3.3), powerful move semantics eliminate use-after-free errors (Section 3.4), and locks inherently protect data, not code (Section 3.4).</p>
<a class="header" href="print.html#31-results-and-try" id="31-results-and-try"><h2>3.1 Results and <code>try!()</code></h2></a>
<p>When working with traditional languages such as C and C++ it can often be difficult to answer the question &quot;Can this function fail?&quot; Checked exceptions can help, but often APIs are inconsistent, and checks for failure can be forgotten <a href="https://web.stanford.edu/%7Eengler/deviant-sosp-01.pdf" title="Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code"><em>(ref)</em></a>. Some static analysis techniques can be used to determine possible missed failure checks, such has detecting invocations that do check for error. Having failure information included in the function's signature and requiring it to be explicitly checked may be a more robust solution over heuristics though.</p>
<p>The <code>Result&lt;T, E&gt;</code> enum exists as either <code>Ok(T)</code> or <code>Err(E)</code> and conveys the result of something which may fail with an error. Using Rust's <code>match</code> expression the user can act on various error conditions or success.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::io;
use std::error::Error;
// Create an error. (Normally raised from lib)
let error = io::Error::new(io::ErrorKind::Other,
    &quot;I'm an example error!&quot;);
// The two result variants. Type notations usually
// not necessary except in small examples.
let success: Result&lt;_, io::Error&gt; = Ok(&quot;Success!&quot;);
let failure: Result&lt;&amp;str, _&gt; = Err(error);
// Return either the value or the error description.
let val_or_desc = match success {
    Ok(val) =&gt; val,
    Err(ref e)  =&gt; e.description(),
};

#}</code></pre></pre>
<p>It is a compiler warning to perform an action such as <code>file.read_to_string(buf)</code> which returns a <code>Result&lt;usize, Error&gt;</code> and to not handle the error in some way. In Rust is it idiomatic for any recoverable error to be passed up the call stack to where it can be sensibly handled. While approaching this idea newcomers typically struggle with the fact that an <code>io::Error</code> and a <code>Utf8Error</code> are different types and cannot be returned in the same <code>Result&lt;T,E&gt;</code>, since the <code>E</code> value would differ and violate Rust's strong typing. This is typically solved by creating a new <code>Error</code> which is an enumeration over the possible underlaying errors as well as any the programmer may wish to include themselves. Then there are the <code>Into&lt;T&gt;</code> and <code>From&lt;T&gt;</code> traits which can be implemented to provide seamless interaction.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# use std::io;
# use std::str::Utf8Error;
pub enum MyError {
    Io(io::Error),
    Utf8(Utf8Error)
}
impl From&lt;io::Error&gt; for MyError {
    fn from(err: io::Error) -&gt; MyError {
        MyError::Io(err)
    }
}
// ...

#}</code></pre></pre>
<p>When working with functions which may return a <code>Result&lt;T, E&gt;</code> it is common to use the <code>try!()</code> macro. This macro expands to either unwrap the <code>T</code> value inside and assign it, or return the error up the call stack. This helps reduce visual 'noise' and assist in composition.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
# use std::fs::File;
# use std::io::{self, Read};
# pub enum MyError {
#     Io(io::Error),
# }
# impl From&lt;io::Error&gt; for MyError {
#     fn from(err: io::Error) -&gt; MyError {
#         MyError::Io(err)
#     }
# }
fn open_and_read() -&gt; Result&lt;String, MyError&gt; {
    let mut f = try!(File::open(&quot;foo.txt&quot;));
    let mut s = String::new();
    let num_read = try!(f.read_to_string(&amp;mut s));
    Ok(s)
}

#}</code></pre></pre>
<p>Error handling in Rust is explicit, composable, and sane. There are no exceptions, nulls, 'magic numbers' (like -1) or anything that may prevent the programmer from handling the error as <em>they</em> choose to, even if that is to simply <code>.unwrap()</code> it and fail. It's worth noting that even <code>.unwrap()</code>ing does not actually crash the program as normally it unwinds the stack, isolating failure to a single thread and preventing inconsistent state.</p>
<a class="header" href="print.html#32-borrow-and-move-forget-free" id="32-borrow-and-move-forget-free"><h2>3.2 Borrow and Move: Forget <code>free()</code></h2></a>
<p>In Rust there is the notion of moving, copying, and referencing. In some ways Rust's memory model
is similar to C/C++'s. It features a powerful pointer system that allows programmers to make fine-grain, informed decisions about how values are stored, passed, and represented. Like C++, Rust makes use of a concept called Resource Acquisition Is Instantiation (RAII). Rust goes a step further, introducing the distinction between <em>immutably borrowing</em> (<code>&amp;</code>), <em>mutably borrowing</em> (<code>&amp;mut</code>), <em>copying</em> (<code>Copy</code> trait), and <em>moving</em> values. At any given time there may be any number of <em>immutable borrows</em>, meanwhile there may only be one <em>mutable borrow</em>, and a value may not be used in the function once it has been <em>moved</em> out.</p>
<p>This makes it simple for a programmer to observe a function signature and determine which values the function may mutate or consume, and which it may return. Using this information the compiler is able to determine the lifetime constraints of almost any value without additional notations. In (rare, complex) cases where it does require additional information, the programmer can annotate lifetimes just as they would generic type parameters.</p>
<pre><code class="language-rust ignore">fn main() {
    // An owned, growable,
    // non-copyable string.
    let mut foo = String::from(&quot;foo&quot;);

    // Introduce a new scope.
    {
        // Reference bar is created.
        let bar = &amp;foo;
        // Error, bar is immutable.
        bar.push('c');
    } // bar is destroyed.

    // Error, bar does not exist.
    let baz = bar;
    // Works, reference mutable.
    let rad = &amp;mut foo;
    rad.push('c');
} // foo is destroyed.
</code></pre>
<p>This behavior is very similar to C++'s RAII facilities and ensures all values are safely destructed in a consistent, predictable manner as soon as they are no longer needed. The programmer does not need to worry about making sure each of their <code>malloc()</code> calls have a corresponding <code>free()</code> or rely on an outside tool <a href="https://web.stanford.edu/%7Eengler/deviant-sosp-01.pdf" title="Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code"><em>(ref)</em></a> to discover such errors. The borrow checker is also able to determine when a value has been <em>moved</em> into a function call and should not be further used in the caller, eliminating another possible class of errors.</p>
<a class="header" href="print.html#33-traits-zero-cost-abstractions" id="33-traits-zero-cost-abstractions"><h2>3.3 Traits: Zero-cost Abstractions</h2></a>
<p>Rust does not use a class based or inheritance based system. Data is stored in <code>struct</code>s, primitives, or <code>enum</code>s which implement a set of traits that define how it interacts and which functions are available to it. For example, the <code>File</code> is a <code>struct</code> which implements <code>Read</code> and <code>Write</code> among other traits. Other structures like <code>TcpStream</code> and <code>UdpSocket</code> also implement the same <code>Read</code> and <code>Write</code> trait. Traits are zero-cost abstractions that act to encourage common interfaces and capabilities between like-structures <a href="http://blog.rust-lang.org/2015/05/11/traits.html" title="Abstraction without overhead: traits in Rust"><em>(ref)</em></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Thing {
    barred: bool,
}
trait Foo {
    // Implementor must define.
    fn bar(&amp;mut self);
    // Default definition.
    fn do_bar(&amp;mut self) { self.bar() }
}
impl Foo for Thing {
    fn bar(&amp;mut self) {
        self.barred = true;
    }
}

#}</code></pre></pre>
<p>Traits fit easily together, are widespread in their implementation, and allow for common interfaces between modules to permit better adaptability. Traits can also be used as 'markers' in design patterns like state machines to provide additional compile time verification of correctness.</p>
<a class="header" href="print.html#34-static-analysis-at-the-core" id="34-static-analysis-at-the-core"><h2>3.4 Static Analysis at the Core</h2></a>
<p>Static analysis tools, like <code>splint</code> for C <a href="http://splint.org/" title="Splint"><em>(ref)</em></a> are an invaluable tool for Operating Systems programming, particularly when working on large codebases with multiple programmers.  Rust's type system and region based memory, based on Cyclone <a href="http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf" title="Region-Based Memory Management in Cyclone"><em>(ref)</em></a>, are particularly well suited to static analysis. Indeed, <code>rustc</code> itself performs a tremendous amount of static analysis without the help of external tools. The type system carries all the information necessary for the compiler to understand all possible control flows of the program, all possible (recoverable) errors which arise, and the lifetimes of each region of memory.</p>
<p>Of particular interest is <code>rustc</code>'s &quot;Borrow Checker&quot; which analyzes and understands the pointer system and is able to verify data safety, even across multiple threads. The borrow checker is an area of active research <a href="ftp://ftp.cs.washington.edu/tr/2015/03/UW-CSE-15-03-02.pdf" title="Patina: A Formalization of the Rust Programming Language"><em>(ref)</em></a>.  As a result of the static analysis done by <code>rustc</code> it is able to infer information about (but is not limited to):</p>
<ul>
<li>Unused results, variables and functions.</li>
<li>Unreachable code.</li>
<li>Unsafe pointer sharing (multiple mutable pointers.)</li>
<li>Incorrect type matching and lossy casts.</li>
<li>Use-after-free errors.</li>
<li>Unclear lifetimes (asking for either clarity or refactoring.)</li>
</ul>
<a class="header" href="print.html#35-threads-that-dont-bite" id="35-threads-that-dont-bite"><h2>3.5 Threads that don't Bite</h2></a>
<p>Threading is perhaps one of the most powerful and robust features of Rust. The characteristics detailed above culminate in a sort of <em>tour de force</em> when used bravely in a threaded context.</p>
<p>Harnessing the power of ownership semantics, the type system, the standard library's threading modules there are a number of tools available <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" title="Fearless Concurrency"><em>(ref)</em></a>:</p>
<p><strong>Channels</strong> provide a way to transfer messages (and ownership) between threads without fear of there being later (unsafe) access to the data by other threads. The default channel provided by the standard library is a Multiple-Producer, Single-Consumer channel.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::sync::mpsc::{channel, Sender, Receiver};
let (send, receive) = channel();
# let send: Sender&lt;u8&gt; = send;

#}</code></pre></pre>
<p><strong>Locks</strong> can encapsulate data such that access is only granted if the lock is held. In Rust, you <strong>don't lock code, you lock data</strong>, and it is safer because of it. Locks are typically represented by <code>Mutex</code>s and shared between threads with an Atomically Reference Counted structure (<code>Arc</code>). It should be noted that this design of locking data prevents a lock from being acquired and never given up, identified as common by Engler <a href="https://web.stanford.edu/%7Eengler/deviant-sosp-01.pdf" title="Bugs as Deviant Behavior: A General Approach to Inferring Errors in Systems Code"><em>(ref)</em></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::sync::{Arc, Mutex};
let data = Arc::new(Mutex::new(0));

#}</code></pre></pre>
<p><strong>Traits</strong> like <code>Sync</code> and <code>Send</code> are implemented on types and symbolize if it can be <em>sent</em> or <em>shared</em> between threads safely. These traits are not just documentation, they are intrinsic to the language.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Safe to share between threads.
use std::marker::Sync;
// Safe to transfer between threads.
use std::marker::Send;

#}</code></pre></pre>
<p>Rust's concurrency primitives are powerful and composable, allowing users to implement other, more fearless forms of concurrency such as <strong>sharing stack frames</strong>. For example, here's a demonstration of a third-party crate called <strong>crossbeam</strong> that allows us to safely operate concurrently on stack-allocated data: <a href="http://aturon.github.io/crossbeam-doc/crossbeam/struct.Scope.html#method.spawn" title="crossbeam::Scope::spawn"><em>(ref)</em></a></p>
<pre><code class="language-rust ignore">extern crate crossbeam;

fn main() {
    let items = [1, 2, 3];

    crossbeam::scope(|scope| {
        for item in &amp;items {
            scope.spawn(move || {
                println!(&quot;{}&quot;, item);
            });
        }
    });
}
</code></pre>
<p>This same crate also provides primitives for building lock-free concurrent data structures without the overhead of a garbage collector <a href="http://aturon.github.io/blog/2015/08/27/epoch/" title="Lock-freedom without garbage collection"><em>(ref)</em></a>, again demonstrating Rust's capacity for building safe, efficient, and reusable concurrent components.</p>
<a class="header" href="print.html#4-safety-tools-and-community" id="4-safety-tools-and-community"><h1>4. Safety, Tools, and Community</h1></a>
<p>The concept of &quot;Safety&quot; in code is often poorly defined, but can be considered in three categories:</p>
<ul>
<li><strong>Type Safety</strong> prevents or discourages type errors, such as treating a <code>float</code> like an <code>int</code>. Rust and languages like Haskell excel here as their type systems are strong, explicit (but often inferred), and do not include the notion of a <code>null</code> that can go anywhere indiscriminately.</li>
<li><strong>Memory Safety</strong> reduces or eliminates the possibility of mistakes like writing a 64 bit value into a 32 bit space (overwriting unintended data), or multi-threaded mutable access to the same memory. Rust's borrow checker effectively eliminates data races in safe code and strong type safety prevents unintended clobbering.</li>
<li><strong>Thread Safety</strong> prevents inter-thread race conditions, such as one thread exiting when another thread is waiting on data from it. Rust provides some robust tools for managing thread pools integrated into its type system, however some mistakes are still possible if the programmer works hard enough to accomplish them.</li>
</ul>
<p>Rust advertises both type safety and data safety. There is still research and development to be done before it can truly be considered thread-safe.</p>
<a class="header" href="print.html#41-tooling" id="41-tooling"><h2>4.1 Tooling</h2></a>
<p>Rust has a robust, opinionated set of tooling. The Rust standard distribution includes <code>rustc</code> (the compiler), <code>cargo</code> (a package manager and build tool), and <code>rustdoc</code> (a documentation generator). Currently there is work being done on a <code>rustfmt</code> which would function the same as Go's venerable <code>gofmt</code>.</p>
<p>Package management via <code>cargo</code> is a feature Rust has inherited from several other modern languages. All package dependencies, build options, and tasks are defined in a <code>Cargo.toml</code> file. Dependencies are checked and (if necessary) pulled on <code>cargo build</code>, <code>test</code>, or <code>doc</code>.</p>
<p>Rust supports both <em>unit tests</em> and <em>integration tests</em> by default. Unit tests may appear wherever is appropriate in the code and are annotated by <code>#[test]</code>, it is common for designers to include a <code>test</code> module in their code. Integration tests are written in the <code>tests/</code> directory and allow a package to be tested as a depended upon library. Testing is done by simply invoking <code>cargo test</code> in the project directory. These features blow away barriers which programmers might face in other languages that would prevent them from bothering to test. Additionally, it makes marking Rust based projects very easy, all an instructor needs to do is provide (or replace) the <code>tests/</code> directory with an appropriate suite.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
fn test_passes() {
    assert_eq!(true, true);
}
#[test]
#[should_panic]
fn test_fails() {
    assert!(true == false);
}

#}</code></pre></pre>
<p>Having a standardized, high quality documentation format is invaluable for programmers, and Rust facilitates this. Documentation comments can be placed anywhere in the code using <code>///</code> for function level documentation or <code>//!</code> for module level documentation. Documentation is in a common markdown format, code samples included in the documentation are automatically processed as unit tests. Generating documentation is done by <code>cargo doc</code>, which generates HTML and manpage documentation. Many Rust projects even go so far as to automate the unit testing and documentation generation step and hook it into their git commits <a href="http://hoverbear.org/2015/03/06/rust-travis-github-pages/" title="Rust, Travis, and Github Pages"><em>(ref)</em></a>.</p>
<a class="header" href="print.html#42-community" id="42-community"><h2>4.2 Community</h2></a>
<p>One of the biggest dangers in choosing a language that &quot;Is not C&quot; to teach operating systems in is that it can be very difficult for students to get help.  Mozilla's IRC network hosts the popular #rust channel which regularly has over 800 members at any given time. <a href="http://crates.io/"><code>crates.io</code></a> hosts over 2300 packages. The language reached 1.0 on May 15, 2015 <a href="http://blog.rust-lang.org/2015/05/15/Rust-1.0.html" title="Announcing Rust 1.0"><em>(ref)</em></a> and has been in development since 2006. The community is active and friendly with a variety special interest groups.</p>
<p>Best of all, there is active operating system development in Rust. There is a project to develop <code>coreutils</code> <a href="https://github.com/uutils/coreutils" title="uutils/coreutils"><em>(ref)</em></a>, a kernel <a href="http://jvns.ca/blog/2014/03/12/the-rust-os-story/" title="Writing an OS in Rust in Tiny Steps"><em>(ref)</em></a>, operating systems <a href="https://scialex.github.io/reenix.pdf" title="Reenix: Implementing a Unix-Like Operating System in Rust"><em>(ref)</em></a>, and embedded system platforms <a href="http://zinc.rs/" title="zinc.rs"><em>(ref)</em></a>. At the time of writing, these projects are young enough that students could even contribute components upstream.</p>
<a class="header" href="print.html#50-conclusion-and-future-work" id="50-conclusion-and-future-work"><h1>5.0 Conclusion and Future Work</h1></a>
<p>In this work we have overviewed some of the reasons to consider Rust as the lanugage for a new generation of systems programmers by highlighting precisely how Rust prevents classic bugs.  There is a considerable amount of research remaining regarding Rust's uses in systems code and programming in the large in general. We seek to foster knowledge of the language at the University of Victoria and are working on developing distributed consensus algorithms like Raft <a href="http://ramcloud.stanford.edu/raft.pdf" title="In Search of an Understandable Consensus Algorithm"><em>(ref)</em></a> and next generation initialization systems in the spirit of OpenRC.</p>
<blockquote>
<p><a href="https://www.hoverbear.org/2015/09/12/understand-over-guesswork/"><em>Originally published 2015-09-12</em></a></p>
<p><em>License: TBD</em></p>
</blockquote>
<a class="header" href="print.html#where-rust-really-shines" id="where-rust-really-shines"><h1>Where Rust Really Shines</h1></a>
<p>Yesterday I was working on a <a href="https://github.com/rust-lang/rust/pull/25027">small feature</a>
for the Rust compiler, and came across a situation which really showcased Rust's
awesomeness as a language.</p>
<p>There was a struct which was exposed to an API,
and I wished to give it access to a list of things known as &quot;attributes&quot;, where the list was <a href="http://doc.rust-lang.org/std/vec/struct.Vec.html">a heap-allocated vector</a>.</p>
<p>Now, I have two ways of actually giving the struct access to a vector. I can either clone it (i.e. make a copy of its contents),
or use a reference (pointer) to it or its contents.</p>
<p>In a language like C++ there's only once choice in this situation; that is
to clone the vector<sup class="footnote-reference"><a href="print.html#1">1</a></sup>. In a large C++ codebase if I wished to use a pointer I would need to be sure that the vector
isn't deallocated by the time I'm done with it, and more importantly, to be sure that no other code pushes to the vector (when a vector overflows its
capacity it will be reallocated, invalidating any other pointers to its contents).</p>
<p>For a smaller codebase this might be possible, but in this specific case it could have taken me a while to become sure of this.
The code was related to the &quot;expansion&quot; portion of compilation, where the AST is expanded to a bigger AST. A lot of things change and get
moved around, so it is reasonable to assume that it might not be possible to safely use it.
I would have had to find out where the vector is originally stored; all the entry points for the code I was
modifying, and make sure it isn't being mutated (not as hard in Rust, but I would
still need to muck around a large codebase). And then I would have to somehow make sure that nobody tries to mutate it
in the future. This is a task which I would not even consider trying in C++.</p>
<p>However, I had another option here, because this was Rust. In Rust I can store a reference to the contents of the vector
without fear of invalidation, since the compiler will prevent me from using the vector in a way that could cause unsafety.
Such a reference is known as a <a href="http://doc.rust-lang.org/std/primitive.slice.html">slice</a>.</p>
<p>Whilst in C++ I would have to manually go through a lot of code to be sure of safety
(and even after all that be left with code that would be brittle to changes elsewhere
the codebase), in Rust the compiler can do this for me!</p>
<p>Being able to do this was important
— this code is called quite often for a regular compile, and all those
extra allocations could be heavy, especially given that this was a feature that would be used
by very few.</p>
<p>So first I started off by adding a field to the <code>FieldInfo</code> struct which was a <a href="https://github.com/Manishearth/rust/commit/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b#diff-6fa0bf762b2ef85690cce1a0fd8d5a20R285">slice of attributes</a>. Notice that I added a lifetime specifier, <a href="https://github.com/Manishearth/rust/commit/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b#diff-6fa0bf762b2ef85690cce1a0fd8d5a20R273">the <code>'a</code></a> to the struct definition.</p>
<pre><code class="language-rust ignore">/// Summary of the relevant parts of a struct/enum field.
pub struct FieldInfo&lt;'a&gt; {
    /// ...
    /// The attributes on the field
    pub attrs: &amp;'a [ast::Attribute],
}
</code></pre>
<p>For those of you new to Rust, a lifetime is part of the type of a reference. It's related to the scope of the reference, and generally can be treated as
a generic parameter. So, for example, here, I have a <code>FieldInfo</code> with a lifetime parameter of <code>'a</code> where <code>'a</code> is the lifetime of the inner slice of attributes.
If I construct this struct with slices from different scopes, its type will be different each time. Lifetimes can get automatically cast depending on their context however,
and quite often they get elided away, so one doesn't need to specify them that much (aside from struct/enum definitions). You can find more information <a href="http://doc.rust-lang.org/nightly/book/ownership.html#lifetimes">in the Rust book</a></p>
<p>I then updated code everywhere to pass the attributes from <a href="https://github.com/Manishearth/rust/commit/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b#diff-6fa0bf762b2ef85690cce1a0fd8d5a20R1440">their source</a>
to <a href="https://github.com/Manishearth/rust/commit/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b#diff-6fa0bf762b2ef85690cce1a0fd8d5a20R1155">their destination</a> through the chained methods.</p>
<p>An important thing to note here is that none of the lifetime specifiers you see now in the commit were added when I did this. For example, <a href="https://github.com/Manishearth/rust/commit/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b#diff-6fa0bf762b2ef85690cce1a0fd8d5a20R1410">the return value
of <code>create_struct_pattern</code></a> was
<code>(P&lt;ast::Pat&gt;, Vec&lt;(Span, Option&lt;Ident&gt;, P&lt;Expr&gt;, &amp;[ast::Attribute])&gt;)</code> at this point, not <code>(P&lt;ast::Pat&gt;, Vec&lt;(Span, Option&lt;Ident&gt;, P&lt;Expr&gt;, &amp;'a [ast::Attribute])&gt;)</code>.
You can ignore the complicated types being passed around, for now just pretend that a slice of attributes was returned.</p>
<p>Now comes the magic. After these small changes necessary for the feature, I basically let the compiler do the rest of the work. See, at this point the code was wrong.
I had forgotten lifetime specifiers in places where they were important, and still wasn't sure if storing a reference would in fact be possible in the first place.
However, the compiler was smart enough to figure things out for me. It would tell me to add lifetime specifiers, and I would add them.</p>
<p>First, the compiler asked me to add <a href="https://github.com/Manishearth/rust/commit/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b#diff-6fa0bf762b2ef85690cce1a0fd8d5a20R297">a lifetime to the <code>FieldInfo</code> parts of <code>SubstructureFields</code></a>. So, the following:</p>
<pre><code class="language-rust ignore">pub enum SubstructureFields&lt;'a&gt; {
    Struct(Vec&lt;FieldInfo&gt;),
    EnumMatching(usize, &amp;'a ast::Variant, Vec&lt;FieldInfo&gt;),
    // ...
}
</code></pre>
<p>became</p>
<pre><code class="language-rust ignore">pub enum SubstructureFields&lt;'a&gt; {
    Struct(Vec&lt;FieldInfo&lt;'a&gt;&gt;),
    EnumMatching(usize, &amp;'a ast::Variant, Vec&lt;FieldInfo&lt;'a&gt;&gt;),
    // ...
}
</code></pre>
<p>This needed to happen because elision doesn't work for structs and enums,
and besides, the compiler would need to know if the <code>&amp;ast::Variant</code> was supposed to be the same lifetime as the parameter of the <code>FieldInfo</code>s. I decided
to just use the existing <code>'a</code> parameter, which meant that yes, the <code>&amp;ast::Variant</code> was supposed to live just as long. I could also have opted to give the <code>FieldInfo</code>s
a different lifetime by adding a <code>'b</code> parameter, but I guessed that it would work this way too (knowing the origin of the fieldinfo and variant, and that implicit lifetime casting would
fix most issues that cropped up). I didn't need to think this out much, though — the compiler gave me a suggestion and I could simply copy it.</p>
<p>The next error was in <a href="https://github.com/Manishearth/rust/commit/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b#diff-6fa0bf762b2ef85690cce1a0fd8d5a20R1463"><code>create_enum_variant_pattern()</code></a>
and <a href="https://github.com/Manishearth/rust/commit/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b#diff-6fa0bf762b2ef85690cce1a0fd8d5a20R1404"><code>create_struct_pattern()</code></a> as well as some other places.</p>
<p>Here, the method had a signature of</p>
<pre><code class="language-rust ignore">
fn create_enum_variant_pattern(&amp;self,
                               cx: &amp;mut ExtCtxt,
                               enum_ident: ast::Ident,
                               variant: &amp;ast::Variant,
                               prefix: &amp;str,
                               mutbl: ast::Mutability)
-&gt; (P&lt;ast::Pat&gt;, Vec&lt;(Span, Option&lt;Ident&gt;, P&lt;Expr&gt;, &amp;[ast::Attribute])&gt;)
</code></pre>
<p>and I changed it to</p>
<pre><code class="language-rust ignore">
fn create_enum_variant_pattern&lt;'a&gt;(&amp;self,
                               cx: &amp;mut ExtCtxt,
                               enum_ident: ast::Ident,
                               variant: &amp;'a ast::Variant,
                               prefix: &amp;str,
                               mutbl: ast::Mutability)
-&gt; (P&lt;ast::Pat&gt;, Vec&lt;(Span, Option&lt;Ident&gt;, P&lt;Expr&gt;, &amp;'a [ast::Attribute])&gt;)
</code></pre>
<p>In this case, the code was uncomfortable with taking a slice of attributes out of an arbitrary <code>StructDef</code> reference and returning it. What if the <code>StructDef</code> doesn't live long enough?
Generally the compiler internally figures out the lifetimes necessary and uses them here, but if you have too many references there's no single way to make the fix.
In this case, the compiler suggested I add a <code>'a</code> to <code>&amp;StructDef</code> and the returned <code>&amp;[Attribute]</code>, and I did so. The <code>'a</code> lifetime was declared at <a href="https://github.com/Manishearth/rust/blob/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b/src/libsyntax/ext/deriving/generic/mod.rs#L379">the top of the impl</a>, so it was the lifetime parameter of <code>self</code><sup class="footnote-reference"><a href="print.html#2">2</a></sup>. This meant that the returned attribute of the function will
have a lifetime tied to <code>self</code> and the input <code>StructDef</code>, and due to this it cannot outlive the inputs, which is what we wanted in the first place. In essence, I took a bit of code that was doing:</p>
<pre><code class="language-rust ignore">fn minicreate(&amp;self, variant: &amp;ast::Variant) -&gt; &amp;[ast::Attribute] {
    // do stuff
    // return variant.attributes
}
</code></pre>
<p>and changed it to</p>
<pre><code class="language-rust ignore">// we are sure that the returned slice cannot outlive the variant argument
fn minicreate&lt;'a&gt;(&amp;self, variant: &amp;'a ast::Variant) -&gt; &amp;'a [ast::Attribute] {
    // do stuff
    // return variant.attributes
}
</code></pre>
<p>Again, I didn't need to think this out much (I'm only thinking it through now for this blog post). I followed the suggestion given to me by the compiler:</p>
<pre><code class="language-text">error: cannot infer an appropriate lifetime for automatic coercion due to conflicting requirements
help: consider using an explicit lifetime parameter as shown: fn create_enum_variant_pattern&lt;'a&gt;(&amp;self, cx: &amp;mut ExtCtxt, enum_ident: ast::Ident, variant: &amp;'a ast::Variant, prefix: &amp;str, mutbl: ast::Mutability) -&gt; (P&lt;ast::Pat&gt;, Vec&lt;(Span, Option&lt;Ident&gt;, P&lt;Expr&gt;, &amp;'a [ast::Attribute])&gt;)

</code></pre>
<p>There were a couple of similar errors elsewhere that were caused by tying these two lifetimes together. Since these methods were chained, updating the lifetimes of a child method
would mean that I would have to now update the parent method which passes its arguments down to the children and returns a modification of its return value (and thus must now impose the
same restrictions on its own signature). All of this was done by just listening to the suggestions of the compiler (which all contain a function signature to try out). In <a href="https://github.com/Manishearth/rust/commit/ede7a6dc8ff5455f9d0d39a90e6d11e9a374e93b#diff-6fa0bf762b2ef85690cce1a0fd8d5a20R890">some cases</a> I introduced a <code>'b</code> lifetime, because tying it to <code>'a</code>
(the self lifetime parameter) was possibly too restrictive. All of this at the suggestion of the compiler.</p>
<p>While this all seems long and complicated, in reality it wasn't. I simply added the field to the initial struct, tried compiling a couple of times to figure out which code needed updating
to pass around the attributes, and then went through 3-4 more compilation attempts to fix the lifetimes. It didn't take long, and I didn't need to put much mental effort into it. I just
listened to the compiler, and it worked.</p>
<p>And now I trust completely that that code will not cause any segfaults due to attempted access of a destroyed or moved vector. And this is despite the fact that I <em>still</em> don't know
where that particular vector is modified or destroyed — I didn't explore that far because I didn't need to! (or want to :P)</p>
<p>And this is one place Rust really shines. It lets you do optimizations which you wouldn't dream of doing in C++. In fact, while the C++ way of looking at this problem
would probably be to just clone and move on, most Rust programmers would think of using slices as the default, and not even consider it an &quot;optimization&quot;. And again, this wasn't
with much cognitive overhead; I could just follow the compiler and it fixed everything for me.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Some people have pointed out that a shared pointer to the vector itself would work here too. This is correct, but a shared pointer also has a runtime overhead, and more importantly doesn't prevent iterator invalidation. I had no idea how the vector was being used elsewhere, so this was a risk I didn't want to take. Additionally, whilst a shared pointer to the vector itself is immune to the issue of the vector being moved, since this was an API, someone consuming the API might take a reference of an attribute and hold on to it long enough for it to become invalidated. This is something we can't have either -- an API consumer should not have to worry about where the pointers will invalidate.
<sup class="footnote-reference"><a href="print.html#2">2</a></sup>: Note: This is not the lifetime of the reference <code>&amp;self</code>, which is the lifetime of the pointer (<code>&amp;'b self</code>), but the lifetime parameter of <code>self</code>, a <code>TraitDef&lt;'a&gt;</code>, which has a lifetime parameter for its child fields.</p>
<blockquote>
<p><a href="https://manishearth.github.io/blog/2015/05/03/where-rust-really-shines/"><em>Originally published 2015-05-03</em></a></p>
<p><em>License: TBD</em></p>
</blockquote>
</div>
<a class="header" href="print.html#the-problem-with-single-threaded-shared-mutability" id="the-problem-with-single-threaded-shared-mutability"><h1>The Problem with Single-threaded Shared Mutability</h1></a>
<p>This is a post that I've been meaning to write for a while now; and the release of Rust 1.0 gives
me the perfect impetus to go ahead and do it.</p>
<p>Whilst this post discusses a choice made in the design of Rust; and uses examples in Rust; the principles discussed
here apply to other languages for the most part. I'll also try to make the post easy to understand for those without
a Rust background; please let me know if some code or terminology needs to be explained.</p>
<p>What I'm going to discuss here is the choice made in Rust to disallow having multiple mutable aliases
to the same data (or a mutable alias when there are active immutable aliases),
<strong>even from the same thread</strong>. In essence, it disallows one from doing things like:</p>
<pre><code class="language-rust ignore">let mut x = Vec::new();
{
    let ptr = &amp;mut x; // Take a mutable reference to `x`
    ptr.push(1); // Allowed
    let y = x[0]; // Not allowed (will not compile): as long as `ptr` is active,
                  // x cannot be read from ...
    x.push(1);    // .. or written to
}


// alternatively,

let mut x = Vec::new();
x.push(1); // Allowed
{
    let ptr = &amp;x; // Create an immutable reference
    let y = ptr[0]; // Allowed, nobody can mutate
    let y = x[0]; // Similarly allowed
    x.push(1); // Not allowed (will not compile): as long as `ptr` is active,
               // `x` is frozen for mutation
}

</code></pre>
<p>This is essentially the &quot;Read-Write lock&quot; (RWLock) pattern, except it's not being used in a
threaded context, and the &quot;locks&quot; are done via static analysis (compile time &quot;borrow checking&quot;).</p>
<p>Newcomers to the language have the recurring question as to why this exists. <a href="http://doc.rust-lang.org/nightly/book/ownership.html">Ownership semantics</a>
and immutable <a href="http://doc.rust-lang.org/nightly/book/references-and-borrowing.html">borrows</a> can be grasped because there are concrete examples from languages like C++ of
problems that these concepts prevent. It makes sense that having only one &quot;owner&quot; and then multiple &quot;borrowers&quot; who
are statically guaranteed to not stick around longer than the owner will prevent things like use-after-free.</p>
<p>But what could possibly be wrong with having multiple handles for mutating an object? Why do we need an RWLock pattern? <sup class="footnote-reference"><a href="print.html#0">1</a></sup></p>
<div class="footnote-definition" id="0"><sup class="footnote-definition-label">1</sup>
<p>Hereafter referred to as &quot;The Question&quot;</p>
<a class="header" href="print.html#it-causes-memory-unsafety" id="it-causes-memory-unsafety"><h2>It causes memory unsafety</h2></a>
<p>This issue is specific to Rust, and I promise that this will be the only Rust-specific answer.</p>
</div>
<p><a href="http://doc.rust-lang.org/nightly/book/enums.html">Rust enums</a> provide a form of algebraic data types. A Rust enum is allowed to &quot;contain&quot; data,
for example you can have the enum</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
enum StringOrInt {
    Str(String),
    Int(i64)
}

#}</code></pre></pre>
<p>which gives us a type that can either be a variant <code>Str</code>, with an associated string, or a variant <code>Int</code><sup class="footnote-reference"><a href="print.html#1">2</a></sup>, with an associated integer.</p>
<p>With such an enum, we could cause a segfault like so:</p>
<pre><code class="language-rust ignore">let x = Str(&quot;Hi!&quot;.to_string()); // Create an instance of the `Str` variant with associated string &quot;Hi!&quot;
let y = &amp;mut x; // Create a mutable alias to x

if let Str(ref insides) = x { // If x is a `Str`, assign its inner data to the variable `insides`
    *y = Int(1); // Set `*y` to `Int(1), therefore setting `x` to `Int(1)` too
    println!(&quot;x says: {}&quot;, insides); // Uh oh!
}
</code></pre>
<p>Here, we invalidated the <code>insides</code> reference because setting <code>x</code> to <code>Int(1)</code> meant that there is no longer a string inside it.
However, <code>insides</code> is still a reference to a <code>String</code>, and the generated assembly would try to dereference the memory location where
the pointer to the allocated string <em>was</em>, and probably end up trying to dereference <code>1</code> or some nearby data instead, and cause a segfault.</p>
<p>Okay, so far so good. We know that for Rust-style enums to work safely in Rust, we need the RWLock pattern. But are there any other
reasons we need the RWLock pattern? Not many languages have such enums, so this shouldn't really be a problem for them.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">2</sup>
<p>Note: <code>Str</code> and <code>Int</code> are variant names which I chose; they are not keywords. Additionally, I'm using &quot;associated foo&quot; loosely here; Rust <em>does</em> have a distinct concept of &quot;associated data&quot; but it's not relevant to this post.</p>
</div>
<a class="header" href="print.html#iterator-invalidation" id="iterator-invalidation"><h2>Iterator invalidation</h2></a>
<p>Ah, the example that is brought up almost every time the question above is asked. While I've been quite guilty of
using this example often myself (and feel that it is a very appropriate example that can be quickly explained),
I also find it to be a bit of a cop-out, for reasons which I will explain below. This is partly why I'm writing
this post in the first place; a better idea of the answer to The Question should be available for those who want
to dig deeper.</p>
<p>Iterator invalidation involves using tools like iterators whilst modifying the underlying dataset somehow.</p>
<p>For example,</p>
<pre><code class="language-rust ignore">
let buf = vec![1,2,3,4];

for i in &amp;buf {
    buf.push(i);
}
</code></pre>
<p>Firstly, this will loop infinitely (if it compiled, which it doesn't, because Rust prevents this). The
equivalent C++ example would be <a href="http://stackoverflow.com/questions/5638323/modifying-a-data-structure-while-iterating-over-it">this one</a>, which I <a href="http://manishearth.github.io/Presentations/Rust/#/1/2">use</a> at every opportunity.</p>
<p>What's happening in both code snippets is that the iterator is really just a pointer to the vector and an index.
It doesn't contain a snapshot of the original vector; so pushing to the original vector will make the iterator iterate for
longer. Pushing once per iteration will obviously make it iterate forever.</p>
<p>The infinite loop isn't even the real problem here. The real problem is that after a while, we could get a segmentation fault.
Internally, vectors have a certain amount of allocated space to work with. If the vector is grown past this space,
a new, larger allocation may need to be done (freeing the old one), since vectors must use contiguous memory.</p>
<p>This means that when the vector overflows its capacity, it will reallocate, invalidating the reference stored in the
iterator, and causing use-after-free.</p>
<p>Of course, there is a trivial solution in this case — store a reference to the <code>Vec</code>/<code>vector</code> object inside
the iterator instead of just the pointer to the vector on the heap. This leads to some extra indirection or a larger
stack size for the iterator (depending on how you implement it), but overall will prevent the memory unsafety.</p>
<p>This would still cause problems with more complex situations involving multidimensional vectors, however.</p>
<a class="header" href="print.html#its-effectively-threaded" id="its-effectively-threaded"><h2>&quot;It's effectively threaded&quot;</h2></a>
<blockquote>
<p>Aliasing with mutability in a sufficiently complex, single-threaded program is effectively the same thing as
accessing data shared across multiple threads without a lock</p>
</blockquote>
<p>(The above is my paraphrasing of someone else's quote; but I can't find the original or remember who made it)</p>
<p>Let's step back a bit and figure out why we need locks in multithreaded programs. The way caches and memory work;
we'll never need to worry about two processes writing to the same memory location simultaneously and coming up with
a hybrid value, or a read happening halfway through a write.</p>
<p>What we do need to worry about is the rug being pulled out underneath our feet. A bunch of related reads/writes
would have been written with some invariants in mind, and arbitrary reads/writes possibly happening between them
would invalidate those invariants. For example, a bit of code might first read the length of a vector, and then go ahead
and iterate through it with a regular for loop bounded on the length.
The invariant assumed here is the length of the vector. If <code>pop()</code> was called on the vector in some other thread, this invariant could be
invalidated after the read to <code>length</code> but before the reads elsewhere, possibly causing a segfault or use-after-free in the last iteration.</p>
<p>However, we can have a situation similar to this (in spirit) in single threaded code. Consider the following:</p>
<pre><code class="language-rust ignore">let x = some_big_thing();
let len = x.some_vec.len();
for i in 0..len {
    x.do_something_complicated(x.some_vec[i]);
}
</code></pre>
<p>We have the same invariant here; but can we be sure that <code>x.do_something_complicated()</code> doesn't modify <code>x.some_vec</code> for
some reason? In a complicated codebase, where <code>do_something_complicated()</code> itself calls a lot of other functions which may
also modify <code>x</code>, this can be hard to audit.</p>
<p>Of course, the above example is a simplification and contrived; but it doesn't seem unreasonable to assume that such
bugs can happen in large codebases — where many methods being called have side effects which may not always be evident.</p>
<p>Which means that in large codebases we have almost the same problem as threaded ones. It's very hard to maintain invariants
when one is not completely sure of what each line of code is doing. It's possible to become sure of this by reading through the code
(which takes a while), but further modifications may also have to do the same. It's impractical to do this all the time and eventually
bugs will start cropping up.</p>
<p>On the other hand, having a static guarantee that this can't happen is great. And when the code is too convoluted for
a static guarantee (or you just want to avoid the borrow checker), a single-threaded RWlock-esque type called <a href="https://doc.rust-lang.org/core/cell/struct.RefCell.html">RefCell</a>
is available in Rust. It's a type providing interior mutability and behaves like a runtime version of the borrow checker.
Similar wrappers can be written in other languages.</p>
<p>Edit: In case of many primitives like simple integers, the problems with shared mutability turn out to not be a major issue.
For these, we have a type called <a href="http://doc.rust-lang.org/nightly/std/cell/struct.Cell.html">Cell</a> which lets these be mutated and shared simultaenously. This works on all <code>Copy</code>
types; i.e. types which only need to be copied on the stack to be copied. (Unlike types involving pointers or other indirection)</p>
<p>This sort of bug is a good source of reentrancy problems too.</p>
<a class="header" href="print.html#safe-abstractions" id="safe-abstractions"><h2>Safe abstractions</h2></a>
<p>In particular, the issue in the previous section makes it hard to write safe abstractions, especially with generic code.
While this problem is clearer in the case of Rust (where abstractions are expected to be safe and preferably low-cost),
this isn't unique to any language.</p>
<p>Every method you expose has a contract that is expected to be followed. Many times, a contract is handled by type safety itself,
or you may have some error-based model to throw out uncontractual data (for example, division by zero).</p>
<p>But, as an API (can be either internal or exposed) gets more complicated, so does the contract. It's not always possible to verify that the contract is being violated
at runtime either, for example many cases of iterator invalidation are hard to prevent in nontrivial code even with asserts.</p>
<p>It's easy to create a method and add documentation &quot;the first two arguments should not point to the same memory&quot;.
But if this method is used by other methods, the contract can change to much more complicated things that are harder to express
or check. When generics get involved, it only gets worse; you sometimes have no way of forcing that there are no shared mutable aliases,
or of expressing what isn't allowed in the documentation. Nor will it be easy for an API consumer to enforce this.</p>
<p>This makes it harder and harder to write safe, generic abstractions. Such abstractions rely on invariants, and these invariants can often
be broken by the problems in the previous section. It's not always easy to enforce these invariants, and such abstractions will either
be misused or not written in the first place, opting for a heavier option. Generally one sees that such abstractions or patterns are avoided
altogether, even though they may provide a performance boost, because they are risky and hard to maintain. Even if the present version of
the code is correct, someone may change something in the future breaking the invariants again.</p>
<p><a href="http://manishearth.github.io/blog/2015/05/03/where-rust-really-shines/">My previous post</a> outlines a situation where Rust was able to choose
the lighter path in a situation where getting the same guarantees would be hard in C++.</p>
<p>Note that this is a wider problem than just with mutable aliasing. Rust has this problem too, but not when it comes to mutable aliasing.
Mutable aliasing is important to fix however, because we can make a lot of assumptions about our program when there are no mutable aliases.
Namely, by looking at a line of code we can know what happened wrt the locals. If there is the possibility of mutable aliasing out there; there's the
possibility that other locals were modified too. A very simple example is:</p>
<pre><code class="language-rust ignore">fn look_ma_no_temp_var_l33t_interview_swap(&amp;mut x, &amp;mut y) {
    *x = *x + *y;
    *y = *x - *y;
    *x = *x - *y;
}
// or
fn look_ma_no_temp_var_rockstar_interview_swap(&amp;mut x, &amp;mut y) {
    *x = *x ^ *y;
    *y = *x ^ *y;
    *x = *x ^ *y;
}
</code></pre>
<p>In both cases, when the two references are the same<sup class="footnote-reference"><a href="print.html#2">3</a></sup>, instead of swapping, the two variables get set to zero.
A user (internal to your library, or an API consumer) would expect <code>swap()</code> to not change anything when fed equal
references, but this is doing something totally different. This assumption could get used in a program; for example instead
of skipping the passes in an array sort where the slot is being compared with itself, one might just go ahead with it
because <code>swap()</code> won't change anything there anyway; but it does, and suddenly your sort function fills everything with
zeroes. This could be solved by documenting the precondition and using asserts, but the documentation gets harder and harder
as <code>swap()</code> is used in the guts of other methods.</p>
<p>Of course, the example above was contrived. It's well known that those <code>swap()</code> implementations have that precondition,
and shouldn't be used in such cases. Also, in most swap algorithms it's trivial to ignore cases when you're comparing
an element with itself, generally done by bounds checking.</p>
<p>But the example is a simplified sketch of the problem at hand.</p>
<p>In Rust, since this is statically checked, one doesn't worry much about these problems, and
robust APIs can be designed since knowing when something won't be mutated can help simplify
invariants.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">3</sup>
<p>Note that this isn't possible in Rust due to the borrow checker.</p>
<a class="header" href="print.html#wrapping-up" id="wrapping-up"><h2>Wrapping up</h2></a>
</div>
<p>Aliasing that doesn't fit the RWLock pattern is dangerous. If you're using a language like
Rust, you don't need to worry. If you're using a language like C++, it can cause memory unsafety,
so be very careful. If you're using a language like Java or Go, while it can't cause memory unsafety,
it will cause problems in complex bits of code.</p>
<p>This doesn't mean that this problem should force you to switch to Rust, either. If you feel that you
can avoid writing APIs where this happens, that is a valid way to go around it. This problem is much
rarer in languages with a GC, so you might be able to avoid it altogether without much effort. It's
also okay to use runtime checks and asserts to maintain your invariants; performance isn't everything.</p>
<p>But this <em>is</em> an issue in programming; and make sure you think of it when designing your code.</p>
<p><small>Discuss: <a href="https://news.ycombinator.com/item?id=9560158">HN</a>, <a href="http://www.reddit.com/r/rust/comments/369jnx/the_problem_with_singlethreaded_shared_mutability/">Reddit</a></small></p>
<blockquote>
<p><a href="https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/"><em>Originally published 2015-05-17</em></a></p>
<p><em>License: TBD</em></p>
</blockquote>
<hr />
<p>layout: post
title: &quot;Strategies for solving 'cannot move out of' borrowing errors in Rust&quot;
tags:</p>
<ul>
<li>rustlang
status: publish
type: post
published: true</li>
</ul>
<hr />
<p>The rules around <a href="https://doc.rust-lang.org/stable/book/references-and-borrowing.html#the-rules">references and borrowing</a> in Rust are fairly straight-forward. Given an owned variable, we are allowed to have as many <em>immutable</em> references to that variable as we want. Rust defaults to immutability, so even functions like <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.trim">trim</a> are written in such a way that the result is a reference to the original string:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let name = &quot; Herman &quot;.to_string();
   let trimmed_name = name.trim(); // == &amp;[1..n-1]
}
</code></pre></pre>
<p>The only caveat is that I cannot <em>move</em> the <code>name</code> variable anymore. If I try to move <code>name</code>, the compiler will give me an error: <em>cannot move out of <code>name</code> because it is borrowed</em>.</p>
<pre><code class="language-rust ignore">fn main() {
   let name = &quot; Herman &quot;.to_string();
   let trimmed_name = name.trim();

   let owned_name = name; // move error
}
</code></pre>
<p>The compiler knows that <code>trimmed_name</code> is a reference to <code>name</code>. As long as <code>trimmed_name</code> is still in scope, the compiler will not let us pass <code>name</code> to a function, reassign it or do any other <em>move</em> operation. We could <code>clone()</code> the <code>name</code> variable and then trim it, but we really just want to let the compiler know when we are done <em>borrowing</em> <code>name</code>. The key word here is <em>scope</em>. If the reference to <code>name</code> goes out of scope, the compiler will let us <em>move</em> <code>name</code> because it is no longer being <em>borrowed</em>. Let us wrap the call to <code>trim()</code> in curly braces to denote a different scope.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let name = &quot; Herman &quot;.to_string();

   {
      let trimmed_name = name.trim();
   }

   let owned_name = name;
}
</code></pre></pre>
<p>That is simple enough, but let us take it a step further. Suppose we wanted to get back the length of the trimmed string from within our scope. If we do that inside our curly braces, then <code>trimmed_name_len</code> will no longer exist once we leave that scope.</p>
<pre><code class="language-rust ignore">fn main() {
   let name = &quot; Herman &quot;.to_string();

   {
      let trimmed_name = name.trim();
      let trimmed_name_len = trimmed_name.len();
   }

   println!(&quot;Length of trimmed string is {}&quot;, trimmed_name_len); // no such variable error
   let owned_name = name;
}
</code></pre>
<a class="header" href="print.html#strategies" id="strategies"><h2>Strategies</h2></a>
<p>There are a few ways to deal with this. They all look pretty similar, but have different trade-offs. We can return the value from a scoped block of code:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let name = &quot; Herman &quot;.to_string();

   let trimmed_name_len = {
      let trimmed_name = name.trim();
      trimmed_name.len()
   };

   println!(&quot;Length of trimmed string is {}&quot;, trimmed_name_len);
   let owned_name = name;
}
</code></pre></pre>
<p>This is a cheap and quick way to force the reference to go out of scope. It does not require us to specify parameters or their types nor does it require us to specify the return type. It is not reusable though. We can get some more reuse if we use an anonymous function (or closure):</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let name = &quot; Herman &quot;.to_string();

   let f = |name: &amp;str| {
      let trimmed_name = name.trim();
      trimmed_name.len()
   };

   let trimmed_name_len = f(&amp;name);

   println!(&quot;Length of trimmed string is {}&quot;, trimmed_name_len);
   let owned_name = name;
}
</code></pre></pre>
<p>A closure requires us to specify parameters and their types, but makes specifying the return type optional. The way this is written, the anonymous function <code>f</code> is only usable within the function scope. If we want complete reusuability we can use a normal function:</p>
<pre><pre class="playpen"><code class="language-rust">fn len_of_trimmed_string(name: &amp;str) -&gt; usize {
      let trimmed_name = name.trim();
      trimmed_name.len()
}

fn main() {
   let name = &quot; Herman &quot;.to_string();

   let trimmed_name_len = len_of_trimmed_string(name.as_ref());

   println!(&quot;Length of trimmed string is {}&quot;, trimmed_name_len);
   let owned_name = name;
}
</code></pre></pre>
<p>These strategies only work if we are calling immutable functions. We are temporarily keeping the reference to get some other peice of information. This works really well that information is something like implements the <code>Copy</code> trait, such as numbers or booleans. If we wanted to do something like remove all spaces on a string like <code>&quot;H e r m a n&quot;</code> then we are mutating the string. We would have to call <code>name.clone()</code> in order to later <em>move</em> the original <code>name</code> variable.</p>
<a class="header" href="print.html#closure-without-parameters" id="closure-without-parameters"><h3>Closure Without Parameters</h3></a>
<p>You may have wondered if we really did have to specify parameters when using a closure. If we try to access the <code>name</code> variable from within the closure, it will create a reference during compile time. That reference will continue to exist, even if we try to remove the closure <code>f</code> from scope. Example:</p>
<pre><code class="language-rust ignore">fn main() {
   let name = &quot; Herman &quot;.to_string();

   let f = || {
      let trimmed_name = name.trim();
      trimmed_name.len()
   };

   let trimmed_name_len = f();

   println!(&quot;Length of trimmed string is {}&quot;, trimmed_name_len);
   let owned_name = name; // move error
}
</code></pre>
<pre><code class="language-ignore">error: cannot move out of `name` because it is borrowed
   let owned_name = name;
               ^~~~~~~~~~
note: borrow of `name` occurs here
    let f = || {
       let trimmed_name = name.trim();
       trimmed_name.len()
    };
note: in expansion of closure expansion
</code></pre>
<a class="header" href="print.html#real-world-example" id="real-world-example"><h2>Real World Example</h2></a>
<p>The above examples are pretty contrived. However, you will run into this when you are breaking down functions into smaller parts. In this below example, I was using a <code>find_matches</code> function that required an input of type <code>&amp;str</code>. Given a <code>PathBuf</code>, I needed to call the immutable <code>file_name()</code> method on it and then convert it to a <code>&amp;str</code> by calling <code>to_str()</code> before calling <code>find_matches(file_name)</code>. In order to return a tuple of <code>(p, matches)</code>, I had to make sure reference created by <code>file_name</code> was out of scope. I chose to use a function, but could have use curly braces or a closure as we discussed above.</p>
<pre><code class="language-rust ignore">fn find_matches(s: &amp;str) -&gt; f64 {
   // ...
}

fn count_filename_matches(path: &amp;Path) -&gt; f64 {
    let file_name = path.file_name()
        .and_then(|f| f.to_str())
        .unwrap_or_else(|| {
            debug!(&quot;Unable to determine filename for {:?}&quot;, path);
            &quot;&quot;
        });

    find_matches(file_name)
}

fn find_filename_matches_in_path(path: &amp;str) -&gt; Vec&lt;(PathBuf, f64)&gt; {
    fs::read_dir(path).unwrap()
        .map(|p| p.unwrap().path())
        .map(|p| {
            let matches = count_filename_matches(p.as_ref(), cmd);
            (p, matches)
        })
        .filter(|&amp;(ref _p, matches)| {
            matches &gt; 0.0
        })
        .collect()
}
</code></pre>
<a class="header" href="print.html#fearless-concurrency-with-rust" id="fearless-concurrency-with-rust"><h1>Fearless Concurrency with Rust</h1></a>
<p>The Rust project was initiated to solve two thorny problems:</p>
<ul>
<li>How do you do safe systems programming?</li>
<li>How do you make concurrency painless?</li>
</ul>
<p>Initially these problems seemed orthogonal, but to our amazement, the
solution turned out to be identical: <strong>the same tools that make Rust
safe also help you tackle concurrency head-on</strong>.</p>
<p>Memory safety bugs and concurrency bugs often come down to code
accessing data when it shouldn't. Rust's secret weapon is <em>ownership</em>,
a discipline for access control that systems programmers try to
follow, but that Rust's compiler checks statically for you.</p>
<p>For memory safety, this means you can program without a garbage
collector <em>and</em> without fear of segfaults, because Rust will catch
your mistakes.</p>
<p>For concurrency, this means you can choose from a wide variety of
paradigms (message passing, shared state, lock-free, purely
functional), and Rust will help you avoid common pitfalls.</p>
<p>Here's a taste of concurrency in Rust:</p>
<ul>
<li>
<p>A <a href="http://static.rust-lang.org/doc/master/std/sync/mpsc/index.html">channel</a> transfers ownership of the messages sent along it,
so you can send a pointer from one thread to another without fear of
the threads later racing for access through that pointer. <strong>Rust's
channels enforce thread isolation.</strong></p>
</li>
<li>
<p>A <a href="http://static.rust-lang.org/doc/master/std/sync/struct.Mutex.html">lock</a> knows what data it protects, and Rust guarantees
that the data can only be accessed when the lock is held. State is
never accidentally shared. <strong>&quot;Lock data, not code&quot; is enforced in
Rust.</strong></p>
</li>
<li>
<p>Every data type knows whether it can safely be <a href="http://static.rust-lang.org/doc/master/std/marker/trait.Send.html">sent</a> between
or <a href="http://static.rust-lang.org/doc/master/std/marker/trait.Sync.html">accessed</a> by multiple threads, and Rust enforces this safe
usage; there are no data races, even for lock-free data structures.
<strong>Thread safety isn't just documentation; it's law.</strong></p>
</li>
<li>
<p>You can even <a href="http://static.rust-lang.org/doc/master/std/thread/fn.scoped.html">share stack frames</a> between threads, and Rust
will statically ensure that the frames remain active while other
threads are using them. <strong>Even the most daring forms of sharing are
guaranteed safe in Rust</strong>.</p>
</li>
</ul>
<p>All of these benefits come out of Rust's ownership model, and in fact
locks, channels, lock-free data structures and so on are defined in
libraries, not the core language. That means that Rust's approach to
concurrency is <em>open ended</em>: new libraries can embrace new paradigms
and catch new bugs, just by adding APIs that use Rust's ownership
features.</p>
<p>The goal of this post is to give you some idea of how that's done.</p>
<a class="header" href="print.html#background-ownership" id="background-ownership"><h3>Background: ownership</h3></a>
<blockquote>
<p>We'll start with an overview of Rust's ownership and borrowing
systems. If you're already familiar with these, you can skip the two
&quot;background&quot; sections and jump straight into concurrency. If you want
a deeper introduction, I can't recommend
<a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">Yehuda Katz's post</a>
highly enough. And
<a href="http://doc.rust-lang.org/book/ownership.html">the Rust book</a> has all
the details.</p>
</blockquote>
<p>In Rust, every value has an &quot;owning scope,&quot; and passing or returning a
value means transferring ownership (&quot;moving&quot; it) to a new
scope. Values that are still owned when a scope ends are automatically
destroyed at that point.</p>
<p>Let's look at some simple examples. Suppose we create a vector and
push some elements onto it:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn make_vec() {
    let mut vec = Vec::new(); // owned by make_vec's scope
    vec.push(0);
    vec.push(1);
    // scope ends, `vec` is destroyed
}

#}</code></pre></pre>
<p>The scope that creates a value also initially owns it. In this case,
the body of <code>make_vec</code> is the owning scope for <code>vec</code>. The owner can do
anything it likes with <code>vec</code>, including mutating it by pushing. At the
end of the scope, <code>vec</code> is still owned, so it is automatically
deallocated.</p>
<p>Things get more interesting if the vector is returned or passed around:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn make_vec() -&gt; Vec&lt;i32&gt; {
    let mut vec = Vec::new();
    vec.push(0);
    vec.push(1);
    vec // transfer ownership to the caller
}

fn print_vec(vec: Vec&lt;i32&gt;) {
    // the `vec` parameter is part of this scope, so it's owned by `print_vec`

    for i in vec.iter() {
        println!(&quot;{}&quot;, i)
    }

    // now, `vec` is deallocated
}

fn use_vec() {
    let vec = make_vec(); // take ownership of the vector
    print_vec(vec);       // pass ownership to `print_vec`
}

#}</code></pre></pre>
<p>Now, just before <code>make_vec</code>'s scope ends, <code>vec</code> is moved out by
returning it; it is not destroyed. A caller like <code>use_vec</code> then
receives ownership of the vector.</p>
<p>On the other hand, the <code>print_vec</code> function takes a <code>vec</code> parameter,
and ownership of the vector is transferred <em>to</em> it by its
caller. Since <code>print_vec</code> does not transfer the ownership any further,
at the end of its scope the vector is destroyed.</p>
<p>Once ownership has been given away, a value can no longer be used. For
example, consider this variant of <code>use_vec</code>:</p>
<pre><code class="language-rust ignore">fn use_vec() {
    let vec = make_vec();  // take ownership of the vector
    print_vec(vec);        // pass ownership to `print_vec`

    for i in vec.iter() {  // continue using `vec`
        println!(&quot;{}&quot;, i * 2)
    }
}
</code></pre>
<p>If you feed this version to the compiler, you'll get an  error:</p>
<pre><code class="language-text">error: use of moved value: `vec`

for i in vec.iter() {
         ^~~
</code></pre>
<p>The compiler is saying <code>vec</code> is no longer available; ownership has
been transferred elsewhere. And that's very good, because the vector
has already been deallocated at this point!</p>
<p>Disaster averted.</p>
<a class="header" href="print.html#background-borrowing" id="background-borrowing"><h3>Background: borrowing</h3></a>
<p>The story so far isn't totally satisfying, because it's not our intent
for <code>print_vec</code> to destroy the vector it was given. What we really
want is to grant <code>print_vec</code> <em>temporary</em> access to the vector, and
then continue using the vector afterwards.</p>
<p>This is where <em>borrowing</em> comes in. If you have access to a value in
Rust, you can lend out that access to the functions you call. <strong>Rust
will check that these leases do not outlive the object being
borrowed</strong>.</p>
<p>To borrow a value, you make a <em>reference</em> to it (a kind of pointer),
using the <code>&amp;</code> operator:</p>
<pre><code class="language-rust ignore">fn print_vec(vec: &amp;Vec&lt;i32&gt;) {
    // the `vec` parameter is borrowed for this scope

    for i in vec.iter() {
        println!(&quot;{}&quot;, i)
    }

    // now, the borrow ends
}

fn use_vec() {
    let vec = make_vec();  // take ownership of the vector
    print_vec(&amp;vec);       // lend access to `print_vec`
    for i in vec.iter() {  // continue using `vec`
        println!(&quot;{}&quot;, i * 2)
    }
    // vec is destroyed here
}
</code></pre>
<p>Now <code>print_vec</code> takes a reference to a vector, and <code>use_vec</code> lends out
the vector by writing <code>&amp;vec</code>. Since borrows are temporary, <code>use_vec</code>
retains ownership of the vector; it can continue using it after the
call to <code>print_vec</code> returns (and its lease on <code>vec</code> has expired).</p>
<p>Each reference is valid for a limited scope, which the compiler will
automatically determine. References come in two flavors:</p>
<ul>
<li>
<p>Immutable references <code>&amp;T</code>, which allow sharing but not mutation.
There can be multiple <code>&amp;T</code> references to the same value
simultaneously, but the value cannot be mutated while those
references are active.</p>
</li>
<li>
<p>Mutable references <code>&amp;mut T</code>, which allow mutation but not sharing.
If there is an <code>&amp;mut T</code> reference to a value, there can be no other
active references at that time, but the value can be mutated.</p>
</li>
</ul>
<p>Rust checks these rules at compile time; borrowing has no runtime
overhead.</p>
<p>Why have two kinds of references? Consider a function like:</p>
<pre><code class="language-rust ignore">fn push_all(from: &amp;Vec&lt;i32&gt;, to: &amp;mut Vec&lt;i32&gt;) {
    for i in from.iter() {
        to.push(*i);
    }
}
</code></pre>
<p>This function iterates over each element of one vector, pushing it
onto another. The iterator keeps a pointer into the vector at the
current and final positions, stepping one toward the other.</p>
<p>What if we called this function with the same vector for both arguments?</p>
<pre><code class="language-rust ignore">push_all(&amp;vec, &amp;mut vec)
</code></pre>
<p>This would spell disaster! As we're pushing elements onto the vector,
it will occasionally need to resize, allocating a new hunk of memory
and copying its elements over to it. The iterator would be left with a
dangling pointer into the old memory, leading to memory unsafety (with
attendant segfaults or worse).</p>
<p>Fortunately, Rust ensures that <strong>whenever a mutable borrow is active,
no other borrows of the object are active</strong>, producing the message:</p>
<pre><code class="language-text">error: cannot borrow `vec` as mutable because it is also borrowed as immutable
push_all(&amp;vec, &amp;mut vec);
                    ^~~
</code></pre>
<p>Disaster averted.</p>
<a class="header" href="print.html#message-passing" id="message-passing"><h3>Message passing</h3></a>
<p>Now that we've covered the basic ownership story in Rust, let's see
what it means for concurrency.</p>
<p>Concurrent programming comes in many styles, but a particularly simple
one is message passing, where threads or actors communicate by sending
each other messages.  Proponents of the style emphasize the way that
it ties together sharing and communication:</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by
communicating.</p>
<p>--<a href="http://golang.org/doc/effective_go.html">Effective Go</a></p>
</blockquote>
<p><strong>Rust's ownership makes it easy to turn that advice into a
compiler-checked rule</strong>. Consider the following channel API
(<a href="http://static.rust-lang.org/doc/master/std/sync/mpsc/index.html">channels in Rust's standard library</a> are a bit different):</p>
<pre><code class="language-rust ignore">fn send&lt;T: Send&gt;(chan: &amp;Channel&lt;T&gt;, t: T);
fn recv&lt;T: Send&gt;(chan: &amp;Channel&lt;T&gt;) -&gt; T;
</code></pre>
<p>Channels are generic over the type of data they transmit (the <code>&lt;T: Send&gt;</code> part of the API). The <code>Send</code> part means that <code>T</code> must be
considered safe to send between threads; we'll come back to that later
in the post, but for now it's enough to know that <code>Vec&lt;i32&gt;</code> is
<code>Send</code>.</p>
<p>As always in Rust, passing in a <code>T</code> to the <code>send</code> function means
transferring ownership of it. This fact has profound consequences: it
means that code like the following will generate a compiler error.</p>
<pre><code class="language-rust ignore">// Suppose chan: Channel&lt;Vec&lt;i32&gt;&gt;

let mut vec = Vec::new();
// do some computation
send(&amp;chan, vec);
print_vec(&amp;vec);
</code></pre>
<p>Here, the thread creates a vector, sends it to another thread, and
then continues using it. The thread receiving the vector could mutate
it as this thread continues running, so the call to <code>print_vec</code> could
lead to race condition or, for that matter, a use-after-free bug.</p>
<p>Instead, the Rust compiler will produce an error message on the call
to <code>print_vec</code>:</p>
<pre><code class="language-text">Error: use of moved value `vec`
</code></pre>
<p>Disaster averted.</p>
<a class="header" href="print.html#locks" id="locks"><h3>Locks</h3></a>
<p>Another way to deal with concurrency is by having threads communicate
through passive, shared state.</p>
<p>Shared-state concurrency has a bad rap. It's easy to forget to acquire
a lock, or otherwise mutate the wrong data at the wrong time, with
disastrous results -- so easy that many eschew the style altogether.</p>
<p>Rust's take is that:</p>
<ol>
<li>
<p>Shared-state concurrency is nevertheless a fundamental programming
style, needed for systems code, for maximal performance, and for
implementing other styles of concurrency.</p>
</li>
<li>
<p>The problem is really about <em>accidentally</em> shared state.</p>
</li>
</ol>
<p>Rust aims to give you the tools to conquer shared-state concurrency
directly, whether you're using locking or lock-free techniques.</p>
<p>In Rust, threads are &quot;isolated&quot; from each other automatically, due to
ownership. Writes can only happen when the thread has mutable access,
either by owning the data, or by having a mutable borrow of it. Either
way, <strong>the thread is guaranteed to be the only one with access at the
time</strong>.  To see how this plays out, let's look at locks.</p>
<p>Remember that mutable borrows cannot occur simultaneously with other
borrows. Locks provide the same guarantee (&quot;mutual exclusion&quot;) through
synchronization at runtime. That leads to a locking API that hooks
directly into Rust's ownership system.</p>
<p>Here is a simplified version (the <a href="http://static.rust-lang.org/doc/master/std/sync/struct.Mutex.html">standard library's</a>
is more ergonomic):</p>
<pre><code class="language-rust ignore">// create a new mutex
fn mutex&lt;T: Send&gt;(t: T) -&gt; Mutex&lt;T&gt;;

// acquire the lock
fn lock&lt;T: Send&gt;(mutex: &amp;Mutex&lt;T&gt;) -&gt; MutexGuard&lt;T&gt;;

// access the data protected by the lock
fn access&lt;T: Send&gt;(guard: &amp;mut MutexGuard&lt;T&gt;) -&gt; &amp;mut T;
</code></pre>
<p>This lock API is unusual in several respects.</p>
<p>First, the <code>Mutex</code> type is generic over a type <code>T</code> of <strong>the data
protected by the lock</strong>. When you create a <code>Mutex</code>, you transfer
ownership of that data <em>into</em> the mutex, immediately giving up access
to it. (Locks are unlocked when they are first created.)</p>
<p>Later, you can <code>lock</code> to block the thread until the lock is
acquired. This function, too, is unusual in providing a return value,
<code>MutexGuard&lt;T&gt;</code>. The <code>MutexGuard</code> automatically releases the lock when
it is destroyed; there is no separate <code>unlock</code> function.</p>
<p>The only way to access the lock is through the <code>access</code> function,
which turns a mutable borrow of the guard into a mutable borrow of the
data (with a shorter lease):</p>
<pre><code class="language-rust ignore">fn use_lock(mutex: &amp;Mutex&lt;Vec&lt;i32&gt;&gt;) {
    // acquire the lock, taking ownership of a guard;
    // the lock is held for the rest of the scope
    let mut guard = lock(mutex);

    // access the data by mutably borrowing the guard
    let vec = access(&amp;mut guard);

    // vec has type `&amp;mut Vec&lt;i32&gt;`
    vec.push(3);

    // lock automatically released here, when `guard` is destroyed
}
</code></pre>
<p>There are two key ingredients here:</p>
<ul>
<li>
<p>The mutable reference returned by <code>access</code> cannot outlive the
<code>MutexGuard</code> it is borrowing from.</p>
</li>
<li>
<p>The lock is only released when the <code>MutexGuard</code> is destroyed.</p>
</li>
</ul>
<p>The result is that <strong>Rust enforces locking discipline: it will not let
you access lock-protected data except when holding the lock</strong>. Any
attempt to do otherwise will generate a compiler error. For example,
consider the following buggy &quot;refactoring&quot;:</p>
<pre><code class="language-rust ignore">fn use_lock(mutex: &amp;Mutex&lt;Vec&lt;i32&gt;&gt;) {
    let vec = {
        // acquire the lock
        let mut guard = lock(mutex);

        // attempt to return a borrow of the data
        access(&amp;mut guard)

        // guard is destroyed here, releasing the lock
    };

    // attempt to access the data outside of the lock.
    vec.push(3);
}
</code></pre>
<p>Rust will generate an error pinpointing the problem:</p>
<pre><code class="language-text">error: `guard` does not live long enough
access(&amp;mut guard)
            ^~~~~
</code></pre>
<p>Disaster averted.</p>
<a class="header" href="print.html#thread-safety-and-send" id="thread-safety-and-send"><h3>Thread safety and &quot;Send&quot;</h3></a>
<p>It's typical to distinguish some data types as &quot;thread safe&quot; and
others not. Thread safe data structures use enough internal
synchronization to be safely used by multiple threads concurrently.</p>
<p>For example, Rust ships with two kinds of &quot;smart pointers&quot; for
reference counting:</p>
<ul>
<li>
<p><code>Rc&lt;T&gt;</code> provides reference counting via normal reads/writes. It is
not thread safe.</p>
</li>
<li>
<p><code>Arc&lt;T&gt;</code> provides reference counting via <em>atomic</em> operations. It is
thread safe.</p>
</li>
</ul>
<p>The hardware atomic operations used by <code>Arc</code> are more expensive than
the vanilla operations used by <code>Rc</code>, so it's advantageous to use <code>Rc</code>
rather than <code>Arc</code>. On the other hand, it's critical that an <code>Rc&lt;T&gt;</code>
never migrate from one thread to another, because that could lead to
race conditions that corrupt the count.</p>
<p>Usually, the only recourse is careful documentation; most languages
make no <em>semantic</em> distinction between thread-safe and thread-unsafe
types.</p>
<p>In Rust, the world is divided into two kinds of data types: those that
are <a href="http://static.rust-lang.org/doc/master/std/marker/trait.Send.html"><code>Send</code></a>, meaning they can be safely moved from one thread to
another, and those that are <code>!Send</code>, meaning that it may not be safe
to do so. If all of a type's components are <code>Send</code>, so is that type --
which covers most types. Certain base types are not inherently
thread-safe, though, so it's also possible to explicitly mark a type
like <code>Arc</code> as <code>Send</code>, saying to the compiler: &quot;Trust me; I've verified
the necessary synchronization here.&quot;</p>
<p>Naturally, <code>Arc</code> is <code>Send</code>, and <code>Rc</code> is not.</p>
<p>We already saw that the <code>Channel</code> and <code>Mutex</code> APIs work only with
<code>Send</code> data. Since they are the point at which data crosses thread
boundaries, they are also the point of enforcement for <code>Send</code>.</p>
<p>Putting this all together, Rust programmers can reap the benefits of
<code>Rc</code> and other thread-<em>unsafe</em> types with confidence, knowing that if
they ever do accidentally try to send one to another thread, the Rust
compiler will say:</p>
<pre><code class="language-text">`Rc&lt;Vec&lt;i32&gt;&gt;` cannot be sent between threads safely
</code></pre>
<p>Disaster averted.</p>
<a class="header" href="print.html#sharing-the-stack-scoped" id="sharing-the-stack-scoped"><h3>Sharing the stack: &quot;scoped&quot;</h3></a>
<p><em>Note: The API mentioned here is an old one which has been moved out of
the standard library. You can find equivalent functionality in
<a href="https://crates.io/crates/crossbeam"><code>crossbeam</code></a> (<a href="http://aturon.github.io/crossbeam-doc/crossbeam/fn.scope.html">documentation for <code>scope()</code></a>)
and <a href="https://crates.io/crates/scoped_threadpool"><code>scoped_threadpool</code></a>
(<a href="http://kimundi.github.io/scoped-threadpool-rs/scoped_threadpool/index.html#examples:">documentation for <code>scoped()</code></a>)</em></p>
<p>So far, all the patterns we've seen involve creating data structures
on the heap that get shared between threads. But what if we wanted to
start some threads that make use of data living in our stack frame?
That could be dangerous:</p>
<pre><code class="language-rust ignore">fn parent() {
    let mut vec = Vec::new();
    // fill the vector
    thread::spawn(|| {
        print_vec(&amp;vec)
    })
}
</code></pre>
<p>The child thread takes a reference to <code>vec</code>, which in turn resides in
the stack frame of <code>parent</code>. When <code>parent</code> exits, the stack frame is
popped, but the child thread is none the wiser. Oops!</p>
<p>To rule out such memory unsafety, Rust's basic thread spawning API
looks a bit like this:</p>
<pre><code class="language-rust ignore">fn spawn&lt;F&gt;(f: F) where F: 'static, ...
</code></pre>
<p>The <code>'static</code> constraint is a way of saying, roughly, that no borrowed
data is permitted in the closure.  It means that a function like
<code>parent</code> above will generate an error:</p>
<pre><code class="language-text">error: `vec` does not live long enough
</code></pre>
<p>essentially catching the possibility of <code>parent</code>'s stack frame
popping. Disaster averted.</p>
<p>But there is another way to guarantee safety: ensure that the parent
stack frame stays put until the child thread is done. This is the
pattern of <em>fork-join</em> programming, often used for divide-and-conquer
parallel algorithms. Rust supports it by providing a
<a href="http://static.rust-lang.org/doc/master/std/thread/fn.scoped.html">&quot;scoped&quot;</a> variant of thread spawning:</p>
<pre><code class="language-rust ignore">fn scoped&lt;'a, F&gt;(f: F) -&gt; JoinGuard&lt;'a&gt; where F: 'a, ...
</code></pre>
<p>There are two key differences from the <code>spawn</code> API above:</p>
<ul>
<li>
<p>The use a parameter <code>'a</code>, rather than <code>'static</code>. This parameter
represents a scope that encompasses all the borrows within the
closure, <code>f</code>.</p>
</li>
<li>
<p>The return value, a <code>JoinGuard</code>. As its name suggests, <code>JoinGuard</code>
ensures that the parent thread joins (waits on) its child, by
performing an implicit join in its destructor (if one hasn't happened
explicitly already).</p>
</li>
</ul>
<p>Including <code>'a</code> in <code>JoinGuard</code> ensures that the <code>JoinGuard</code> <strong>cannot
escape the scope of any data borrowed by the closure</strong>.  In other
words, Rust guarantees that the parent thread waits for the child to
finish before popping any stack frames the child might have access to.</p>
<p>Thus by adjusting our previous example, we can fix the bug and satisfy
the compiler:</p>
<pre><code class="language-rust ignore">fn parent() {
    let mut vec = Vec::new();
    // fill the vector
    let guard = thread::scoped(|| {
        print_vec(&amp;vec)
    });
    // guard destroyed here, implicitly joining
}
</code></pre>
<p>So in Rust, you can freely borrow stack data into child threads,
confident that the compiler will check for sufficient synchronization.</p>
<a class="header" href="print.html#data-races" id="data-races"><h3>Data races</h3></a>
<p>At this point, we've seen enough to venture a strong statement about
Rust's approach to concurrency: <strong>the compiler prevents all <em>data races</em>.</strong></p>
<blockquote>
<p>A data race is any unsynchronized, concurrent access to data
involving a write.</p>
</blockquote>
<p>Synchronization here includes things as low-level as atomic
instructions. Essentially, this is a way of saying that you cannot
accidentally &quot;share state&quot; between threads; all (mutating) access to
state has to be mediated by <em>some</em> form of synchronization.</p>
<p>Data races are just one (very important) kind of race condition, but
by preventing them, Rust often helps you prevent other, more subtle
races as well. For example, it's often important that updates to
different locations appear to take place <em>atomically</em>: other threads
see either all of the updates, or none of them. In Rust, having <code>&amp;mut</code>
access to the relevant locations at the same time <strong>guarantees
atomicity of updates to them</strong>, since no other thread could possibly
have concurrent read access.</p>
<p>It's worth pausing for a moment to think about this guarantee in the
broader landscape of languages. Many languages provide memory safety
through garbage collection. But garbage collection doesn't give you
any help in preventing data races.</p>
<p>Rust instead uses ownership and borrowing to provide its two key value
propositions:</p>
<ul>
<li>Memory safety without garbage collection.</li>
<li>Concurrency without data races.</li>
</ul>
<a class="header" href="print.html#the-future" id="the-future"><h3>The future</h3></a>
<p>When Rust first began, it baked channels directly into the language,
taking a very opinionated stance on concurrency.</p>
<p>In today's Rust, concurrency is <em>entirely</em> a library affair;
everything described in this post, including <code>Send</code>, is defined in the
standard library, and could be defined in an external library instead.</p>
<p>And that's very exciting, because it means that Rust's concurrency
story can endlessly evolve, growing to encompass new paradigms and
catch new classes of bugs. Libraries like <a href="https://github.com/carllerche/syncbox">syncbox</a> and
<a href="https://github.com/huonw/simple_parallel">simple_parallel</a> are taking some of the first steps,
and we expect to invest heavily in this space in the next few
months. Stay tuned!</p>
<blockquote>
<p><a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html"><em>Originally published 2015-04-10</em></a></p>
<p><em>License: TBD</em></p>
</blockquote>
<a class="header" href="print.html#how-rust-achieves-thread-safety" id="how-rust-achieves-thread-safety"><h1>How Rust Achieves Thread Safety</h1></a>
<p><em>In every talk I have given till now, the question &quot;how does Rust achieve thread safety?&quot;
has invariably come up<sup class="footnote-reference"><a href="print.html#1">1</a></sup>. I usually just give an overview, but this provides a more comprehensive
explanation for those who are interested</em></p>
<p>See also: <a href="http://huonw.github.io/blog/2015/02/some-notes-on-send-and-sync/">Huon's blog post on the same topic</a></p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>So much that I added bonus slides about thread safety to the end of my deck, and of course I ended up using them at the talk I gave recently</p>
<p>In my <a href="http://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">previous post</a> I touched a bit on the <a href="http://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> trait. There are other such
&quot;marker&quot; traits in the standard library, and the ones relevant to this discussion are <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>
and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>. I recommend reading that post if you're not familiar with Rust wrapper types
like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> and <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a>, since I'll be using them as examples throughout this post;
but the concepts explained here are largely independent.</p>
<p>For the purposes of this post, I'll restrict thread safety to mean no data races or cross-thread
dangling pointers. Rust doesn't aim to solve race conditions. However, there are projects which
utilize the type system to provide some form of extra safety, for example <a href="https://github.com/Munksgaard/rust-sessions">rust-
sessions</a> attempts to provide protocol safety using
session types.</p>
<p>These traits are auto-implemented using a feature called &quot;opt in builtin traits&quot;. So, for example,
if struct <code>Foo</code> contains only <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> fields, it will also be <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, unless we
explicitly opt out using <code>impl !Sync for Foo {}</code>. Similarly, if struct <code>Foo</code> contains at least one
non-<a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> type, it will not be <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> either, unless it explicitly opts in (<code>unsafe impl Sync for Foo {}</code>)</p>
<p>This means that, for example, a <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender</code></a> for a <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> type is itself
<a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>, but a <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender</code></a> for a non-<code>Send</code> type will not be <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>. This
pattern is quite powerful; it lets one use channels with non-threadsafe data in a single-threaded
context without requiring a separate &quot;single threaded&quot; channel abstraction.</p>
<p>At the same time, structs like <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> and <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> which contain
<a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>/<a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> fields have explicitly opted out of one or more of these because the
invariants they rely on do not hold in threaded situations.</p>
<p>It's actually possible to design your own library with comparable thread safety guarantees outside
of the compiler — while these marker traits are specially treated by the compiler, the special
treatment is not necessary for their working. Any two opt-in builtin traits could be used here.</p>
<p><a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> have slightly differing meanings, but are very intertwined.</p>
<p><a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> types can be moved between threads without an issue. It answers the question
&quot;if this variable were moved to another thread, would it still be valid for use?&quot;.
Most objects which completely own their contained data qualify here. Notably, <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> doesn't
(since it is shared ownership). Another exception is <a href="https://doc.rust-lang.org/nightly/std/thread/struct.LocalKey.html"><code>LocalKey</code></a>, which
<em>does</em> own its data but isn't valid from other threads. Borrowed data does qualify to be <code>Send</code>, but
in most cases it can't be sent across threads due to a constraint that will be touched upon later.</p>
<p>Even though types like <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> use non-atomic reference counting, it can be sent safely
between threads because this is a transfer of <em>ownership</em> (a move). Sending a <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> to another thread
will be a move and will make it unusable from the original thread; so this is fine.</p>
</div>
<p><a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>, on the other hand, is about synchronous access. It answers the question: &quot;if
multiple threads were all trying to access this data, would it be safe?&quot;. Types like
<a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> and other lock/atomic based types implement this, along with primitive types.
Things containing pointers generally are not <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>.</p>
<p><code>Sync</code> is sort of a crutch to <code>Send</code>; it helps make other types <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> when sharing is
involved. For example, <code>&amp;T</code> and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> are only <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> when the inner data is <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> (there's an additional
<a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> bound in the case of <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>). In words, stuff that has shared/borrowed ownership can be sent
to another thread if the shared/borrowed data is synchronous-safe.</p>
<p><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a>, while <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>, is not <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> because of the non atomic reference counting.</p>
<p>Bringing it together, the gatekeeper for all this is <a href="http://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn()</code></a>. It has the signature</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; where F: FnOnce() -&gt; T, F: Send + 'static, T: Send + 'static
</code></pre>
<p>Admittedly, this is confusing/noisy, partially because it's allowed to return a value, and also because
it returns a handle from which we can block on a thread join. We can conjure a simpler <code>spawn</code> API for our needs though:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F&gt;(f: F) where F: FnOnce(), F: Send + 'static
</code></pre>
<p>which can be called like:</p>
<pre><code class="language-rust ignore">let mut x = vec![1,2,3,4];

// `move` instructs the closure to move out of its environment
thread::spawn(move || {
   x.push(1);

});

// x is not accessible here since it was moved

</code></pre>
<p>In words, <code>spawn()</code> will take a callable (usually a closure) that will be called once, and contains
data which is <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <code>'static</code>. Here, <code>'static</code> just means that there is no borrowed
data contained in the closure. This is the aforementioned constraint that prevents the sharing of
borrowed data across threads; without it we would be able to send a borrowed pointer to a thread that
could easily outlive the borrow, causing safety issues.</p>
<p>There's a slight nuance here about the closures — closures can capture outer variables,
but by default they do so by-reference (hence the <code>move</code> keyword). They autoimplement <code>Send</code>
and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> depending on their capture clauses. For more on their internal representation,
see <a href="http://huonw.github.io/blog/2015/05/finding-closure-in-rust/">huon's post</a>. In this case, <code>x</code> was captured by-move; i.e. as <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>
(instead of being similar to <code>&amp;Vec&lt;T&gt;</code> or something), so the closure itself can be <code>Send</code>.
Without the <code>move</code> keyword, the closure would not be `'static' since it contains borrowed
content.</p>
<p>Since the closure inherits the <code>Send</code>/<code>Sync</code>/<code>'static</code>-ness of its captured data, a closure
capturing data of the correct type will satisfy the <code>F: Send+'static</code> bound.</p>
<p>Some examples of things that are allowed and not allowed by this function (for the type of <code>x</code>):</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>, <a href="http://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> are allowed because they are <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <code>'static</code> (when the inner type is of the same kind)</li>
<li><code>&amp;T</code> isn't allowed because it's not <code>'static</code>. This is good, because borrows should have a statically-known lifetime. Sending a borrowed pointer to a thread may lead to a use after free, or otherwise break aliasing rules.</li>
<li><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> isn't <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>, so it isn't allowed. We could have some other <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a>s hanging around, and end up with a data race on the refcount.</li>
<li><code>Arc&lt;Vec&lt;u32&gt;&gt;</code> is allowed (<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> is <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> if the inner type is); we can't cause a safety violation here. Iterator invalidation requires mutation, and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> doesn't provide this by default.</li>
<li><code>Arc&lt;Cell&lt;T&gt;&gt;</code> isn't allowed. <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> provides copying-based internal mutability, and isn't <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> (so the <code>Arc&lt;Cell&lt;T&gt;&gt;</code> isn't <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>). If this were allowed, we could have cases where larger structs are getting written to from different threads simultaneously resulting in some random mishmash of the two. In other words, a data race.</li>
<li><code>Arc&lt;Mutex&lt;T&gt;&gt;</code> or <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> are allowed (for <code>Send</code> <code>T</code>). The inner types use threadsafe locks and provide lock-based internal mutability. They can guarantee that only one thread is writing to them at any point in time. For this reason, the mutexes are <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> regardless of the inner <code>T</code> (as long as it is <code>Send</code>), and <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> types can be shared safely with wrappers like <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>. From the point of view of the inner type, it's only being accessed by one thread at a time (slightly more complex in the case of <a href="http://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>), so it doesn't need to know about the threads involved. There can't be data races when <code>Sync</code> types like these are involved.</li>
</ul>
<p>As mentioned before, you can in fact create a <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender</code></a>/<a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html"><code>Receiver</code></a> pair of non-<code>Send</code> objects. This sounds a bit
counterintuitive — shouldn't we be only sending values which are <code>Send</code>? However, <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender&lt;T&gt;</code></a> is only
<code>Send</code> if <code>T</code> is <code>Send</code>; so even if we can use a <a href="http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender</code></a> of a non-<code>Send</code> type, we cannot send it to another thread,
so it cannot be used to violate thread safety.</p>
<p>There is also a way to utilize the <code>Send</code>-ness of <code>&amp;T</code> (which is not <code>'static</code>) for some <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> <code>T</code>, namely <a href="http://doc.rust-lang.org/std/thread/fn.scoped.html"><code>thread::scoped</code></a>.
This function does not have the <code>'static</code> bound, but it instead has an RAII guard which forces a join before the borrow ends. This
allows for easy fork-join parallelism without necessarily needing a <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>.
Sadly, there <a href="http://cglab.ca/%7Eabeinges/blah/everyone-peaches/">are</a> <a href="http://smallcultfollowing.com/babysteps/blog/2015/04/29/on-reference-counting-and-leaks/">problems</a> which crop up when this interacts with <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> cycles, so the API
is currently unstable and will be redesigned. This is not a problem with the language design or the design of <code>Send</code>/<code>Sync</code>,
rather it is a perfect storm of small design inconsistencies in the libraries.</p>
<p><small>Discuss: <a href="https://news.ycombinator.com/item?id=9628131">HN</a>, <a href="https://www.reddit.com/r/rust/comments/37s5x2/how_rust_achieves_thread_safety/">Reddit</a></small></p>
<blockquote>
<p><a href="https://manishearth.github.io/blog/2015/05/30/how-rust-achieves-thread-safety/"><em>Originally published 2015-05-30</em></a></p>
<p><em>License: TBD</em></p>
</blockquote>
<a class="header" href="print.html#abstraction-without-overhead" id="abstraction-without-overhead"><h1>Abstraction without overhead</h1></a>
<p><a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Previous posts</a> have covered two pillars of Rust's design:</p>
<ul>
<li>Memory safety without garbage collection</li>
<li>Concurrency without data races</li>
</ul>
<p>This post begins exploring the third pillar:</p>
<ul>
<li><strong>Abstraction without overhead</strong></li>
</ul>
<p>One of the mantras of C++, one of the qualities that make it a good fit for
systems programming, is its principle of zero-cost abstraction:</p>
<blockquote>
<p>C++ implementations obey the zero-overhead principle: What you don't use, you
don't pay for [Stroustrup, 1994]. And further: What you do use, you couldn't
hand code any better.</p>
<p>-- Stroustrup</p>
</blockquote>
<p>This mantra did not always apply to Rust, which for example used to have
mandatory garbage collection. But over time Rust's ambitions have gotten
ever lower-level, and zero-cost abstraction is now a core principle.</p>
<p>The cornerstone of abstraction in Rust is <em>traits</em>:</p>
<ul>
<li>
<p><strong>Traits are Rust's sole notion of interface</strong>. A trait can be implemented by
multiple types, and in fact new traits can provide implementations for
existing types. On the flip side, when you want to abstract over an unknown
type, traits are how you specify the few concrete things you need to know
about that type.</p>
</li>
<li>
<p><strong>Traits can be statically dispatched</strong>. Like C++ templates, you can have
the compiler generate a separate copy of an abstraction for each way it is
instantiated. This comes back to the C++ mantra of &quot;What you do use, you
couldn't hand code any better&quot; -- the abstraction ends up completely erased.</p>
</li>
<li>
<p><strong>Traits can be dynamically dispatched</strong>. Sometimes you really do need an
indirection, and so it doesn't make sense to &quot;erase&quot; an abstraction at
runtime. The <em>same</em> notion of interface -- the trait -- can also be used when
you want to dispatch at runtime.</p>
</li>
<li>
<p><strong>Traits solve a variety of additional problems beyond simple abstraction</strong>.
They are used as &quot;markers&quot; for types, like the <code>Send</code> marker described
<a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">in a previous post</a>. They can be used to define &quot;extension methods&quot;
-- that is, to add methods to an externally-defined type. They largely obviate
the need for traditional method overloading. And they provide a simple scheme
for operator overloading.</p>
</li>
</ul>
<p>All told, the trait system is the secret sauce that gives Rust the ergonomic,
expressive feel of high-level languages while retaining low-level control over
code execution and data representation.</p>
<p>This post will walk through each of the above points at a high level, to give
you a sense for how the design achieves these goals, without getting too bogged
down in the details.</p>
<a class="header" href="print.html#background-methods-in-rust" id="background-methods-in-rust"><h3>Background: methods in Rust</h3></a>
<blockquote>
<p>Before delving into traits, we need to look at a small but important detail of
the language: the difference between methods and functions.</p>
</blockquote>
<p>Rust offers both methods and free-standing functions, which are very
closely related:</p>
<pre><code class="language-rust ignore">struct Point {
    x: f64,
    y: f64,
}

// a free-standing function that converts a (borrowed) point to a string
fn point_to_string(point: &amp;Point) -&gt; String { ... }

// an &quot;inherent impl&quot; block defines the methods available directly on a type
impl Point {
    // this method is available on any Point, and automatically borrows the
    // Point value
    fn to_string(&amp;self) -&gt; String { ... }
}
</code></pre>
<p>Methods like <code>to_string</code> above are called &quot;inherent&quot; methods, because they:</p>
<ul>
<li>Are tied to a single concrete &quot;self&quot; type (specified via the <code>impl</code> block header).</li>
<li>Are <em>automatically</em> available on any value of that type -- that is, unlike
functions, inherent methods are always &quot;in scope&quot;.</li>
</ul>
<p>The first parameter for a method is always an explicit &quot;self&quot;, which is either
<code>self</code>, <code>&amp;mut self</code>, or <code>&amp;self</code> depending on the
<a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">level of ownership required</a>.  Methods are invoked using the <code>.</code>
notation familiar from object-oriented programming, and the self parameter is
<em>implicitly borrowed</em> as per the form of <code>self</code> used in the method:</p>
<pre><code class="language-rust ignore">let p = Point { x: 1.2, y: -3.7 };
let s1 = point_to_string(&amp;p);  // calling a free function, explicit borrow
let s2 = p.to_string();        // calling a method, implicit borrow as &amp;p
</code></pre>
<p>Methods and their auto-borrowing are an important aspect of the ergonomics of
Rust, supporting &quot;fluent&quot; APIs like the one for spawning processes:</p>
<pre><code class="language-rust ignore">let child = Command::new(&quot;/bin/cat&quot;)
    .arg(&quot;rusty-ideas.txt&quot;)
    .current_dir(&quot;/Users/aturon&quot;)
    .stdout(Stdio::piped())
    .spawn();
</code></pre>
<a class="header" href="print.html#traits-are-interfaces" id="traits-are-interfaces"><h3>Traits are interfaces</h3></a>
<p>Interfaces specify the expectations that one piece of code has on another,
allowing each to be switched out independently. For traits, this specification
largely revolves around methods.</p>
<p>Take, for example, the following simple trait for hashing:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Hash {
    fn hash(&amp;self) -&gt; u64;
}

#}</code></pre></pre>
<p>In order to implement this trait for a given type, you must provide a <code>hash</code>
method with matching signature:</p>
<pre><code class="language-rust ignore">impl Hash for bool {
    fn hash(&amp;self) -&gt; u64 {
        if *self { 0 } else { 1 }
    }
}

impl Hash for i64 {
    fn hash(&amp;self) -&gt; u64 {
        *self as u64
    }
}
</code></pre>
<p>Unlike interfaces in languages like Java, C# or Scala, <strong>new traits can be
implemented for existing types</strong> (as with <code>Hash</code> above). That means abstractions
can be created after-the-fact, and applied to existing libraries.</p>
<p>Unlike inherent methods, trait methods are in scope only when their trait
is. But assuming <code>Hash</code> is in scope, you can write <code>true.hash()</code>, so
implementing a trait extends the set of methods available on a type.</p>
<p>And... that's it! Defining and implementing a trait is really nothing more than
abstracting out a common interface satisfied by more than one type.</p>
<a class="header" href="print.html#static-dispatch" id="static-dispatch"><h3>Static dispatch</h3></a>
<p>Things get more interesting on the other side -- consuming a trait. The most
common way of doing so is through <em>generics</em>:</p>
<pre><code class="language-rust ignore">fn print_hash&lt;T: Hash&gt;(t: &amp;T) {
    println!(&quot;The hash is {}&quot;, t.hash())
}
</code></pre>
<p>The <code>print_hash</code> function is generic over an unknown type <code>T</code>, but requires that
<code>T</code> implements the <code>Hash</code> trait. That means we can use it with <code>bool</code> and <code>i64</code>
values:</p>
<pre><code class="language-rust ignore">print_hash(&amp;true);      // instantiates T = bool
print_hash(&amp;12_i64);    // instantiates T = i64
</code></pre>
<p><strong>Generics are compiled away, resulting in static dispatch</strong>. That is, as with
C++ templates, the compiler will generate <em>two copies</em> of the <code>print_hash</code>
method to handle the above code, one for each concrete argument type.  That in
turn means that the internal call to <code>t.hash()</code> -- the point where the
abstraction is actually used -- has zero cost: it will be compiled to a direct,
static call to the relevant implementation:</p>
<pre><code class="language-rust ignore">// The compiled code:
__print_hash_bool(&amp;true);  // invoke specialized bool version directly
__print_hash_i64(&amp;12_i64);   // invoke specialized i64 version directly
</code></pre>
<p>This compilation model isn't so useful for a function like <code>print_hash</code>, but
it's <em>very</em> useful for more realistic uses of hashing. Suppose we also introduce
a trait for equality comparison:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Eq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;
}

#}</code></pre></pre>
<p>(The reference to <code>Self</code> here will resolve to whatever type we implement the
trait for; in <code>impl Eq for bool</code> it will refer to <code>bool</code>.)</p>
<p>We can then define a hash map that is generic over a type <code>T</code> implementing both
<code>Hash</code> and <code>Eq</code>:</p>
<pre><code class="language-rust ignore">struct HashMap&lt;Key: Hash + Eq, Value&gt; { ... }
</code></pre>
<p>The static compilation model for generics will then yield several benefits:</p>
<ul>
<li>
<p>Each use of <code>HashMap</code> with concrete <code>Key</code> and <code>Value</code> types will result in a
different concrete <code>HashMap</code> type, which means that <code>HashMap</code> can lay out the
keys and values in-line (without indirection) in its buckets. This saves on
space and indirections, and improves cache locality.</p>
</li>
<li>
<p>Each method on <code>HashMap</code> will likewise generate specialized code. That means
there is no extra cost dispatching to calls to <code>hash</code> and <code>eq</code>, as above.  It
also means that the optimizer gets to work with the fully concrete code --
that is, from the point of view of the optimizer, <em>there is no abstraction</em>.
In particular, static dispatch allows for <em>inlining</em> across uses of generics.</p>
</li>
</ul>
<p>Altogether, just as in C++ templates, these aspects of generics mean that you
can write quite high-level abstractions that are <em>guaranteed</em> to compile down to
fully concrete code that &quot;you couldn't hand code any better&quot;.</p>
<p><strong>But, unlike with C++ templates, clients of traits are fully type-checked in
advance</strong>.  That is, when you compile <code>HashMap</code> in isolation, its code is
checked <em>once</em> for type correctness against the abstract <code>Hash</code> and <code>Eq</code> traits,
rather than being checked repeatedly when applied to concrete types. That means
earlier, clearer compilation errors for library authors, and less typechecking
overhead (i.e., faster compilation) for clients.</p>
<a class="header" href="print.html#dynamic-dispatch" id="dynamic-dispatch"><h3>Dynamic dispatch</h3></a>
<p>We've seen one compilation model for traits, where all abstraction is compiled
away statically. But sometimes abstraction isn't just about reuse or modularity
-- <strong>sometimes abstraction plays an essential role at runtime that can't be
compiled away</strong>.</p>
<p>For example, GUI frameworks often involve callbacks for responding to events,
such as mouse clicks:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait ClickCallback {
    fn on_click(&amp;self, x: i64, y: i64);
}

#}</code></pre></pre>
<p>It's also common for GUI elements to allow multiple callbacks to be registered
for a single event. With generics, you might imagine writing:</p>
<pre><code class="language-rust ignore">struct Button&lt;T: ClickCallback&gt; {
    listeners: Vec&lt;T&gt;,
    ...
}
</code></pre>
<p>but the problem is immediately apparent: that would mean that each button is
specialized to precisely one implementor of <code>ClickCallback</code>, and that the type
of the button reflects that type. That's not at all what we wanted! Instead,
we'd like a single <code>Button</code> type with a set of <em>heterogeneous</em> listeners, each
potentially a different concrete type, but each one implementing
<code>ClickCallback</code>.</p>
<p>One immediate difficulty here is that, if we're talking about a heterogeneous
group of types, <em>each one will have a distinct size</em> -- so how can we even lay
out the internal vector? The answer is the usual one: indirection. We'll store
<em>pointers</em> to callbacks in the vector:</p>
<pre><code class="language-rust ignore">struct Button {
    listeners: Vec&lt;Box&lt;ClickCallback&gt;&gt;,
    ...
}
</code></pre>
<p>Here, we are using the <code>ClickCallback</code> trait as if it were a type. Actually, in
Rust, <a href="http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/">traits <em>are</em> types, but they are &quot;unsized&quot;</a>, which roughly means
that they are only allowed to show up behind a pointer like <code>Box</code> (which points
onto the heap) or <code>&amp;</code> (which can point anywhere).</p>
<p>In Rust, a type like <code>&amp;ClickCallback</code> or <code>Box&lt;ClickCallback&gt;</code> is called a &quot;trait
object&quot;, and includes a pointer to an instance of a type <code>T</code> implementing
<code>ClickCallback</code>, <em>and</em> a vtable: a pointer to <code>T</code>'s implementation of each
method in the trait (here, just <code>on_click</code>). That information is enough to
dispatch calls to methods correctly at runtime, and to ensure uniform
representation for all <code>T</code>. So <code>Button</code> is compiled just once, and the
abstraction lives on at runtime.</p>
<p>Static and dynamic dispatch are complementary tools, each appropriate for
different scenarios. <strong>Rust's traits provide a single, simple notion of
interface that can be used in both styles, with minimal, predictable
costs</strong>. Trait objects satisfy Stroustrup's &quot;pay as you go&quot; principle: you have
vtables when you need them, but the same trait can be compiled away statically
when you don't.</p>
<a class="header" href="print.html#the-many-uses-of-traits" id="the-many-uses-of-traits"><h3>The many uses of traits</h3></a>
<p>We've seen a lot of the mechanics and basic use of traits above, but they also
wind up playing a few other important roles in Rust. Here's a taste:</p>
<ul>
<li>
<p><strong>Closures</strong>. Somewhat like the <code>ClickCallback</code> trait, closures in Rust are
simply particular traits. You can read more about how this works in
Huon Wilson's <a href="http://huonw.github.io/blog/2015/05/finding-closure-in-rust/">in-depth post</a> on the topic.</p>
</li>
<li>
<p><strong>Conditional APIs</strong>. Generics make it possible to implement a trait
conditionally:</p>
<pre><code class="language-rust ignore">struct Pair&lt;A, B&gt; { first: A, second: B }
impl&lt;A: Hash, B: Hash&gt; Hash for Pair&lt;A, B&gt; {
    fn hash(&amp;self) -&gt; u64 {
        self.first.hash() ^ self.second.hash()
    }
}
</code></pre>
<p>Here, the <code>Pair</code> type implements <code>Hash</code> if, and only if, its components do --
allowing the single <code>Pair</code> type to be used in different contexts, while
supporting the largest API available for each context.  It's such a common
pattern in Rust that there is built-in support for generating certain kinds of
&quot;mechanical&quot; implementations automatically:</p>
<pre><code class="language-rust ignore">#[derive(Hash)]
struct Pair&lt;A, B&gt; { .. }
</code></pre>
</li>
<li>
<p><strong>Extension methods</strong>. Traits can be used to extend an existing type (defined
elsewhere) with new methods, for convenience, similarly to C#'s extension
methods. This falls directly out of the scoping rules for traits: you just
define the new methods in a trait, provide an implementation for the type in
question, and <em>voila</em>, the method is available.</p>
</li>
<li>
<p><strong>Markers</strong>. Rust has a handful of &quot;markers&quot; that classify types: <code>Send</code>,
<code>Sync</code>, <code>Copy</code>, <code>Sized</code>. These markers are just <em>traits</em> with empty bodies,
which can then be used in both generics and trait objects. Markers can be
defined in libraries, and they automatically provide <code>#[derive]</code>-style
implementations: if all of a types components are <code>Send</code>, for example, so is
the type. As we saw <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">before</a>, these markers can be very powerful:
the <code>Send</code> marker is how Rust guarantees thread safety.</p>
</li>
<li>
<p><strong>Overloading</strong>. Rust does not support traditional overloading where the same
method is defined with multiple signatures. But traits provide much of the
benefit of overloading: if a method is defined generically over a trait, it
can be called with any type implementing that trait. Compared to traditional
overloading, this has two advantages. First, it means the overloading is less
<a href="http://dl.acm.org/citation.cfm?id=75283">ad hoc</a>: once you understand a trait, you immediately understand the
overloading pattern of any APIs using it. Second, it is <em>extensible</em>: you can
effectively provide new overloads downstream from a method by providing new
trait implementations.</p>
</li>
<li>
<p><strong>Operators</strong>. Rust allows you to overload operators like <code>+</code> on your own
types. Each of the operators is defined by a corresponding standard library
trait, and any type implementing the trait automatically provides the operator
as well.</p>
</li>
</ul>
<p>The point: <strong>despite their seeming simplicity, traits are a unifying concept
that supports a wide range of use cases and patterns, without having to pile on
additional language features.</strong></p>
<a class="header" href="print.html#the-future-1" id="the-future-1"><h3>The future</h3></a>
<p>One of the primary ways that languages tend to evolve is in their abstraction
facilities, and Rust is no exception: many of our <a href="http://internals.rust-lang.org/t/priorities-after-1-0/1901">post-1.0 priorities</a>
are extensions of the trait system in one direction or another. Here are some
highlights.</p>
<ul>
<li>
<p><strong>Statically dispatched outputs</strong>. Right now, it's possible for functions to
use generics for their parameters, but there's no equivalent for their
results: you cannot say &quot;this function returns a value of some type that
implements the <code>Iterator</code> trait&quot; and have that abstraction compiled away.
This is particularly problematic when you want to return a closure that you'd
like to be statically-dispatched -- you simply can't, in today's Rust. We want
to make this possible, and <a href="https://github.com/rust-lang/rfcs/pull/105">have some ideas already</a>.</p>
</li>
<li>
<p><strong>Specialization</strong>. Rust does not allow overlap between trait implementations,
so there is never ambiguity about which code to run. On the other hand, there
are some cases where you can give a &quot;blanket&quot; implementation for a wide range
of types, but would then like to provide a more specialized implementation for
a few cases, often for performance reasons. We hope to propose a design in the
near future.</p>
</li>
<li>
<p><strong>Higher-kinded types</strong> (HKT). Traits today can only be applied to <em>types</em>,
not <em>type constructors</em> -- that is, to things like <code>Vec&lt;u8&gt;</code>, not to <code>Vec</code>
itself. This limitation makes it difficult to provide a good set of container
traits, which are therefore not included in the current standard library. HKT
is a major, cross-cutting feature that will represent a big step forward in
Rust's abstraction capabilities.</p>
</li>
<li>
<p><strong>Efficient re-use</strong>. Finally, while traits provide some mechanisms for
reusing code (which we didn't cover above), there are still some patterns of
reuse that don't fit well into the language today -- notably, object-oriented
hierarchies found in things like the DOM, GUI frameworks, and many
games. Accommodating these use cases without adding too much overlap or
complexity is a very interesting design problem, and one that Niko Matsakis
has started a separate <a href="http://smallcultfollowing.com/babysteps/blog/2015/05/05/where-rusts-enum-shines/">blog series</a> about. It's not yet clear
whether this can all be done with traits, or whether some other ingredients
are needed.</p>
</li>
</ul>
<p>Of course, we're at the eve of the 1.0 release, and it will take some time for
the dust to settle, and for the community to have enough experience to start
landing these extensions. But that makes it an exciting time to get involved:
from influencing the design at this early stage, to working on implementation,
to trying out different use cases in your own code -- we'd love to have your
help!</p>
<blockquote>
<p><a href="http://blog.rust-lang.org/2015/05/11/traits.html"><em>Originally published 2015-05-11</em></a></p>
<p><em>License: TBD</em></p>
</blockquote>
<a class="header" href="print.html#all-about-trait-objects" id="all-about-trait-objects"><h1>All About Trait Objects</h1></a>
<p>One of the most powerful parts of
<a href="http://rust-lang.org">the Rust programming language</a><sup class="footnote-reference"><a href="print.html#version">1</a></sup> is the
<a href="http://doc.rust-lang.org/nightly/book/traits.html">trait system</a>. They form the basis of the generic system and
polymorphic functions and types. There's an interesting use of traits,
as so-called &quot;trait objects&quot;, that allows for dynamic polymorphism and
heterogeneous uses of types, which I'm going to look at in more detail
over a short series of posts.</p>
<p><em>Update 2015-02-19</em>: A lot of this document has been copied into
<a href="http://doc.rust-lang.org/nightly/book/trait-objects.html">the main book</a>, with improvements and updates.</p>
<div class="footnote-definition" id="version"><sup class="footnote-definition-label">1</sup>
<p>It's generally good practice for Rust posts to mention
their version due to language instability, but this post
and the series won't have much real runnable code and the
concepts described are pretty stable... but habits die
hard: <code>rustc 1.0.0-nightly (44a287e6e 2015-01-08 17:03:40 -0800)</code>.</p>
<p>which should also be the 1.0.0-alpha release (speaking of which,
the language instability should be starting to settle down now).</p>
<a class="header" href="print.html#part-1-peeking-inside-trait-objects" id="part-1-peeking-inside-trait-objects"><h2>Part 1: Peeking Inside Trait Objects</h2></a>
<p>This post will set the scene, with an introduction to the internals of
a trait object; the remaining posts will look at the <code>Sized</code> trait and
&quot;object safety&quot; in detail (a lot of people have encountered trouble
with somewhat abstruse compiler errors about this recently).</p>
</div>
<a class="header" href="print.html#traits-1" id="traits-1"><h3>Traits</h3></a>
<p>A simple example of a <code>trait</code> is this <code>Foo</code>. It has one method that is
expected to return a <code>String</code>, and, in the real world, there would be
some expectation about what the string would mean, but this is just a
blog, so you're free to make up your own favourite meaning.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn method(&amp;self) -&gt; String;
}

#}</code></pre></pre>
<p>This can then be implemented for certain types, stating that these
types satisfy whatever behaviours the trait is trying to summarise and
allow polymorphism over. For example, bytes and strings are <code>Foo</code>,
apparently:</p>
<pre><code class="language-rust ignore">impl Foo for u8 {
    fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
}
impl Foo for String {
    fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
}
</code></pre>
<p>There's two basic ways to use traits to be polymorphic:</p>
<p>The first and most common are generic functions like <code>fn func&lt;T: Foo&gt;(x: &amp;T)</code>. These are implemented via monomorphisation, the compiler
creates a specialised version of the generic function for every type
used with it. This has some upsides—static dispatching of any
method calls<sup class="footnote-reference"><a href="print.html#upsides">2</a></sup>, allowing for inlining and hence usually higher
performance—and some downsides—causing code bloat due to
many copies of the same function existing in the binary, one for each
type<sup class="footnote-reference"><a href="print.html#one-per-type">3</a></sup>.</p>
<p>Fortunately, there's second option if that trade-off is inappropriate,
or if being required to know every type everywhere is impossible or
undesirable.</p>
<div class="footnote-definition" id="upsides"><sup class="footnote-definition-label">2</sup>
<p>Static dispatching isn't <em>guaranteed</em> to be an upside:
compilers aren't perfect and may &quot;optimise&quot; code to become
slower. For example, functions inlined too eagerly will
bloating the instruction cache (cache rules everything
around us). This is part of the reason that <code>#[inline]</code>
and <code>#[inline(always)]</code> that should be used carefully, and
one reason why using a trait object—with its dynamic
dispatch—is sometimes more efficient.</p>
<p>However, the common case is that it is more efficient to use static
dispatch, and one can always have a thin statically-dispatched wrapper
function that does a dynamic, but not vice versa, meaning static calls
are more flexible. The standard library tries to be statically
dispatched where possible for this reason.</p>
</div>
<div class="footnote-definition" id="one-per-type"><sup class="footnote-definition-label">3</sup>
<p>There's no guarantee that there will actually be a
copy of the function for each type that implements
the trait, or even for each type that is used with
the function, since the compiler is free to combine
copies if it can tell that sharing the code would not
change semantics. But, in general, this optimisation
doesn't trigger.</p>
<a class="header" href="print.html#trait-objects" id="trait-objects"><h3>Trait objects</h3></a>
<p>Trait objects, like <code>&amp;Foo</code> or <code>Box&lt;Foo&gt;</code>, are normal values that store
a value of <em>any</em> type that implements the given trait, where the
precise type can only be known at runtime. The methods of the trait
can be called on a trait object via a special record of function
pointers (created and managed by the compiler).</p>
<p>A function that takes a trait object—say <code>fn func(x: &amp;Foo)</code>—is not
specialised to each of the types that implements <code>Foo</code>: only one copy
is generated, often (but not always) resulting in less code
bloat. However, this comes at the cost of requiring slower virtual
function calls, and effectively inhibiting any chance of inlining and
related optimisations from occurring.</p>
<p>Trait objects are both simple and complicated: their core
representation and layout is quite straight-forward, but there are
some curly error messages and surprising behaviours to discover.</p>
<a class="header" href="print.html#obtaining-a-trait-object" id="obtaining-a-trait-object"><h3>Obtaining a trait object</h3></a>
<p>There's two similar ways to get a trait object value: casts and
coercions. If <code>T</code> is a type that implements a trait <code>Foo</code> (e.g. <code>u8</code>
for the <code>Foo</code> above), then the two ways to get a <code>Foo</code> trait object
out of a pointer to <code>T</code> look like:</p>
<pre><code class="language-rust ignore">let ref_to_t: &amp;T = ...;

// `as` keyword for casting
let cast = ref_to_t as &amp;Foo;

// using a `&amp;T` in a place that has a known type of `&amp;Foo` will implicitly coerce:
let coerce: &amp;Foo = ref_to_t;

fn also_coerce(_unused: &amp;Foo) {}
also_coerce(ref_to_t);
</code></pre>
<p>These trait object coercions and casts also work for pointers like
<code>&amp;mut T</code> to <code>&amp;mut Foo</code> and <code>Box&lt;T&gt;</code> to <code>Box&lt;Foo&gt;</code>, but that's all at
the moment. Other than some bugs, coercions and casts are identical.</p>
<p>This operation can be seen as &quot;erasing&quot; the compiler's knowledge about
the specific type of the pointer, and hence trait objects are
sometimes referred to &quot;type erasure&quot;.</p>
</div>
<a class="header" href="print.html#representation" id="representation"><h3>Representation</h3></a>
<p>Let's start simple, with the runtime representation of a trait
object. The <code>std::raw</code> module contains structs with layouts that are
the same as the complicated build-in types,
<a href="http://doc.rust-lang.org/nightly/std/raw/struct.TraitObject.html">including trait objects</a>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}

#}</code></pre></pre>
<p>That is, a trait object like <code>&amp;Foo</code> consists of a &quot;data&quot; pointer and a
&quot;vtable&quot; pointer.</p>
<p>The data pointer addresses the data (of some unknown type <code>T</code>) that
the trait object is storing, and the vtable pointer points to the
<a href="https://en.wikipedia.org/wiki/Virtual_method_table">vtable</a> (&quot;virtual method table&quot;) corresponding to the implementation
of <code>Foo</code> for <code>T</code>.</p>
<p>A vtable is essentially a struct of function pointers, pointing to the
concrete piece of machine code for each method in the
implementation. A method call like <code>trait_object.method()</code> will
retrieve the correct pointer out of the vtable and then do a dynamic
call of it. For example:</p>
<pre><code class="language-rust ignore">struct FooVtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -&gt; String,
}


// u8:

fn call_method_on_u8(x: *const ()) -&gt; String {
    // the compiler guarantees that this function is only called
    // with `x` pointing to a u8
    let byte: &amp;u8 = unsafe { &amp;*(x as *const u8) };

    byte.method()
}

static Foo_for_u8_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    size: 1,
    align: 1,

    // cast to a function pointer
    method: call_method_on_u8 as fn(*const ()) -&gt; String,
};


// String:

fn call_method_on_String(x: *const ()) -&gt; String {
    // the compiler guarantees that this function is only called
    // with `x` pointing to a String
    let string: &amp;String = unsafe { &amp;*(x as *const String) };

    string.method()
}

static Foo_for_String_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    // values for a 64-bit computer, halve them for 32-bit ones
    size: 24,
    align: 8,

    method: call_method_on_String as fn(*const ()) -&gt; String,
};
</code></pre>
<p>(The <code>call_method_on_...</code> functions could also be UFCS: <code>&lt;... as Foo&gt;::method</code>, but that's somewhat less clear.)</p>
<p>The <code>destructor</code> field in each vtable points to a function that will
clean up any resources of the vtable's type, for <code>u8</code> it is trivial,
but for <code>String</code> it will free the memory. This is necessary for owning
trait objects like <code>Box&lt;Foo&gt;</code>, which need to clean-up both the <code>Box</code>
allocation and as well as the internal type when they go out of
scope. The <code>size</code> and <code>align</code> fields store the size of the erased
type, and its alignment requirements; these are essentially unused at
the moment since the information is embedded in the destructor, but
will be used in future, as trait objects are progressively made more
flexible.</p>
<p>Suppose we've got some values that implement <code>Foo</code>, the explicit form
of construction and use of <code>Foo</code> trait objects might look a bit like
(ignoring the type mismatches: they're all just pointers anyway):</p>
<pre><code class="language-rust ignore">let a: String = &quot;foo&quot;.to_string();
let x: u8 = 1;

// let b: &amp;Foo = &amp;a;
let b = TraitObject {
    // store the data
    data: &amp;a,
    // store the methods
    vtable: &amp;Foo_for_String_vtable
};

// let y: &amp;Foo = x;
let y = TraitObject {
    // store the data
    data: &amp;x,
    // store the methods
    vtable: &amp;Foo_for_u8_vtable
};

// b.method();
(b.vtable.method)(b.data);

// y.method();
(y.vtable.method)(y.data);
</code></pre>
<p>If <code>b</code> or <code>y</code> were owning trait objects (<code>Box&lt;Foo&gt;</code>), there would be a
<code>(b.vtable.destructor)(b.data)</code> (respectively <code>y</code>) call when they went
out of scope.</p>
<a class="header" href="print.html#why-pointers" id="why-pointers"><h4>Why pointers?</h4></a>
<p>The use of language like &quot;fat pointer&quot; implies that a trait object is
always a pointer of some form, but why? I wrote above that</p>
<blockquote>
<p>[Trait objects] are normal values and can store a value of <em>any</em> type
that implements the given trait, where the precise type can only
be known at runtime.</p>
</blockquote>
<p>Rust does not put things behind a pointer by default, unlike many
managed languages, so types can have different sizes. Knowing the size
of the value at compile time is important for things like passing it
as an argument to a function, moving it about on the stack and
allocating (and deallocating) space on the heap to store it.</p>
<p>For <code>Foo</code>, we would need to have a value that could be at least either
a <code>String</code> (24 bytes) or a <code>u8</code> (1 byte), as well as any other type
for which dependent crates may implement <code>Foo</code> (any number of bytes at
all). There's no way to guarantee that this last point can work if the
values are stored without a pointer, because those other types can be
arbitrarily large.</p>
<p>Putting the value behind a pointer means the size of the value is not
relevant when we are tossing a trait object around, only the size of
the pointer itself.</p>
<a class="header" href="print.html#part-2-the-sized-trait" id="part-2-the-sized-trait"><h2>Part 2: The <code>Sized</code> Trait</h2></a>
<p>An important piece in my story about trait objects in
<a href="http://rust-lang.org">Rust</a><sup class="footnote-reference"><a href="print.html#version">1</a></sup> is <a href="https://doc.rust-lang.org/nightly/std/marker/trait.Sized.html">the <code>Sized</code> trait</a>,
so I'm slotting in this short post between
[my discussion of low-level details][previouspost] and
[the post on &quot;object safety&quot;][nextpost].</p>
<div class="footnote-definition" id="version"><sup class="footnote-definition-label">1</sup>
<p>Per the [previous post][previouspost], this post is
designed to reflect the state of Rust at version: <code>rustc 1.0.0-nightly (44a287e6e 2015-01-08 17:03:40 -0800)</code>.</p>
<p>[previouspost]: {% post_url 2015-01-10-peeking-inside-trait-objects %}
[nextpost]: {% post_url 2015-01-13-object-safety %}</p>
<p><code>Sized</code> is a (very) special compiler built-in trait that is
automatically implemented or not based on the sizedness of a type. A
type is considered sized if the precise size of a value of type is
known and fixed at compile time once the real types of the type
parameters are known (i.e. after completing monomorphisation). For
example,</p>
<ul>
<li><code>u8</code> is one byte,</li>
<li><code>Vec&lt;T&gt;</code> is either 12 or 24 bytes (platforms with 32 and 64 bit
pointers respectively), independent of <code>T</code>,</li>
<li>pointers like <code>&amp;T</code> are sized too, on 64-bit platforms <code>&amp;T</code> is either
8 or 16 bytes, for sized <code>T</code> and unsized <code>T</code> respectively. This may
seems like the size isn't known, but the sizedness of <code>T</code> is always
known at compile time, so the precise one of those options is also
known.</li>
</ul>
<p>Types for which the size is not known are called
[dynamically sized types (DSTs)][dst], and there's two classes of
examples in current Rust<sup class="footnote-reference"><a href="print.html#virtual">4</a></sup>: <code>[T]</code> and <code>Trait</code>. A slice<sup class="footnote-reference"><a href="print.html#str">5</a></sup>
<code>[T]</code> is unsized because it represents an unknown-at-compile-time
number of <code>T</code>s contiguous in memory. A <code>Trait</code> is unsized because it
represents a value of any type that implements <code>Trait</code> and these have
wildly different sizes; I discussed this
[in the previous post too][whypointers]. Unsized values must always
appear behind a pointer at runtime, like <code>&amp;[T]</code> or <code>Box&lt;Trait&gt;</code>, and
have the information required to compute their size and other relevant
properties (the length for <code>[T]</code>, the vtable for <code>Trait</code>) stored next
to that pointer.</p>
</div>
<div class="footnote-definition" id="virtual"><sup class="footnote-definition-label">4</sup>
<p>There is the possibility that Rust will gain some form of
<a href="http://discuss.rust-lang.org/t/summary-of-efficient-inheritance-rfcs/494">&quot;inheritance&quot;</a>, and Niko points out to me that
<code>Sized</code> may play an important role there too: certain
types (e.g. &quot;base classes&quot; in an conventional inheritance
scheme)  make sense to be unsized.</p>
</div>
<div class="footnote-definition" id="str"><sup class="footnote-definition-label">5</sup>
<p>The unsized string type <code>str</code> is usually considered a slice,
since it is just a <code>[u8]</code> with the guarantee that the bytes
are valid UTF-8.</p>
</div>
<p>Sized types are more flexible, since the compiler knows how to
manipulate them directly: passing them directly into functions, moving
them about in memory. Putting an unsized type behind a pointer
effectively makes it sized. A <code>Box</code> trait object, like <code>Box&lt;Trait&gt;</code>,
is the closest one can get to handling a trait object as a normal
value; the <code>Box</code> ensures sizedness (at the expense of an allocation)
without fundamentally changing the ownership semantics of a normal
value.</p>
<a class="header" href="print.html#sized" id="sized"><h3><code>?Sized</code></h3></a>
<p>The <code>Sized</code> trait gets some special syntax for use in bounds, at the
moment: <code>?Sized</code>. Such a bound is necessary because <code>Sized</code> is
special: it is a default bound for type parameters in most positions,
and so one needs some way to opt-in to a parameter not necessarily
being sized.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn foo&lt;T&gt;() {} // can only be used with sized T

fn bar&lt;T: ?Sized&gt;() {} // can be used with both sized and unsized T

#}</code></pre></pre>
<p>This bound is particularly special because adding the <code>?Sized</code> bound
to a parameter <code>T</code> increases the number of types that can be used for
<code>T</code>, whereas every other trait bound reduces it.</p>
<p>This unusual decision was chosen because of the increased flexibility
of sized types, and some data (which I now can't find in the issue
tracker) which indicated that most type parameters needed to be
sized. That is, not having these defaults would result in many
instances of <code>T: Sized</code> bounds in the standard library and elsewhere.</p>
<p>However, I believe this data did not consider using some form of
inference (like lifetime elision) to try to guess when sizedness was
likely to be needed, and some data Niko has been collecting apparently
implies that such inference may make removing this special case
significantly more palatable. (It may or may not be so palatable so as
to be worth the breaking change...)</p>
<p>[whypointers]: {% post_url 2015-01-10-peeking-inside-trait-objects %}#why-pointers
[dst]: http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/</p>
<a class="header" href="print.html#part-3-object-safety" id="part-3-object-safety"><h2>Part 3: Object Safety</h2></a>
<p>A trait object in <a href="http://rust-lang.org">Rust</a><sup class="footnote-reference"><a href="print.html#version">1</a></sup> can only be
constructed out of traits that satisfy certain restrictions, which are
collectively called &quot;object safety&quot;. This object safety can appear to
be a needless restriction at first, I'll try to give a deeper
understanding into why it exists and related compiler behaviour.</p>
<div class="footnote-definition" id="version"><sup class="footnote-definition-label">1</sup>
<p>[As usual][previouspost], this post is designed to reflect
the state of Rust at version <code>rustc 1.0.0-nightly (44a287e6e 2015-01-08 17:03:40 -0800)</code>.</p>
</div>
<p>[previouspost]: {% post_url 2015-01-10-peeking-inside-trait-objects %}
[sizedpost]: {% post_url 2015-01-12-the-sized-trait %}</p>
<p>This is the second (and a half) in a short series of articles on trait
objects. The first
one---[Peeking inside Trait Objects][previouspost]---set the scene by
looking into the low-level implementation details of trait objects,
and the
first-and-a-half-th---[an interlude about <code>Sized</code>][sizedpost]---looked
at the special <code>Sized</code> trait. I strongly recommended at least glancing
over it to be familiar with trait objects, vtables and <code>Sized</code>,
since this post builds on those concepts.</p>
<a class="header" href="print.html#motivation" id="motivation"><h2>Motivation</h2></a>
<p>The notion of object safety was introduced in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255</a>, with
the motivation that one should be able to use the dynamic trait object
types <code>Foo</code> (as a type) in more places where a &quot;static&quot; <code>Foo</code> (as a
trait) generic is expected. In a sense, it is bringing the two uses of
traits---static dispatch and dynamic dispatch---closer together,
reducing special handling in the language.</p>
<p>The high-level behaviour/restriction imposed by that RFC is: a trait
object---<code>&amp;Foo</code>, <code>&amp;mut Foo</code>, etc.---can only be made out of a trait
<code>Foo</code> if <code>Foo</code> is object safe. This section will focus on borrowed <code>&amp;</code>
trait objects, but what is said applies to any.</p>
<p>Let's look at an example of the things object safety enables: if we
have a trait <code>Foo</code> and a function like</p>
<pre><code class="language-rust ignore">fn func&lt;T: Foo + ?Sized&gt;(x: &amp;T) { ... }
</code></pre>
<p>It would be nice to be able to call it like <code>func(object)</code> where
<code>object: &amp;Foo</code>; that is, take <code>T</code> to be the dynamically sized type
<code>Foo</code>. As you might guess from the context, it is not possible to
do this without some notion of object safety: the arbitrary piece of
code <code>...</code> can do bad (uncontrolled) things.</p>
<p>Take it on faith (for a few paragraphs) that calling a generic method
is one example of something that can't be done on a trait object. So,
let's define a trait and a function like:</p>
<pre><code class="language-rust ignore">trait Bad {
    fn generic_method&lt;A&gt;(&amp;self, value: A);
}

fn func&lt;T: Bad + ?Sized&gt;(x: &amp;T) {
    x.generic_method(&quot;foo&quot;); // A = &amp;str
    x.generic_method(1_u8); // A = u8
}
</code></pre>
<p>The function <code>func</code> <em>can't</em> be called like <code>foo(obj)</code> where <code>obj</code> is a
trait object <code>&amp;Bad</code> because the generic method calls are
illegal. There's a possible approaches here, like</p>
<ol>
<li>have signatures like <code>&lt;T: Foo + ?Sized&gt;(x: &amp;T)</code> not work with <code>T = Foo</code> by default, for any trait <code>Foo</code>,</li>
<li>check the body of the function to see if it is legal to have <code>T = Bad</code> when we ask for that, or</li>
<li>ensure that we can never pass a <code>&amp;Bad</code> into <code>func</code>.</li>
</ol>
<p>Approach 1 is what existed before object safety, and is what object
safety was designed to solve. Approach 2 violates Rust's goal of
needing to know only the signatures of any function/method called to
type-check a program. That is, if one satisfies the signature one can
call it, unlike C++, there's no need to type-check internal code of
each the actual instantiation of a generic because the signatures
guarantee that the internals will be legal.</p>
<p>Approach 3 is the one that Rust takes via object safety, by ensuring
that it is impossible to ever encounter a scenario in which a function
with signature <code>fn func&lt;T: Foo + ?Sized&gt;(x: &amp;T)</code> that does bad things,
could have <code>T == Foo</code>. That is, make it so that the only way that a
<code>&amp;Foo</code> can be created is if there's no way that <code>func</code> can misbehave.</p>
<p>Object safety and those sort of function signatures apply particularly
to UFCS (uniform function call syntax), which allows one to call
methods as normal, generic function scoped under the type/trait in
which they are defined, for example, the UFCS function
<code>Bad::generic_method</code> from the trait above effectively has signature:</p>
<pre><code class="language-rust ignore">fn Bad::generic_method&lt;Self: Bad + ?Sized, A&gt;(self: &amp;Self, x: A)
</code></pre>
<p>If <code>fn method(&amp;self)</code> comes from a trait <code>Foo</code>, <code>x.method()</code> can
always be rewritten to <code>Foo::method(x)</code> (modulo auto-deref and
auto-ref, which possibly add an <code>&amp;</code> and/or some number of <code>*</code>s),
however, without object safety, it may not be possible to write
<code>trait_object.method()</code> as <code>Foo::method(trait_object)</code>. Object safety
guarantees this transformation is always valid---making UFCS and
method calls essentially equivalent---by outlawing creating a trait
object in situations where it would be invalid.</p>
<a class="header" href="print.html#how-it-works" id="how-it-works"><h2>How it works</h2></a>
<p>After <a href="https://github.com/rust-lang/rfcs/blob/master/text/0546-Self-not-sized-by-default.md">RFC 546</a> and <a href="https://github.com/rust-lang/rust/pull/20341">PR 20341</a>, making trait objects
automatically work with those sort of generic functions is achieved by
effectively having the compiler implicitly create an implementation of
<code>Foo</code> (as a trait) for <code>Foo</code> (as a type). Each method of the trait is
implemented to call into the corresponding method in the vtable. In
the explicit notation of [my previous post][previouspost], the
situation might look something like:</p>
<pre><code class="language-rust ignore">trait Foo {
    fn method1(&amp;self);
    fn method2(&amp;mut self, x: i32, y: String) -&gt; usize;
}

// autogenerated impl
impl&lt;'a&gt; Foo for Foo+'a {
    fn method1(&amp;self) {
        // `self` is an `&amp;Foo` trait object.

        // load the right function pointer and call it with the opaque data pointer
        (self.vtable.method1)(self.data)
    }
    fn method2(&amp;mut self, x: i32, y: String) -&gt; usize {
        // `self` is an `&amp;mut Foo` trait object

        // as above, passing along the other arguments
        (self.vtable.method2)(self.data, x, y)
    }
}
</code></pre>
<p>To be clear: the <code>.vtable</code> and <code>.data</code> notation doesn't work directly
on trait objects, so that code has no hope of compiling, I am just
being explicit about actual behaviour.</p>
<a class="header" href="print.html#object-safety" id="object-safety"><h2>Object safety</h2></a>
<p>The rules for object safety were set-out in that initial
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255</a>, with two missed cases identified and resolved in
<a href="https://github.com/rust-lang/rfcs/issues/428">RFC 428</a> and <a href="https://github.com/rust-lang/rfcs/blob/master/text/0546-Self-not-sized-by-default.md">RFC 546</a>. At the time of writing, the
possible ways to be object-unsafe are described
<a href="https://github.com/rust-lang/rust/blob/2127e0d56d85ff48aafce90ab762650e46370b63/src/librustc/middle/traits/object_safety.rs#L30-L52">by two enums</a>:</p>
<pre><code class="language-rust ignore">pub enum ObjectSafetyViolation&lt;'tcx&gt; {
    /// Self : Sized declared on the trait
    SizedSelf,

    /// Method has someting illegal
    Method(Rc&lt;ty::Method&lt;'tcx&gt;&gt;, MethodViolationCode),
}

/// Reasons a method might not be object-safe.
#[derive(Copy,Clone,Show)]
pub enum MethodViolationCode {
    /// e.g., `fn(self)`
    ByValueSelf,

    /// e.g., `fn foo()`
    StaticMethod,

    /// e.g., `fn foo(&amp;self, x: Self)` or `fn foo(&amp;self) -&gt; Self`
    ReferencesSelf,

    /// e.g., `fn foo&lt;A&gt;()`
    Generic,
}
</code></pre>
<p>Let's go through each case.</p>
<p><em>Update 2015-05-06</em>: <a href="https://github.com/rust-lang/rfcs/pull/817">RFC 817</a> added more precise control
over object safety via <code>where</code> clauses, see
[<em>Where Self Meets Sized: Revisiting Object Safety</em>][whereselfsized].</p>
<p>[whereselfsized]: {% post_url 2015-05-06-where-self-meets-sized-revisiting-object-safety %}</p>
<a class="header" href="print.html#sized-self" id="sized-self"><h3>Sized <code>Self</code></h3></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo: Sized {
    fn method(&amp;self);
}

#}</code></pre></pre>
<p>The trait <code>Foo</code> inherits from <code>Sized</code>, requiring the <code>Self</code> type to be
sized, and hence writing <code>impl Foo for Foo</code> is illegal: the type <code>Foo</code>
is not sized and doesn't implement <code>Sized</code>. Traits default to <code>Self</code>
being possibly-unsized---effectively a bound <code>Self: ?Sized</code>---to make
more traits object safe by default.</p>
<a class="header" href="print.html#by-value-self" id="by-value-self"><h3>By-value <code>self</code></h3></a>
<p><em>Update 2015-05-06</em>: this is no longer object unsafe, but it is
impossible to call such methods on possibly-unsized types, including
trait objects. That is, one can define traits with <code>self</code> methods,
but one is statically disallowed from call those methods on trait
objects (and on generics that could be trait objects).</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn method(self);
}

#}</code></pre></pre>
<p>At the moment<sup class="footnote-reference"><a href="print.html#change-is-in-the-air">6</a></sup>, it's not possible to use trait
objects by-value anywhere, due to the lack of sizedness. If one were
to write an <code>impl Foo for Foo</code>, the signature of <code>method</code> would mean
<code>self</code> has type <code>Foo</code>: a by-value unsized type, illegal!</p>
<div class="footnote-definition" id="change-is-in-the-air"><sup class="footnote-definition-label">6</sup>
<p>There is desire to remove/relax this
restriction for function parameters, and
especially <code>self</code>, to allow them to be
unsized types. Niko's <a href="http://smallcultfollowing.com/babysteps/blog/2014/11/26/purging-proc/">&quot;Purging proc&quot;</a>
describes the problem and the necessity for
<a href="http://doc.rust-lang.org/nightly/std/thunk/trait.Invoke.html">the <code>Invoke</code> trait</a> as a work-around
for the <code>FnOnce</code> trait.</p>
<a class="header" href="print.html#static-method" id="static-method"><h3>Static method</h3></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn func() -&gt; i32;
}

#}</code></pre></pre>
<p>There's no way to provide a sensible implementation of <code>func</code> as a
static method on the type <code>Foo</code>:</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; Foo for Foo+'a {
    fn func() -&gt; i32 {
        // what goes here??
    }
}
</code></pre>
<p>The compiler can't just conjure up some <code>i32</code>---the chosen value may
make no sense in context---and it can't call some other type's
<code>Foo::func</code> method---which type would it choose? The whole scenario
makes no sense.</p>
<a class="header" href="print.html#references-self" id="references-self"><h3>References <code>Self</code></h3></a>
<p>There's two fundamental ways in which this can happen, as an argument
or as a return value, in either case a reference to the <code>Self</code> type
means that it must match the type of the <code>self</code> value, the true type
of which is unknown at compile time. For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn method(&amp;self, other: &amp;Self);
}

#}</code></pre></pre>
<p>The types of the two arguments have to match, but this can't be
guaranteed with a trait object: the erased types of two separate
<code>&amp;Foo</code> values may not match:</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; Foo for Foo+'a {
    fn method(&amp;self, other: &amp;(Foo+'a))
        (self.vtable.method)(self.data, /* what goes here? */)
    }
}
</code></pre>
<p>(Using the explicit-but-invalid notation as above.)</p>
<p>One can't use <code>other.data</code> because the <code>method</code> entry of <code>self.vtable</code>
is assuming that both pointers point to the same, specific type
(whatever type the vtable is specialised for), but there's absolutely
no guarantee <code>other.data</code> points to matching data. There's also not
necessarily a (reliable) way to detect a mismatch, and no way the
compiler can know a correct way to handle a mismatch even if it can be
detected.</p>
<a class="header" href="print.html#generic-method" id="generic-method"><h3>Generic method</h3></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn method&lt;A&gt;(&amp;self, a: A);
}

#}</code></pre></pre>
<p>As discussed briefly in [the first post][previouspost], generic
functions in Rust are monomorphised, that is, a copy of the function
is created for each type used as a generic parameter. An attempted
implementation might look like</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; Foo for Foo+'a {
    fn method&lt;A&gt;(&amp;self, a: A) {
        (self.vtable./* ... huh ???*/)(self.data, a: A)
    }
}
</code></pre>
<p>The vtable is a static struct of function pointers, somehow we have to
select a function pointer from it that will work with the arbitrary
type <code>A</code>. To have any hope of doing this, one would have<sup class="footnote-reference"><a href="print.html#alternative">7</a></sup>
to pregenerate code for every type that could possibly be used for <code>A</code>
and then fill in the <code>huh</code> above to select the right one. This would
be effectively implicitly adding a whole series of methods to the
trait:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn method_u8(&amp;self);     // A = u8
    fn method_i8(&amp;self);     // A = i8
    fn method_String(&amp;self); // A = String
    fn method_unit(&amp;self);   // A = ()
    // ...
}

#}</code></pre></pre>
<p>and each one would need an entry in the vtable struct. If it is even
possible, this would be some serious bloat, especially as I imagine
most possibilities wouldn't be used.</p>
<p>For the more fundamental question of &quot;is it possible&quot;, the answer is
rarely: it only works if the number of possible types that can be used
with the generic parameters is finite and completely known, so that a
complete list can be written. I think the only circumstance in which
this occurs is if all the parameters have to be bounded by some
private trait (the example above fails, since <code>A</code> is unbounded and so
can be used with every type ever, including ones that aren't even
defined in scope).</p>
</div>
<div class="footnote-definition" id="alternative"><sup class="footnote-definition-label">7</sup>
<p>Strictly speaking I suppose one could do some type of
runtime codegen/JITing, but that's not really
something Rust wants to build into the language, as it
would require Rust programs to essentially carry
around a compiler.</p>
</div>
<a class="header" href="print.html#part-4-where-self-meets-sized" id="part-4-where-self-meets-sized"><h2>Part 4: Where <code>Self</code> Meets <code>Sized</code></h2></a>
<p>The concept of object safety in Rust was recently refined to be more
flexible in an important way: the checks can be disabled for specific
methods by using <code>where</code> clauses to restrict them to only work when
<code>Self: Sized</code>.</p>
<p>[trait-objects]: {% post_url 2015-01-10-peeking-inside-trait-objects %}
<a href="https://doc.rust-lang.org/nightly/std/marker/trait.Sized.html">sized</a>: {% post_url 2015-01-12-the-sized-trait %}
[object-safety]: {% post_url 2015-01-13-object-safety %}</p>
<p>This post is a rather belated fourth entry in my series on trait
objects and object safety:
[<em>Peeking inside Trait Objects</em>][trait-objects],
<a href="https://doc.rust-lang.org/nightly/std/marker/trait.Sized.html"><em>The Sized Trait</em></a> and [<em>Object Safety</em>][object-safety]. It's
been long enough that a refresher is definitely in order, although this
isn't complete coverage of the details.</p>
<a class="header" href="print.html#recap" id="recap"><h2>Recap</h2></a>
<p>Rust offers open sets of types, type erasure and dynamic dispatch via
[trait objects][trait-objects]. However, to ensure a uniform handling
of trait objects and non-trait objects in generic code, there are
certain restrictions about exactly which traits can be used to create
objects: this is [object safety][object-safety].</p>
<p>A trait is object safe only if the compiler can automatically
implement it for itself, by implementing each method as a dynamic
function call through the vtable stored in a trait object.</p>
<pre><code class="language-rust ignore">trait Foo {
    fn method_a(&amp;self) -&gt; u8;

    fn method_b(&amp;self, x: f32) -&gt; String;
}

// automatically inserted by the compiler
impl&lt;'a&gt; Foo for Foo+'a {
    fn method_a(&amp;self) -&gt; u8 {
         // dynamic dispatch to `method_a` of erased type
         self.method_a()
    }
    fn method_b(&amp;self, x: f32) -&gt; String {
         // as above
         self.method_b(x)
    }
}
</code></pre>
<p>Without the object safety rules one can write functions with type
signatures satisfied by trait objects, where the internals make it
impossible to actually use with trait objects. However, Rust tries to ensure
that this can't happen---code should only need to know the signatures
of anything it calls, not the internals---and hence object safety.</p>
<p>These rules outlaw creating trait objects of, for example, traits with
generic methods:</p>
<pre><code class="language-rust ignore">trait Bar {
    fn bad&lt;T&gt;(&amp;self, x: T);
}

impl Bar for u8 {
    fn bad&lt;T&gt;(&amp;self, _: T) {}
}

fn main() {
    &amp;1_u8 as &amp;Bar;
}

/*
...:10:5: 10:7 error: cannot convert to a trait object because trait `Bar` is not object-safe [E0038]
...:10     &amp;1 as &amp;Bar;
           ^~
...:10:5: 10:7 note: method `bad` has generic type parameters
...:10     &amp;1 as &amp;Bar;
           ^~
*/
</code></pre>
<p>Trait object values always appear behind a pointer, like <code>&amp;SomeTrait</code>
or <code>Box&lt;AnotherTrait&gt;</code>, since the trait value &quot;<code>SomeTrait</code>&quot; itself
doesn't have size known at compile time. This property is captured via
the <a href="https://doc.rust-lang.org/nightly/std/marker/trait.Sized.html"><code>Sized</code> trait</a>, which is implemented for types like <code>i32</code>,
or simple <code>struct</code>s and <code>enum</code>s, but not for unsized slices <code>[T]</code>, or
the plain trait types <code>SomeTrait</code>.</p>
<a class="header" href="print.html#iterating-on-the-design" id="iterating-on-the-design"><h2>Iterating on the design</h2></a>
<p>One impact of introducing object safety was that the design of several
traits had to change. The most noticeable ones were <code>Iterator</code>, and
the IO traits <code>Read</code> and <code>Write</code> (although they were probably <code>Reader</code>
and <code>Writer</code> at that point).</p>
<p>Focusing on the former, before object safety it was defined
something<sup class="footnote-reference"><a href="print.html#associated-type">8</a></sup> like:</p>
<div class="footnote-definition" id="associated-type"><sup class="footnote-definition-label">8</sup>
<p>I'm using an associated type for <code>Item</code> here, but
I believe it was probably still a generic
parameter <code>trait Iterator&lt;Item&gt; { ...</code> at this
point, and the <code>IntoIterator</code> trait didn't
exist. However it doesn't matter: the exact same
problems existed, just with different syntax.</p>
<pre><code class="language-rust ignore">trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { /* ... */ }

    // ... methods methods methods ...

    fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, U::IntoIter&gt;
        where U: IntoIterator
    { /* ... */ }

    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
        where F: FnMut(Self::Item) -&gt; B
    { /* ... */ }

    // etc
}
</code></pre>
<p>The above <code>Iterator</code> isn't object safe: it has generic methods, and so
it isn't possible to implement <code>Iterator</code> for <code>Iterator</code> itself. This
is unfortunate, since it is very useful to be able to create and use
<code>Iterator</code> trait objects, so it <em>had</em> to be made object safe.</p>
<p>The solution at the time was extension traits: define a new trait
<code>IteratorExt</code> that incorporated all the object unsafe methods, and use
a blanket implementation to implement it for all <code>Iterator</code>s &quot;from the
outside&quot;.</p>
<pre><code class="language-rust ignore">trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { /* ... */ }
}

trait IteratorExt: Sized + Iterator {
    // ... methods methods methods ...

    fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, U::IntoIter&gt;
        where U: IntoIterator
    { /* ... */ }

    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
        where F: FnMut(Self::Item) -&gt; B
    { /* ... */ }

    // etc
}
// blanket impl, for all iterators
impl&lt;I: Iterator&gt; IteratorExt for I {}
</code></pre>
<p>The <code>next</code> and <code>size_hint</code> methods are object safe, so this version of
<code>Iterator</code> can create trait objects: <code>Box&lt;Iterator&lt;Item = u8&gt;&gt;</code> is a
legal iterator over bytes. It works because the methods of
<code>IteratorExt</code> are no longer part of <code>Iterator</code> and so they're not
involved in any object considerations for it.</p>
<p>Fortunately, those methods aren't lost on trait objects, because there
are implementations like the following, allowing the blanket
implementation of <code>IteratorExt</code> to kick in:</p>
<pre><code class="language-rust ignore">// make Box&lt;...&gt; an Iterator by deferring to the contents
impl&lt;I: Iterator + ?Sized&gt; Iterator for Box&lt;I&gt; {
    type Item = I::Item;

    fn next(&amp;mut self) -&gt; Option&lt;I::Item&gt; {
        (**self).next()
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        (**self).size_hint()
    }
}
</code></pre>
<div class="join"></div>
<p>(The <code>?Sized</code> ensures this applies to <code>Box&lt;Iterator&lt;...&gt;&gt;</code> trait
objects as well as simply <code>Box&lt;SomeType&gt;</code> where <code>SomeType</code> is a normal
type that implements <code>Iterator</code>.)</p>
<p>This approach has some benefits, like clarifying the separation
between the &quot;core&quot; methods (<code>next</code> and <code>size_hint</code>) and the
helpers. However, it has several downsides, especially for cases that
aren't <code>Iterator</code>:</p>
<ul>
<li>extra traits in the documentation,</li>
<li>users will have to import those extra traits</li>
<li>it only works with default-able methods,</li>
<li>the defaults can't be overridden, e.g. there's no way for a specific
type to slot in a more efficient way to implement a method</li>
</ul>
<p>All-in-all, it was a wet blanket on libraries. Fortunately, not all
was lost: let's meet our saviour.</p>
<a class="header" href="print.html#its-a-bird-its-a-plane" id="its-a-bird-its-a-plane"><h2>It's a bird... it's a plane...</h2></a>
<p>It's a <a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md"><code>where</code> clause</a>!</p>
<p><code>where</code> clauses allow predicating functions/methods/types on
essentially arbitrary trait relationships, not just the plain <code>&lt;T: SomeTrait&gt;</code>, where the left-hand side has to be a generic type
declared right then and there. For example, one can use
<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> to
convert <em>to</em> types with a <code>where</code> clause.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn convert_to_string&lt;T&gt;(x: T) -&gt; String
    where String: From&lt;T&gt;
{
    String::from(x)
}

#}</code></pre></pre>
<p>The important realisation was that <code>where</code> allows placing restrictions
on <code>Self</code> directly on methods, so that certain methods only exist for
some implementing types. This was used to great effect to collapse
piles of traits into a single one, for example in <code>std::iter</code>.
<a href="http://doc.rust-lang.org/0.12.0/std/iter/#traits">Rust 0.12.0 had</a> a
swathe of extra <code>Iterator</code> traits: <code>Additive...</code>, <code>Cloneable...</code>,
<code>Multiplicative...</code>, <code>MutableDoubleEnded...</code>, <code>Ord...</code>.</p>
<p>Each of these were designed to define a few extra methods that
required specific restrictions on the element type of the iterator,
for example, <code>OrdIterator</code> needed <code>Ord</code> elements:</p>
<pre><code class="language-rust ignore">trait OrdIterator: Iterator {
     fn max(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
     // ...
}

impl&lt;A: Ord, I: Iterator&lt;Item = A&gt;&gt; OrdIterator for I {
    fn max(&amp;mut self) -&gt; Option&lt;A&gt; { /* ... */ }

    // ...
}
</code></pre>
<p>The <a href="http://doc.rust-lang.org/std/iter">current <code>std::iter</code></a> is much
cleaner: all the traits above have been merged into <code>Iterator</code> itself
with <code>where</code> clauses, e.g.
<a href="http://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html#method.max"><code>max</code></a>:</p>
<pre><code class="language-rust ignore">trait Iterator {
    type Item;

    // ...

    fn max(self) -&gt; Option&lt;Self::Item&gt;
        where Self::Item: Ord
    { /* ... */ }

    // ...
}
</code></pre>
<p>Notably, there's no restriction on <code>Item</code> for general <code>Iterator</code>s,
only on <code>max</code>, so iterators retain full flexibility while still
gaining a <code>max</code> method that only works when it should:</p>
<pre><code class="language-rust ignore">struct NotOrd;

fn main() {
    (0..10).max(); // ok
    (0..10).map(|_| NotOrd).max();
}
</code></pre>
<pre><code class="language-text">...:5:29: 5:34 error: the trait `core::cmp::Ord` is not implemented for the type `NotOrd` [E0277]
...:5     (0..10).map(|_| NotOrd).max();
</code></pre>
<p>This approach works fine for normal traits like <code>Ord</code>, and also works
equally well for &quot;special&quot; traits like <code>Sized</code>:
<a href="http://stackoverflow.com/a/27820018/1256624">it is possible</a> to
restrict methods to only work when <code>Self</code> has a statically known size
with <code>where Self: Sized</code>. Initially this had no interaction with
object safety, it would just influence what exactly that method could
do.</p>
<a class="header" href="print.html#putting-it-together" id="putting-it-together"><h2>Putting it together</h2></a>
<p>The piece that interacts with object safety is <a href="https://github.com/rust-lang/rfcs/pull/817">RFC 817</a>, which
made <code>where Self: Sized</code> special: the compiler now understands that
methods tagged with that cannot ever be used on a trait object, even
in generic code.  This means it is perfectly correct to completely
ignores any methods with that <code>where</code> clause when checking object
safety.</p>
<p>The bad example from the start can be written to compile:</p>
<pre><code class="language-rust ignore">trait Bar {
    fn bad&lt;T&gt;(&amp;self, x: T)
        where Self: Sized;
}

impl Bar for u8 {
    fn bad&lt;T&gt;(&amp;self, _: T)
        where Self: Sized
    {}
}

fn main() {
    &amp;1_u8 as &amp;Bar;
}
</code></pre>
<div class="join"></div>
<p>And also adjusted to not compile: try calling <code>(&amp;1_u8 as &amp;Bar).bad(&quot;foo&quot;)</code> in <code>main</code> and the compiler spits out an error,</p>
<pre><code class="language-text">...:13:21: 13:31 error: the trait `core::marker::Sized` is not implemented for the type `Bar` [E0277]
...:13     (&amp;1_u8 as &amp;Bar).bad(&quot;foo&quot;)
                           ^~~~~~~~~~
...:13:21: 13:31 note: `Bar` does not have a constant size known at compile-time
...:13     (&amp;1_u8 as &amp;Bar).bad(&quot;foo&quot;)
                           ^~~~~~~~~~
</code></pre>
<p>Importantly, this solves the <code>Iterator</code> problem: there's no longer a
need to split methods into extension traits to ensure object safety,
one can instead just guard the bad ones. <code>Iterator</code> now looks like:</p>
<pre><code class="language-rust ignore">trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { /* ... */ }

    // ... methods methods methods ...

    fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, U::IntoIter&gt;
        where Self: Sized, U: IntoIterator
    { /* ... */ }

    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
        where Self: Sized, F: FnMut(Self::Item) -&gt; B
    { /* ... */ }

    // etc
}
</code></pre>
<div class="join"></div>
<p>(Along with <code>max</code> and the other <code>where</code>-reliant methods from the other
<code>*Iterator</code> traits mentioned above.)</p>
<p>The extra flexibility this <code>where</code> clauses offer is immensely helpful
for designing that perfect API.  Of course, just adding <code>where Self: Sized</code> isn't a complete solution or the only trick: the current
<code>Iterator</code> still has the same sort of implementations of <code>Iterator</code>
for <code>Box&lt;I&gt;</code> where <code>I: Iterator + ?Sized</code>, and traits using the
<code>where</code> technique may want to adopt others that <code>Iterator</code> does.</p>
<blockquote>
<p><a href="https://huonw.github.io/blog/2015/01/peeking-inside-trait-objects/"><em>Originally published 2015-01-10</em></a>,
<a href="https://huonw.github.io/blog/2015/01/the-sized-trait/">2015-01-12</a>,
<a href="https://huonw.github.io/blog/2015/01/object-safety/">2015-01-13</a>, and
<a href="https://huonw.github.io/blog/2015/05/where-self-meets-sized-revisiting-object-safety/">2015-05-06</a>.</p>
<p><em>License: TBD</em></p>
</blockquote>
</div>
<p>% The Many Kinds of Code Reuse in Rust</p>
<p>(This article is written against Rust 1.7 stable)</p>
<p>Rust has a lot of <em>stuff</em> in its type system. As far as I'm concerned, almost
all of the complexity is dedicated to expressing programs generically. And people
are still clamouring for more! I always have trouble getting the most advanced
parts straight, so this post is basically a &quot;note to self&quot;. That said, I like
making things that are useful to other people, so this will also cover some
things which I probably won't forget, but other people might not know.</p>
<p>This post will <em>not</em> exhaustively cover syntax or all the details of the features
described. This is mostly focused on <em>why</em> things are the way they are, because
that's the part I always forget. If you want to actually learn Rust properly,
you should probably read The Book. That said, I <em>will</em> randomly fixate on some
of my favorite aspects of these systems.</p>
<p>This post also likely makes many errors, and should not be considered an
official piece of reference material. It's just what I was able to knock out
over a week before I started a new job.</p>
<a class="header" href="print.html#a-brief-review-of-code-reuse" id="a-brief-review-of-code-reuse"><h1>A Brief Review of Code Reuse</h1></a>
<p>The desire to take some piece of code and use it more than once has existed
since our computational ancestors carved the first bits from rocks to hunt
mammoths. Clearly, from this description I have no idea what code reuse looked
like in the earliest days of programming. Cheat sheets? Vacuum tube modules?
Punch card stencils? I dunno, I'm not a histogram. I'm more interested in how
things are done today.</p>
<p>The most common form of a code-reuse is, of course, functions. Sure, great,
everyone likes functions. Depending on what language you're in, and what you're
doing, functions may or may not be the start and the end of the code-reuse
story for you. In other cases, they might not be enough. You might want to do
things that are known by various overloaded terms, like &quot;meta-programming&quot;
(describing code itself) or &quot;polymorphism&quot; (writing code that can handle
different kinds of data).</p>
<p>Technically, these are orthogonal concerns, but they get conflated pretty frequently. Lots of
features in different languages hook into all this: macros, templates, generics,
inheritance, function pointers, interfaces, overloading, unions, and so on.
But all these concepts are just fiddling with the semantics. Really, it's all
going to boil down to three major strategies:
monomorphization, virtualization, and enumeration.</p>
<a class="header" href="print.html#monomorphization" id="monomorphization"><h2>Monomorphization</h2></a>
<p>Monomorphization is the practice of basically copy-pasting code over
and over again, with details changed. The main benefit of monomorphization is
that you can get a &quot;perfect&quot; custom implementation, with nothing weird for your
compiler to try to undo. This is its own weakness, though. In the worst case, the
final binary will contain a distinct copy of a monomorphic interface for every
place it's used. This may just mean large binaries and large compile times, but
it can also mean horrible use of your processor's instruction cache. As far as
it's concerned, there's no code reuse at all! Just piles and piles of code.</p>
<p>The semantic limitation of monomorphization is that it can't be (directly) used
to process multiple distinct things homogeneously. For instance, say I want to
build a job queue that receives tasks, and then executes them in order. If I
want all the tasks to be exactly the same, then monomorphization work fine. But
if I want a single queue to be able to handle different tasks, then it's not
clear how that could be done with monomorphization alone. That's why it's <em>called</em>
&quot;mono&quot;morphization. It's all about taking abstract implementations and creating
instances that do <em>one</em> thing.</p>
<p>Some common examples of monomorphization: text substitution, C++ templates,
C macros, Go Generate, and C# generics. Most of these are done completely at
compile-time, but C# actually monomorphizes something like <code>List&lt;T&gt;</code> on demand
at runtime. All that's created at compile-time is a template. Monomorphization
is also an incredibly popular compiler/JIT optimization. Inlining and specializing
code is, after all, just monomorphizing it!</p>
<a class="header" href="print.html#virtualization" id="virtualization"><h2>Virtualization</h2></a>
<p>Virtualization is monomorphization's natural opposite, leveraging the solution
every programmer comes to after copy-pasting code: adding more indirection.
Both data and functionality can be virtualized, in which case all the user of
a virtualized interface sees are pointers to <em>something</em>.</p>
<p>Virtualizing data allows code to handle types with different sizes and layouts
uniformly. Virtualizing functions allows a single function to have custom behaviour,
without having to copy-paste it. The dynamic job queue example that monomorphization
struggled with is handily solved by virtualization. Each task to perform can simply
be a function pointer, which the queue will follow and execute. If you need to
associate data with each task, you can also pass a pointer to data, which the
queue can pass along to the function to interpret appropriately.</p>
<p>Virtualization's primary downside is that it's <em>usually</em> worse for performance
to add lots of indirection. Particularly because it often implies doing more
heap allocation, jumping to random places in memory (bad for all caches),
and determining what the heck the thing we're working with is.</p>
<p>However virtualization <em>can</em> be more efficient than monomorphization! Whenever
a function is statically invoked (and we aren't doing recursion), a compiler
<em>could</em> inline that function call, but they won't always. This is because,
as I mentioned, too much monomorphization makes programs bloated and slow.
For similar reasons, it can be beneficial to <em>outline</em> code that is rarely
invoked. For instance, error handling code is presumably unlikely to be executed,
so virtualizing that code just leaves more room for the common path in the
instruction cache.</p>
<p>Some common examples of virtualization: function pointers and void pointers in C,
callbacks, inheritance (Java, C++, C#), generics in Java, and prototypes in
JavaScript. Note that in many of these examples, virtualization of functionality
and data is combined. Inheritance in particular often results in virtualization
of both code and data. For instance, if I have a pointer to an Animal, it might
might actually be a Cat or a Dog. If I ask the animal to <code>speak</code>, how does it know
to &quot;bark&quot; or &quot;meow&quot;?</p>
<p>The standard way to handle this is for <em>every single
instance</em> of a type in an inheritance hierarchy to secretly store a pointer
to various pieces of information that may be needed at runtime, called a &quot;vtable&quot;.
The standard thing for a vtable to store would be a bunch of function pointers
(one of which would be this instance's implementation of <code>speak</code>),
but it might also store things like size, alignment, and the actual type.</p>
<a class="header" href="print.html#enumeration" id="enumeration"><h2>Enumeration</h2></a>
<p>Enumerations are a compromise between virtualization and monomorphization.
At runtime monomorphization can only be one thing, while virtualizations can
be anything. Enumerations, on the other hand, can be anything <em>from a fixed list</em>.
The usual strategy is just to pass around an integer &quot;tag&quot; which specifies which
implementation is supposed to be used.</p>
<p>For instance, a job queue using enumeration might define three kinds of task
it can perform: &quot;Create&quot;, &quot;Update&quot;, and &quot;Delete&quot;. Someone who wants to perform
a Create task simply bundles up all the data expected for Create, along with the
appropriate tag. The queue then checks the tag, reinterprets the data to be
the kind associated with Create, and executes its logic for creation.</p>
<p>Like code that uses virtualization, enumerated code can handle multiple types
at once, and there's no need to create a new copy of the code for each type.
Like monomorphized code, there's no need for indirection; the only runtime
aspect is checking the value of the tag. This can make it easier for an optimizer
to reason about enums.</p>
<p>Although it should be noted that if indirection <em>isn't</em> used, then an enumerated
type can become really big, because every instance needs to have space for
the largest type it <em>could</em> be. For instance, Delete may only require a name,
but Create may require a name, author, content, and so on. Even if the queue
is mostly storing Delete commands, it will use up the space of a queue full of
Create commands.</p>
<p>Of course, the biggest limitation of all is that you need to know the full
set of choices upfront. Both virtualization and monomorphization can be used
with interfaces that are &quot;open&quot; to extension. Anyone can extend a class, and
any type can be provided to a template, but enumeration is &quot;closed&quot; to extension.
The set of implementations is set in stone when it is declared. Adding or removing
elements from this set will likely break consumers of an enumeration!</p>
<p>Because of this, this strategy is relatively obscure. Many languages provide a
notion of an enumeration as an <code>enum</code>, but often lack support for those enums
having associated data, which limits their usefulness. C provides the ability
to declare that a field is the union of two types, but leaves it up to the
programmer to determine which type the field should be interpreted as. Many functional
languages provide tagged unions, which are the combination of an enum and a C union,
allowing arbitrary data to be associated with each variant of an enum.</p>
<a class="header" href="print.html#back-to-rust" id="back-to-rust"><h1>Back to Rust</h1></a>
<p>Alright, so those are the major code reuse strategies as seen in <em>other</em>
languages. What's Rust got? Rust's story is split up into three major pillars:</p>
<ul>
<li>Macros (simple monomorphization!)</li>
<li>Enums (full enumeration!)</li>
<li>Traits (where the complexity is)</li>
</ul>
<a class="header" href="print.html#macros" id="macros"><h1>Macros</h1></a>
<p>Macros are the easiest. They're pure, raw, code reuse. In Rust they generally
work on parts of the AST (Abstract Syntax Tree; chunks of source code).
You give them some bits of AST, and it spews out some new bits of AST at
compile time. There's no type information beyond stuff like &quot;this string looked
like a type name&quot;.</p>
<p>There's basically two reasons to use macros: you want to extend the language,
or you want to copy-paste some code with minor tweaks. The standard library
<a href="https://github.com/rust-lang/rust/blob/7bcced73b77ba56834c3b5da0c4f82f80aa74db8/src/libcollections/macros.rs#L11-L52">exports a few examples of the former</a> (<code>println!</code>, <code>thread_local!</code>,
<code>vec!</code>, <code>try</code>, etc):</p>
<pre><code class="language-rust ignore">/// Creates a `Vec` containing the arguments.
///
/// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.
/// There are two forms of this macro:
///
/// - Create a `Vec` containing a given list of elements:
///
/// ```
/// let v = vec![1, 2, 3];
/// assert_eq!(v[0], 1);
/// assert_eq!(v[1], 2);
/// assert_eq!(v[2], 3);
/// ```
///
/// - Create a `Vec` from a given element and size:
///
/// ```
/// let v = vec![1; 3];
/// assert_eq!(v, [1, 1, 1]);
/// ```
///
/// Note that unlike array expressions this syntax supports all elements
/// which implement `Clone` and the number of elements doesn't have to be
/// a constant.
///
/// This will use `clone()` to duplicate an expression, so one should be careful
/// using this with types having a nonstandard `Clone` implementation. For
/// example, `vec![Rc::new(1); 5]` will create a vector of five references
/// to the same boxed integer value, not five references pointing to independently
/// boxed integers.
#[cfg(not(test))]
#[macro_export]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
macro_rules! vec {
    ($elem:expr; $n:expr) =&gt; (
        $crate::vec::from_elem($elem, $n)
    );
    ($($x:expr),*) =&gt; (
        &lt;[_]&gt;::into_vec($crate::boxed::Box::new([$($x),*]))
    );
    ($($x:expr,)*) =&gt; (vec![$($x),*])
}
</code></pre>
<p>and internally <a href="https://github.com/rust-lang/rust/blob/7bcced73b77ba56834c3b5da0c4f82f80aa74db8/src/libcore/num/mod.rs#L2428-L2488">makes good use of the latter</a>
when implementing lots of repetitive interfaces (primitives, tuples, and arrays
are common offenders):</p>
<pre><code class="language-rust ignore">// Conversion traits for primitive integer and float types
// Conversions T -&gt; T are covered by a blanket impl and therefore excluded
// Some conversions from and to usize/isize are not implemented due to portability concerns
macro_rules! impl_from {
    ($Small: ty, $Large: ty) =&gt; {
        impl From&lt;$Small&gt; for $Large {
            fn from(small: $Small) -&gt; $Large {
                small as $Large
            }
        }
    }
}

// Unsigned -&gt; Unsigned
impl_from! { u8, u16 }
impl_from! { u8, u32 }
impl_from! { u8, u64 }

// this goes on for literally 40 more impls...
</code></pre>
<p>As far as I'm concerned, macros are basically the worst game in town. They sorta
try to be helpful (variable names don't leak into or out of the macro), but
fall over in lots of places (using unsafe code inside a macro does weird
things to the outside). Macros are basically regexes (ignoring that <code>expr</code> and <code>tt</code>
aren't at all regular to parse); no one likes reading regexes!</p>
<p>Most critically to me, though, is that macros are basically dynamically typed
metaprogramming. The compiler can't evaluate the the body of a macro matches its
signature, and that the macro is being invoked correctly for its signature. It
just has to expand the macro out to some code and then check that code. This
leads to the standard problem with dynamic programming: late binding of errors.
With macros, we can get the spiritual equivalent of &quot;undefined in not a function&quot;
in the compiler.</p>
<pre><code class="language-rust ignore">macro_rules! make_struct {
    (name: ident) =&gt; {
        struct name {
            field: u32,
        }
    }
}


make_struct! { Foo }
</code></pre>
<pre><code class="language-text">&lt;anon&gt;:10:16: 10:19 error: no rules expected the token `Foo`
&lt;anon&gt;:10 make_struct! { Foo }
                         ^~~
playpen: application terminated with error code 101
</code></pre>
<p>What's the error here? Well obviously I left off the <code>$</code> on name, so this
macro actually always expects to be invoked as literally <code>make_struct! { name: ident }</code>,
and always produces literally <code>struct name { field: u32 }</code>.</p>
<p>Further, when a &quot;normal&quot; Rust error happens to occur in the expansion of a macro,
the resulting output is a mess!</p>
<pre><code class="language-ignore">use std::fs::File;

fn main() {
    let x = try!(File::open(&quot;Hello&quot;));
}
</code></pre>
<pre><code class="language-text">&lt;std macros&gt;:5:8: 6:42 error: mismatched types:
 expected `()`,
    found `core::result::Result&lt;_, _&gt;`
(expected (),
    found enum `core::result::Result`) [E0308]
&lt;std macros&gt;:5 return $ crate:: result:: Result:: Err (
&lt;std macros&gt;:6 $ crate:: convert:: From:: from ( err ) ) } } )
&lt;anon&gt;:4:13: 4:38 note: in this expansion of try! (defined in &lt;std macros&gt;)
&lt;std macros&gt;:5:8: 6:42 help: see the detailed explanation for E0308
</code></pre>
<p>The upside of this mess is the usual upside for dynamic typing: way more flexibility.
Macros are a godsend where we use them, they're just... fragile.</p>
<a class="header" href="print.html#an-honorable-mention-syntax-extensions-and-code-generation" id="an-honorable-mention-syntax-extensions-and-code-generation"><h2>An Honorable Mention: Syntax Extensions and Code Generation</h2></a>
<p>Macros have limits. They can't execute arbitrary code at compile time.
This is a good thing for security and repeatable builds, but sometimes it's
not enough. There are two ways to deal with this in Rust: syntax extensions
(AKA &quot;procedural macros&quot;), and code generation (AKA build.rs).
Both of these basically give you carte-blanche to execute arbitrary code
to generate source code.</p>
<p>Syntax extensions look like macros or annotations, but they cause the
compiler to execute custom code to (ideally) modify the AST.
<code>build.rs</code> files are a file that Cargo will compile and execute whenever
a crate is built. Obviously, this lets them do anything they please to the
project. Hopefully they'll just add some nice source code.</p>
<p>I could give examples or elaborate, but I don't really know much about these
options or care about them. It's code generation, what's there to say?
Also, I've been writing this article for days and it's SO LONG AND I WANT TO BE DONE.</p>
<a class="header" href="print.html#enums" id="enums"><h1>Enums</h1></a>
<p>Enums in Rust are exactly the tagged unions we described earlier.</p>
<p>The most common enums you'll interact with in Rust are Option and Result, which
generally express success/failure. In other words, they let us write code that
uniformly manipulates success and failure.</p>
<p>What about your own custom enums? Let's say you're writing some networking code.
For whatever reason you want this code to be generic over IPv4 and IPv6. You are
absolutely certain that you don't care about the possibility of some hypothetical
IPv8, and honestly you don't have a clue how to define an interface that would
handle that anyway. One way to be generic over IPv4 and IPv6 is to define an enum:</p>
<pre><code class="language-rust ignore">enum IpAddress {
    V4(IPv4Address),
    V6(Ipv6Address),
}

fn connect(addr: IpAddress) {
    // Check which version it was, and choose the right impl
    match addr {
        V4(ip) =&gt; connect_v4(ip),
        V6(ip) =&gt; connect_v6(ip),
    }
}
</code></pre>
<p>That's it. Now you can write all sorts of code that just passes around generic
<code>IpAddress</code>es, and whenever someone needs to actually care about what version is
being used, they can <code>match</code> on the value and extract the contents.</p>
<a class="header" href="print.html#traits-2" id="traits-2"><h1>Traits</h1></a>
<p>Alright, that's the easy stuff out of the way. Now onto The Hard Stuff. Traits
are Rust's answer to <em>everything</em> else. Monomorphization, virtualization,
reflection, operator overloading, type conversions, copy semantics, thread safety,
higher order functions, and bloody <em>for loops</em> all pipe through traits. In due
time, traits will also be the center piece for specialization and probably
every other big new user-facing feature added to Rust.</p>
<p>All that said, traits are just interfaces. That's it.</p>
<pre><pre class="playpen"><code class="language-rust">struct MyType {
    data: u32,
}

// Defining an interface
trait MyTrait {
    fn foo(&amp;self) -&gt; u32;
}

// Implementing an interface
impl MyTrait for MyType {
    fn foo(&amp;self) -&gt; u32 {
        self.data
    }
}

fn main() {
    let mine = MyType { data: 0 };
    println!(&quot;{}&quot;, mine.foo());
}
</code></pre></pre>
<p>For the most part, you can just think of traits as interfaces in Java or C#, but there's
some slight differences. In particular, traits are designed to be more flexible. In C# and
Java, as far as I know, the only one who can implement <code>MyTrait</code> for <code>MyType</code>
is the declarer of <code>MyType</code>. But in Rust, the declarer of <code>MyTrait</code> can <em>also</em>
implement it for MyType. This lets a downstream library or application define interfaces
and have them implemented by types declared in e.g. the standard library.</p>
<p>Of course, letting this go completely unchecked would be chaos. People could
inject functions onto arbitrary types! To keep the chaos under control, trait
implementations are only visible to code that has the relevant trait in scope.
This is why doing I/O without importing the Read and Write traits often falls
apart.</p>
<a class="header" href="print.html#aside-coherence" id="aside-coherence"><h1>Aside: Coherence</h1></a>
<p>Those familiar with Haskell may recognize traits to be quite similar to Haskell's <em>type classes</em>.
Those same people may then raise the (incredibly reasonable) question: what happens if there are
multiple implementations of the same trait for the same type? This is the coherence
problem. In a coherent world, everything only has one implementation. I don't want
to get into coherence, but the long and the short of it is that Rust has more
restrictions in place to avoid the problems Haskell has with coherence.</p>
<p>The bulk of these restrictions are: you need to either be declaring the trait
or declaring the type to <code>impl Trait for Type</code>, and crates can't circularly
depend on each-other (dependencies must form a DAG). The messy case is that this
is actually a lie, and you can do things like <code>impl Trait for Box&lt;MyType&gt;</code>, even
though Trait and Box are declared elsewhere. Most of the complexity in coherence,
to my knowledge, is dealing with these special cases. The rules that govern this
are the &quot;orphan rules&quot;, which basically ensure that, for any web of dependencies,
there's a <em>single</em> crate which can declare a particular <code>impl Trait for ...</code>.</p>
<p>The result is
that it's impossible for two separate libraries to compile but introduce a conflict
when imported at the same time. That said, the restrictions imposed by coherence
can be <em>really annoying</em>, and sometimes I curse Niko Matsakis' name.</p>
<p>The standard library (which is secretly several disjoint libraries stitched together)
is constantly on the cusp of breaking in half because of coherence. There's several
implementations that are conspicuously missing, and several types and traits that
are defined in weird places, precisely because of coherence. Also that wasn't even
sufficient and a special hack had to be added to the compiler called <code>#[fundamental]</code>
which declares that certain things have special coherence rules.</p>
<p>Coherence is really important.</p>
<p>I really hate coherence.</p>
<p>Specialization might make it better.</p>
<p>I should probably explain the orphan rules properly.</p>
<p>I'm not going to.</p>
<a class="header" href="print.html#generics" id="generics"><h1>Generics</h1></a>
<p>So how do we actually use traits for reuse? Well, Rust actually
let's us decide! We can either use virtualization or monomorphization. Monomorphization
is <em>overwhelmingly</em> the choice in Rust's standard library, and in most Rust code I've
seen. This is because monomorphization is <em>probably</em> the more efficient thing on
average, and it's also strictly more general in Rust. That is, a monomorphic interface
can be converted into a virtualized one by the user. We'll see that in a bit.</p>
<p>Declaring a monomorphic interface is done with what Rust calls generics:</p>
<pre><code class="language-rust ignore">// Plain struct, for comparison purposes.
struct Concrete {
    data: u32,
}

// A generic struct. `&lt;..&gt;` is how we declare generic arguments.
// One can create a version of `Generic` for any type, unlike
// `Concrete`, which only works with `u32`.
struct Generic&lt;T&gt; {
    data: T,
}


// Plain impl
impl Concrete {
    fn new(data: u32) -&gt; Concrete {
        Concrete { data: data }
    }

    fn is_big(&amp;self) -&gt; bool {
        self.data &gt; 120
    }
}

// Implementing functionality for a specific
// version of Foo. Note that this is *not*
// &quot;specialization&quot;, in the sense that any names
// declared here can't conflict with other impls.
impl Generic&lt;u32&gt; {
    fn is_big(&amp;self) -&gt; bool {
        self.data &gt; 120
    }
}


// Implementing functionality for all choices of T.
// Note that the &quot;impl&quot; is also Generic here.
// Hopefully this in conjunction with the previous
// example demonstrates why the extra &lt;T&gt; is necessary.
impl&lt;T&gt; Generic&lt;T&gt; {
    fn new(data: T) -&gt; Generic&lt;T&gt; {
        Generic { data: data }
    }

    fn get(&amp;self) -&gt; &amp;T {
        &amp;self.data
    }
}




// A normal trait declaration.
trait Clone {
    fn clone(&amp;self) -&gt; Self;
}

// A generic trait declaration.
// Generic traits introduce a relationship to some
// other type. In this case, we want to be able to
// compare our type to *other* types. This will
// be clearer when we see impls.
trait Equal&lt;T&gt; {
    fn equal(&amp;self, other: &amp;T) -&gt; bool;
}



// Plain-jane trait impl
impl Clone for Concrete {
    fn clone(&amp;self) -&gt; Self {
        Concrete { data: self.data }
    }
}

// Implementing a generic trait concretely
impl Equal&lt;Concrete&gt; for Concrete {
    fn equal(&amp;self, other: &amp;Concrete) -&gt; bool {
        self.data == other.data
    }
}

// Oh hey, we can do this for types we don't own, like primitives!
impl Clone for u32 {
    fn clone(&amp;self) -&gt; Self {
        *self
    }
}

impl Equal&lt;u32&gt; for u32 {
    fn equal(&amp;self, other: &amp;u32) -&gt; Self {
        *self == *other
    }
}

// Taking advantage of that sweet generic trait!
impl Equal&lt;i32&gt; for u32 {
    fn equal(&amp;self, other: &amp;i32) -&gt; Self {
        if *other &lt; 0 {
            false
        } else {
            *self == *other as u32
        }
    }
}


// Implementing a generic trait for a concrete type generically
impl&lt;T: Equal&lt;u32&gt;&gt; Equal&lt;T&gt; for Concrete {
    fn equal(&amp;self, other: &amp;T) -&gt; bool {
        other.equal(&amp;self.data)
    }
}

// Implementing a concrete trait for a generic type generically.
// Note that we require that `T` implements the
// `Clone` trait! This is a *trait bound*.
impl&lt;T: Clone&gt; Clone for Generic&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Generic { data: self.data.clone() }
    }
}

// Implementing a generic trait for a generic type generically.
// Note that we have two generic types in play; T and U.
impl&lt;T: Equal&lt;U&gt;, U&gt; Equal&lt;Generic&lt;U&gt;&gt; for Generic&lt;T&gt; {
    fn equal(&amp;self, other: &amp;Generic&lt;U&gt;) -&gt; bool {
       self.equal(&amp;other.data)
    }
}



// And finally, individual functions can also be generic.
impl Concrete {
    fn my_equal&lt;T: Equal&lt;u32&gt;&gt;(&amp;self, other: &amp;T) -&gt; bool {
        other.equal(&amp;self.data)
    }
}

impl&lt;T&gt; Generic&lt;T&gt; {
    // Interesting problem: we've inverted the order on `equal` here
    // (`x == y` is being evaluated as `y == x`). How can we express
    // `T: Equal&lt;U&gt;` to fix this? Note that we can't do this at the
    // time where we declare `T`, because `U` doesn't exist yet!
    // More on this later!
    fn my_equal&lt;U: Equal&lt;T&gt;&gt;(&amp;self, other: &amp;Generic&lt;U&gt;) -&gt; bool {
       other.data.equal(&amp;self.data)
    }
}
</code></pre>
<p><em>phew</em></p>
<p>So we can see that there's a <em>lot</em> of combinations of situations
you can run into as soon as you want to start describing interfaces
and providing implementations that are generic over those interfaces.
As I mentioned, anything that tries to use any of these structures
and implementations will be monomorphized.</p>
<p>So, at least before optimization passes kick in, the following code
will be expanded as follows:</p>
<pre><code class="language-rust ignore">// Before
struct Generic&lt;T&gt; { data: T }
impl&lt;T&gt; Generic&lt;T&gt; {
    fn new(data: T) {
        Generic { data: data }
    }
}

fn main() {
    let thing1 = Generic::new(0u32);
    let thing2 = Generic::new(0i32);
}
</code></pre>
<pre><code class="language-rust ignore">// After
struct Generic_u32 { data: u32 }
impl Generic_u32 {
    fn new(data: u32) {
        Generic { data: data }
    }
}

struct Generic_i32 { data: i32 }
impl Generic_i32 {
    fn new(data: i32) {
        Generic { data: data }
    }
}


fn main() {
    let thing1 = Generic_u32::new(0u32);
    let thing2 = Generic_i32::new(0i32);
}
</code></pre>
<p>It may or may not surprise you to learn that some really common functions
get copied <em>a lot</em>. For instance, brson measured that 1700 copies of
<code>Option&lt;T&gt;::map</code> <a href="https://gist.github.com/brson/18a1517e9b747a09c492">were being created while building Servo</a>.
Granted, virtualizing all those calls probably would have been disastrous for
runtime performance.</p>
<a class="header" href="print.html#aside-generic-inference-and-the-turbofish" id="aside-generic-inference-and-the-turbofish"><h1>Aside: Generic Inference and The Turbofish</h1></a>
<p>Generics in Rust are inferred. This is really nice when it works out,
but it can also let us express some very strange things.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Vec::new() is a generic function, whose output type
// is inferred based on usage. It's definitely some kind of
// `Vec`, but what type of value it stores is ambiguous.
let mut x = Vec::new();

// Inserting a `u8` into the `x` solidifies its type to `Vec&lt;T&gt;`
x.push(0u8);
x.push(10);
x.push(20);

// `collect` is a generic function. It can produce anything that
// implements `FromIterator`, usually a collection like Vec or VecDeque.
// It's often completely ambiguous what the result of `collect` should
// be, because unlike `Vec::new()`, this function can really produce
// just about anything.

// To deal with this, we can specify the type of y explicitly.
let y: Vec&lt;u8&gt; = x.clone().into_iter().collect();

// Or directly tell collect what its generic arguments should be
// with the turbofish operator `::&lt;&gt;`!
let y = x.clone().into_iter().collect::&lt;Vec&lt;u8&gt;&gt;();

#}</code></pre></pre>
<a class="header" href="print.html#trait-objects-1" id="trait-objects-1"><h1>Trait Objects</h1></a>
<p>So how do we do virtualization? How do we erase a type to just be &quot;something&quot;?
Rust's solution to this is called <em>trait objects</em>. All you do is specify that
the type of something <em>is</em> some trait, and Rust will handle the rest. Of course,
in order to do this, you need to put your type behind a pointer like <code>&amp;</code>, <code>&amp;mut</code>
<code>Box</code>, <code>Rc</code>, or <code>Arc</code>.</p>
<pre><pre class="playpen"><code class="language-rust">trait Print {
    fn print(&amp;self);
}

impl Print for i32 {
    fn print(&amp;self) { println!(&quot;{}&quot;, self); }
}

impl Print for i64 {
    fn print(&amp;self) { println!(&quot;{}&quot;, self); }
}

fn main() {
    // Normal static, monomorphized usage
    let x = 0i32;
    let y = 10i64;
    x.print();      // 0
    y.print();      // 10

    // Box&lt;Print&gt; is a trait object, and therefore can store any
    // implementor of Print. To create a Box&lt;Print&gt;, we just create
    // a `Box&lt;T: Print&gt;`, and try to put it somewhere that expects
    // a `Box&lt;Print&gt;`. Here we specify that `data` contains `Box&lt;Print&gt;`s,
    // so the array literal happily does the coercion for us!
    // Note that we use this to insert an i32 and an i64 into the same
    // list, which would be prevented if we used static dispatch.
    let data: [Box&lt;Print&gt;; 2] = [Box::new(20i32), Box::new(30i64)];

    // Now we can print all the data in this list uniformly.
    for val in &amp;data {
        val.print();    // 20, 30
    }
}
</code></pre></pre>
<p>Note that the requirement that things are behind pointers is more pervasive than
you might think. For instance, consider the <code>Clone</code> trait we defined earlier:</p>
<pre><code>trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
</code></pre>
<p>This trait defines a function that returns Self by-value. What would happen
if we tried to write the following?</p>
<pre><code class="language-ignore">fn main() {
    let x: &amp;Clone = ...; // doesn't matter
    let y = x.clone();   // Clone the data...?
}
</code></pre>
<p>How much space on the stack should <code>y</code> reserve in this case? What type should <code>y</code>
even have? The answer is that <em>we can't know at compile time</em>. This means that
a Clone trait object is actually nonsensical. More generally, <em>any</em> trait that
talks about Self by-value <em>anywhere</em> can't be turned into a trait object.</p>
<p>Trait objects are also, interestingly, implemented in a rather unconventional
way. Recall that the <em>usual</em> strategy for this sort of thing is for virtualizable
types to store a secret vtable field. This is annoying for two reasons.</p>
<p>First, everything is storing and setting a pointer <em>even when it doesn't need to</em>.
Whether you will actually be virtualized or not doesn't matter, because a type
needs to have a fixed layouts. So if some Widgets could be virtualized, then all
Widgets need to store that pointer.</p>
<p>Second, once you get to such a type's vtable, it's actually
non-trivial to determine where the functions you're interested in are stored. This is
because interfaces are, effectively, multiple inheritance (C++ meanwhile literally has
multiple inheritance). As an example, consider this set of types, traits, and
implementations:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Animal { }
trait Feline { }
trait Pet { }

// Animal, Feline, Pet
struct Cat { }

// Animal, Pet
struct Dog { }

// Animal, Feline
struct Tiger { }

#}</code></pre></pre>
<p>What would the static layout of an <code>Animal + Pet</code> and <code>Animal + Feline</code>
be? Well, <code>Animal + Pet</code> consists of Cats and Dogs. We can lay them out
so Cats and Dogs look the same:</p>
<pre><code class="language-text">Cat vtable              Dog vtable              Tiger vtable
+-----------------+     +-----------------+     +-----------------+
| type stuff      |     | type stuff      |     | type stuff      |
+-----------------+     +-----------------+     +-----------------+
| Animal stuff    |     | Animal stuff    |     | Animal stuff    |
+-----------------+     +-----------------+     +-----------------+
| Pet stuff       |     | Pet stuff       |     | Feline stuff    |
+-----------------+     +-----------------+     +-----------------+
| Feline stuff    |
+-----------------+
</code></pre>
<p>But now Cats and Tigers don't look the same. Swapping Pet and Feline in Cat
fixes that:</p>
<pre><code class="language-text">Cat vtable              Dog vtable              Tiger vtable
+-----------------+     +-----------------+     +-----------------+
| type stuff      |     | type stuff      |     | type stuff      |
+-----------------+     +-----------------+     +-----------------+
| Animal stuff    |     | Animal stuff    |     | Animal stuff    |
+-----------------+     +-----------------+     +-----------------+
| Feline stuff    |     | Pet stuff       |     | Feline stuff    |
+-----------------+     +-----------------+     +-----------------+
| Pet stuff       |
+-----------------+
</code></pre>
<p>But now Cats and Dogs don't look the same! In this case, we can take the
following tact:</p>
<pre><code class="language-text">Cat vtable              Dog vtable              Tiger vtable
+-----------------+     +-----------------+     +-----------------+
| type stuff      |     | type stuff      |     | type stuff      |
+-----------------+     +-----------------+     +-----------------+
| Animal stuff    |     | Animal stuff    |     | Animal stuff    |
+-----------------+     +-----------------+     +-----------------+
| Feline stuff    |     |                 |     | Feline stuff    |
+-----------------+     +-----------------+     +-----------------+
| Pet stuff       |     | Pet stuff       |
+-----------------+     +-----------------+
</code></pre>
<p>But this doesn't scale very well. In the limit, every interface would have a
globally unique offset, so every vtable would have to reserve space for every single
interface! Well, you could actually trim off trailing padding like Tiger does, but
still, lots of wasted space. More fatally, this assumes that we <em>know</em> about
every interface. This is in fact not the case when dynamically linking libraries!
If a dynamic library passes you a <code>Box&lt;Pet&gt;</code>, you would need some way to agree
on the offset of a <code>Pet</code>, while knowing completely different sets of interfaces.
This is why most languages just toss in more indirection for resolving the layout
of a vtable at runtime.</p>
<p>But in Rust, this is all irrelevant! Rust doesn't store vtable pointers in types.
Rust represents trait objects as <em>fat pointers</em>. <code>Box&lt;Pet&gt;</code> is not, in fact,
a single pointer. It's a pair of pointers, <code>(data, vtable)</code>. The vtable pointed
to also isn't <em>the</em> vtable for the data's type, it's <em>a</em> vtable. Specifically,
it's a custom vtable made explicitly for <code>Pet</code>:</p>
<pre><code class="language-text">Cat's Pet vtable        Dog's Pet vtable
+-----------------+     +-----------------+
| type stuff      |     | type stuff      |
+-----------------+     +-----------------+
| Pet stuff       |     | Pet stuff       |
+-----------------+     +-----------------+
</code></pre>
<p>Similarly, <code>Pet + Animal</code> or <code>Animal + Feline</code> would each get a custom vtable.
We are, in effect, monomorphizing vtables for every requested combination of
traits.</p>
<p>This strategy completely eliminates the problems with the embedded vtable
solution. Values that don't participate in virtualization don't have any
additional data associated with them, and one can statically know where a
particular <code>Pet</code> function can be found for <em>every</em> <code>Pet</code> vtable.</p>
<p>However it has its own drawbacks. First off, fat pointers obviously occupy
twice as much space, which may be a problem if you're storing a lot of them.
Second off, <em>we're monomorphizing vtables for every requested combination
of traits</em>. This is possible because everything has a statically known type
at <em>some</em> point, and all coercions to trait objects are also statically known.
Still, generous use of virtualization could lead to some serious bloat!</p>
<p><strong>Warning! Hypothetical speculation</strong>:</p>
<p>Fat pointers could also, in principle, be generalized to <em>obese pointers</em>.
With fat pointers, <code>Animal + Feline</code> is a single vtable pointer, but there's
no reason why it couldn't be <em>two</em> vtable pointers, one for each trait. This
could be used to reduce monomorphization, at the cost of even larger pointers.
This idea has been tossed around at various times, but there's no serious
roadmap for it.</p>
<p>Finally, let's return to a claim that was made several section ago:
a monomorphic interface can be converted into a virtualized one by the user.
This is done by a feature called &quot;impl Trait for Trait&quot;, which means that
trait objects implement their own traits. The end result is that the following
works:</p>
<pre><pre class="playpen"><code class="language-rust">// Stuff we've seen before...
trait Print {
    fn print(&amp;self);
}

impl Print for i32 {
    fn print(&amp;self) { println!(&quot;{}&quot;, self); }
}

impl Print for i64 {
    fn print(&amp;self) { println!(&quot;{}&quot;, self); }
}

// ?Sized specifies that T may be virtualized.
// Sized is a trait that all concrete types implicitly
// implement. However, things like Traits and
// [T] are &quot;unsized types&quot;. Specifying that `T: ?Sized`
// indicates to the compiler that it should be an error
// to ever try to use T by-value, because Sized *might not*
// be implemented.
fn print_it_twice&lt;T: ?Sized + Print&gt;(to_print: &amp;T) {
    to_print.print();
    to_print.print();
}

fn main() {
    // Static dispatch; monomorphized version for each type.
    print_it_twice(&amp;0i32);  // 0, 0
    print_it_twice(&amp;10i64); // 10, 10

    // Causes vtables for i32::Print and i64::Print to be constructed
    let data: [Box&lt;Print&gt;; 2] = [Box::new(20i32), Box::new(30i64)];

    for val in &amp;data {
        // Dynamic dispatch; a single virtualized version is monomorphized.
        // Annoying manual conversion from &amp;Box&lt;Print&gt; to &amp;Print because
        // generics and auto-deref have a bad interaction.
        print_it_twice(&amp;**val);    // 20, 20, 30, 30
    }
}
</code></pre></pre>
<p>Nifty! Not silky smooth, but nifty none-the-less. Also, unfortunately,
there is no <code>impl Trait for Box&lt;Trait&gt;</code>. I believe this could have a bad
interaction with the ability to <code>impl&lt;T: Trait&gt; Trait for Box&lt;T&gt;</code>, but
I haven't thought about it too much. Possibly the fact that <code>T</code> is <code>Sized</code>
in such an impl makes it fine?</p>
<a class="header" href="print.html#associated-types" id="associated-types"><h1>Associated Types</h1></a>
<p>When we declare that something is generic over a type, what are the consequences?
What are we trying to express? Usually, the idea being expressed, and the ultimate
consequence, is that someone can give us a type, and we'll figure out how to handle it.
That is, we accept types as <em>input</em>. <code>struct Foo&lt;T&gt;</code> states that given a <code>T</code>, we can produce the
type <code>Foo&lt;T&gt;</code>. Note that <code>Foo</code> itself is not really a well-formed type on its
own.</p>
<p>If you like fancy terms, you could say that <code>Foo</code> is a type constructor -- a function
that takes a type and returns a type -- and we're working with higher-kinded types.
For this reason, you may occasionally see generic arguments referred to as <em>input
types</em>. This is particularly apt, because these types are usually given as input
by the caller of generic code.</p>
<p>Traits can also be generic, what does that mean? What does <code>trait Eat&lt;T&gt;</code> express?
Ultimately, it's expressing that it's possible to implement the interface <code>Eat</code>
multiple times. However it's also saying that any implementation must in some
way be connected to some other type, and it shall be called <code>T</code>.</p>
<p>Like generic arguments to types, an implementation is <em>incomplete</em> without specifying this.
One cannot implement <code>Eat</code>. One must implement <code>Eat&lt;T&gt;</code>. Similarly, one cannot
demand that <code>Eat</code> is implemented. One must demand that <code>Eat&lt;T&gt;</code> is implemented.
Once again, the final choice of <code>T</code> is an input given by the end user of the
interface.</p>
<p>That's all fine and good, but why do we care? Consider providing an interface
for Iterators:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}

/// An iterator that yields the elements
/// from a Vec, Stackwise.
struct StackIter&lt;T&gt; {
    data: Vec&lt;T&gt;,
}

// An iterator over the range [min, max)
struct RangeIter {
    min: u32,
    max: u32,
}

impl&lt;T&gt; Iterator&lt;T&gt; for StackIter&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.data.pop()
    }
}

impl Iterator&lt;u32&gt; for RangeIter {
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        if self.min &gt;= self.max {
            None
        } else {
            let res = Some(self.min);
            self.min += 1;
            res
        }
    }
}

#}</code></pre></pre>
<p>Ok, this all seems good! We can express concrete and generic implementations of
this interface. Perfect. But note something strange here: every <em>real</em> type only
implements Iterator exactly once. That is, <code>StackIter&lt;Cat&gt;</code> only implements
<code>Iterator&lt;Cat&gt;</code>. It's never going to implement <code>Iterator&lt;Dog&gt;</code>. In fact, upon
reflection, allowing this would probably be a bad idea. It would mean that any
time someone tried to get the next element out of an iterator, it would be
ambiguous what kind of element they're actually requesting!</p>
<p>Really, we don't want <code>T</code> to be an input to <code>Iterator</code> in the same way <code>T</code> is an
input to <code>StackIter</code>. But this is necessary, because we can't hard-code what kind
of type is yielded by an iterator. That information needs to be provided by
the implementor!</p>
<p>And that's what associated types are for. With associated types, we can specify
that an implementation of a trait needs to specify some types that are associated
with a particular implementation, just as we can specify that functions
must be provided. Here's <code>Iterator</code> refactored to use them:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait Iterator {
    // Every iterator yields a particular type of
    // item, which they must specify.
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}

/// An iterator that yields the elements
/// from a Vec, Stackwise.
struct StackIter&lt;T&gt; {
    data: Vec&lt;T&gt;,
}

// An iterator over the range [min, max)
struct RangeIter {
    min: u32,
    max: u32,
}

impl&lt;T&gt; Iterator for StackIter&lt;T&gt; {
    // Associated items can still be
    // derived from other generics
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.data.pop()
    }
}

impl Iterator for RangeIter {
    // Or concretely specified.
    type Item = u32;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.min &gt;= self.max {
            None
        } else {
            let res = Some(self.min);
            self.min += 1;
            res
        }
    }
}

#}</code></pre></pre>
<p>And now we've forbidden a type implementing Iterator in multiple ways.
Although associated types can be generic, they can't be specified to
be completely independent of all other types. So for instance, this
is completely invalid code:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Iterator for RangeIter {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        unimplemented!()
    }
}
</code></pre>
<pre><code class="language-text">&lt;anon&gt;:3:6: 3:7 error: the type parameter `T` is not constrained by the impl trait, self type, or predicates [E0207]
&lt;anon&gt;:3 impl&lt;T&gt; Iterator for RangeIter {
              ^
</code></pre>
<p>For this reason, we sometimes call associated types <em>output types</em>.</p>
<p>Ok, so we can restrict implementations with associated types. But do they
let us create implementations that <em>couldn't</em> be expressed before? Actually, yes!</p>
<p>Consider a modified version of Iterator -- StateMachine.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait StateMachine {
    type NextState: StateMachine;
    fn step(self) -&gt; Option&lt;Self::NextState&gt;;
}

#}</code></pre></pre>
<p>Ok, so a StateMachine is some type that you can tell do a step, and it
will turn itself into a new StateMachine of some kind. Let's try to write
that out as a generic trait:</p>
<pre><code class="language-rust ignore">trait StateMachine&lt;NextStep: StateMachine&lt;UHHH_WHAT_GOES_HERE&gt;&gt; {
    fn step(self) -&gt; Option&lt;NextState&gt;;
}
</code></pre>
<p>Trying to express StateMachine as a generic trait leads to infinite type recursion!
Because generics are inputs, all of the types need to be provided by the <em>consumer</em>
of the interface. Which, in this case, is the interface itself. That said, there
<em>is</em> a way to resolve this without associated types: virtualization!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait StateMachine {
    // Box is magic! self can be type Box&lt;Self&gt;.
    // This doesn't work with e.g. Rc&lt;Self&gt;, because *magic*.
    fn step(self: Box&lt;Self&gt;) -&gt; Option&lt;Box&lt;StateMachine&gt;&gt;;
}

#}</code></pre></pre>
<p>This expresses much the same intent as the associated type code. We consume
ourselves, and we yield <em>something</em> that implements the interface. However,
in order to get this working we have to mandate that all StateMachines must
be boxed up, and after the first call to <code>step</code>, the type of the resultant
StateMachine will be completely unknown. With associated types, nothing needs
to be boxed, and concrete code always knows the type of a StateMachine.</p>
<p>Oh, one last thing: traits objects don't work with associated types for the
exact same reason they don't work with by-value Self. No way to know the type
statically, so no way to work with it. If you specify all the associated types,
it does work though! That is, <code>Box&lt;Iterator&gt;</code> doesn't work, but
<code>Box&lt;Iterator&lt;Item=u32&gt;&gt;</code> does.</p>
<a class="header" href="print.html#where-clauses" id="where-clauses"><h1>Where Clauses</h1></a>
<p>Hey, remember this example?</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Generic&lt;T&gt; {
    // Interesting problem: we've inverted the order on `equal` here
    // (`x == y` is being evaluated as `y == x`). How can we express
    // `T: Equal&lt;U&gt;` to fix this? Note that we can't do this at the
    // time where we declare `T`, because `U` doesn't exist yet!
    // More on this later!
    fn my_equal&lt;U: Equal&lt;T&gt;&gt;(&amp;self, other: &amp;Generic&lt;U&gt;) -&gt; bool {
       other.data.equal(&amp;self.data)
    }
}
</code></pre>
<p>And now that we've seen associated items, what about this kind of code?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Interesting problem: associated types were supposed to let us avoid
// declaring &quot;output types&quot;, but we need to declare it if we want to
// bound the item, right?
fn min&lt;I: Iterator&lt;Item = T&gt;, T: Ord&gt;(mut iter: I) -&gt; Option&lt;I::Item&gt; {
    if let Some(first) = iter.next() {
        let mut min = first;
        for x in iter {
            if x &lt; min {
                min = x;
            }
        }
        Some(min)
    } else {
        None
    }
}

#}</code></pre></pre>
<p>The solution to this problem and more is to use a <em>where clause</em>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Generic&lt;T&gt; {
    fn my_equal&lt;U&gt;(&amp;self, other: &amp;Generic&lt;U&gt;) -&gt; bool
        where T: Equal&lt;U&gt;
    {
       self.data.equal(&amp;other.data)
    }
}

fn min&lt;I&gt;(mut iter: I) -&gt; Option&lt;I::Item&gt;
    where I: Iterator,
          I::Item: Ord,
{
    if let Some(first) = iter.next() {
        let mut min = first;
        for x in iter {
            if x &lt; min {
                min = x;
            }
        }
        Some(min)
    } else {
        None
    }
}
</code></pre>
<p>Where clauses allow us to specify bounds on <em>arbitrary</em> types. That's it. It's
just a more flexible syntax than the inline one. You can put where clauses
at the top of trait declarations, trait implementations, function declarations,
enum declarations, and struct declarations. Pretty much anywhere you could've
started defining generic arguments.</p>
<p>In addition to letting you go completely nuts with with weird requirements
(<code>impl Send for MyReference&lt;T&gt; where &amp;T: Send</code> anybody?), they also have a
magical interaction with trait objects. Remember when I said that any trait
that makes reference to Self by-value can't be turned into a trait object?
Well, you can sort-of fix that with where clauses.</p>
<pre><pre class="playpen"><code class="language-rust">trait Print {
    fn print(&amp;self);

    // `where Self: Sized` means this function
    // isn't available for trait-objects. So it's
    // safe to use Print as a trait object!
    fn copy(&amp;self) -&gt; Self where Self: Sized;
}


impl Print for u32 {
    fn print(&amp;self) { println!(&quot;{}&quot;, self); }
    fn copy(&amp;self) -&gt; Self { *self }
}

fn main() {
    let x: Box&lt;Print&gt; = Box::new(0u32);
    x.print();
}
</code></pre></pre>
<a class="header" href="print.html#higher-rank-trait-bounds" id="higher-rank-trait-bounds"><h1>Higher Rank Trait Bounds</h1></a>
<p>Alright, so from here on out is where we really go off the rails. This is
the really obscure stuff that only the depraved type-system aficionados
take pleasure in.</p>
<p>We would like to write higher order functions, which is a really fancy term
for &quot;functions that take functions&quot;. The classic example of a higher-order
function is <code>map</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let x: Option&lt;u32&gt; = Some(0);
let y: Option&lt;bool&gt; = x.map(|v| v &gt; 5);

#}</code></pre></pre>
<p>Several thousand words ago, you may have seen an off-hand comment that Rust
does this with traits. Granted, they're magic traits, but they're traits
nonetheless! We have <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>. This distinction isn't really important,
for our purposes, so ~<em>handwave</em>~ it's about ownership and we're just always going
to use the right one without any explanation.</p>
<p><code>Fn</code> itself isn't a trait though. It's actually a big family of traits.
<code>Fn(A, B) -&gt; C</code>, on the other hand, is a proper trait. It's just like generics.
Actually it's literally generics. <code>Fn(A, B) -&gt; C</code> is actually sugar for a generic
trait, which you can't actually use in stable Rust (as of 1.7). Under the wraps,
it desugars to something like <code>Fn&lt;(A, B), Output=C&gt;</code>. Inputs are all input types,
and outputs are output types. Hey nice, terminology actually lining up!</p>
<p>So for instance the closure in the example above implements <code>FnOnce(u32) -&gt; bool</code>.
Everything sounding good so far. What about this?</p>
<pre><pre class="playpen"><code class="language-rust">fn get_first(input: &amp;(u32, i32)) -&gt; &amp;u32 { &amp;input.0 }

fn main() {
    let a = (0, 1);
    let b = (2, 3);

    let x = Some(&amp;a);
    let y = Some(&amp;b);

    println!(&quot;{}&quot;, x.map(get_first).unwrap());
    println!(&quot;{}&quot;, y.map(get_first).unwrap());
}
</code></pre></pre>
<p>What, exactly, does <code>get_first</code> implement? <code>Fn(&amp;(u32, i32)) -&gt; &amp;u32</code>, right?
Here's the thing: <em>that's not a thing</em>. Let's make our own trait to test:</p>
<pre><code class="language-rust ignore">trait MyFn&lt;Input&gt; {
    type Output;
}

// Dummy type; don't care about
// actually implementing a function here.
struct Thunk;

impl MyFn&lt;&amp;(u32, i32)&gt; for Thunk {
    type Output = &amp;u32;
}
</code></pre>
<pre><code class="language-text">&lt;anon&gt;:9:11: 9:22 error: missing lifetime specifier [E0106]
&lt;anon&gt;:9 impl MyFn&lt;&amp;(u32, i32)&gt; for Thunk {
                   ^~~~~~~~~~~
&lt;anon&gt;:9:11: 9:22 help: see the detailed explanation for E0106
&lt;anon&gt;:10:19: 10:23 error: missing lifetime specifier [E0106]
&lt;anon&gt;:10     type Output = &amp;u32;
                            ^~~~
&lt;anon&gt;:10:19: 10:23 help: see the detailed explanation for E0106
error: aborting due to 2 previous errors
</code></pre>
<p>References without a lifetime are a charade. Anywhere a reference
is used in a type, a lifetime has to be provided! Rust just has
some really nice rules that let you skip it 99% of the time, because
there's an obvious default.</p>
<p>In this case, <code>get_first</code> is actually sugar for this:</p>
<pre><code>fn get_first&lt;'a&gt;(input: &amp;'a (u32, i32)) -&gt; &amp;'a u32 { &amp;input.0 }
</code></pre>
<p>Anywhere you see references in a function signature, they're actually
generic. This implies a generic trait implementation; let's try it.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait MyFn&lt;Input&gt; {
    type Output;
}

struct Thunk;

impl&lt;'a&gt; MyFn&lt;&amp;'a (u32, i32)&gt; for Thunk {
    type Output = &amp;'a u32;
}

#}</code></pre></pre>
<p>Which compiles perfectly fine. But here's the thing: <code>Fn(&amp;(u32, i32)) -&gt; &amp;u32</code>
is <em>totally</em> a thing, and I lied to you. In order to see how and why, let's
consider writing <code>filter</code> for an <code>Iterator</code>:</p>
<pre><pre class="playpen"><code class="language-rust">/// A filter over an iterator
struct Filter&lt;I, F&gt; {
    iter: I,
    pred: F,
}

/// Constructs a filter
fn filter&lt;I, F&gt;(iter: I, pred: F) -&gt; Filter&lt;I, F&gt; {
    Filter { iter: iter, pred: pred }
}

impl&lt;I, F&gt; Iterator for Filter&lt;I, F&gt;
    where I: Iterator,
          F: Fn(&amp;I::Item) -&gt; bool,  // Magic! What's the lifetime?
{
    type Item = I::Item;

    fn next(&amp;mut self) -&gt; Option&lt;I::Item&gt; {
        while let Some(val) = self.iter.next() {
            if (self.pred)(&amp;val) {
                return Some(val);
            }
        }
        None
    }
}

fn main() {
    let x = vec![1, 2, 3, 4, 5];
    for v in filter(x.into_iter(), |v: &amp;i32| *v % 2 == 0) {
        println!(&quot;{}&quot;, v); // 2, 4
    }
}
</code></pre></pre>
<p>Straight-up wizard magic. Here's the deal: our <code>pred</code> function needs to be able
to work with the lifetime of <code>&amp;val</code>. Unfortunately, <em>it's literally impossible
to name that lifetime</em> -- even if we put a <code>where</code> clause on the <code>next</code>
function itself (which would be illegal for the Iterator trait regardless).
That lifetime is just some temporary in the middle of a function. So we need
<code>pred</code> to work with &quot;some&quot; lifetime that we can't name, what are we to do?
Our solution to this problem is simple brute force; demand that <code>pred</code> works
with <em>every</em> lifetime!</p>
<p>It turns out that <code>F: Fn(&amp;I::Item) -&gt; bool</code> is sugar for</p>
<pre><code class="language-rust ignore">for&lt;'a&gt; F: Fn(&amp;I::Item) -&gt; bool
</code></pre>
<p>Where <code>for&lt;'a&gt;</code> is intended to read as literally &quot;for all 'a&quot;. We call this a
<em>higher rank trait bound</em> (HRTB). Unless you're into some deep type-level nonsense,
you will literally only ever see HRTBs used with the function traits, and
function traits have this nice sugar so you usually don't have to use HRTBs at
all. Note that HTRBs literally only work for lifetimes right now.</p>
<a class="header" href="print.html#higher-kinded-types" id="higher-kinded-types"><h1>Higher Kinded Types</h1></a>
<p>We previously noted that generics are essentially expressing higher-kinded types.
That is, one can think of <code>Vec</code> as a type constructor of the form <code>(T) -&gt; Vec&lt;T&gt;</code>.
We can talk about this type constructor to some extent when writing generic code.
That is, we can say something like <code>impl&lt;T&gt; Trait for Vec&lt;T&gt;</code> or
<code>fn make_vec&lt;T&gt;() -&gt; Vec&lt;T&gt;</code>. But we have a limitation here: to talk about a type
constructor, we need to concretely name the type constructor we're interested in.
That is, we can't be generic over type constructors themselves.</p>
<p>For instance, say we wanted to write a data structure that uses reference-counted
pointers internally. Rust's standard library provides two choices: <code>Rc</code>, and <code>Arc</code>.
<code>Rc</code> is more efficient, but <code>Arc</code> is thread-safe. For the purposes of our implementation,
these two types are completely interchangeable. To the consumers of out implementation,
which type is used has important semantic consequences.</p>
<p><em>Ideally</em>, our data structure would be generic over Rc and Arc. That is, we'd
like to write something like:</p>
<pre><code class="language-rust ignore">// NOTE: This code is nonsense and doesn't work!

/// A simple reference-counted linked list.
/// RefCount can either be Rc or Arc; You Decide!
struct Node&lt;RefCount: RcLike, T&gt; {
    elem: T,
    next: Option&lt;RefCount&lt;Node&lt;RefCount, T&gt;&gt;&gt;,
}
</code></pre>
<p>But alas, we cannot do this! Our users can't pass <code>Rc</code> or <code>Arc</code> unadorned to
us. These types must be completed as <code>Rc&lt;SomeType&gt;</code>. One solution is to
specifying a trait for the entirety of <code>Rc&lt;Node&lt;T&gt;&gt;</code>, but this is considerably
less composable than just specifying <code>Rc</code> or <code>Arc</code> themselves.</p>
<p>Another instance where this would be useful would be talking about generic
return types that borrow. For instance, today we can express</p>
<pre><code class="language-rust ignore">/// An iterator that doesn't allow `next` to be called
/// again until the last yielded item is disposed of.
trait RefIterator {
    type Item;
    fn next(&amp;mut self) -&gt; &amp;mut T
}
</code></pre>
<p>which as we saw in the previous section, is sugar for</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
trait RefIterator {
    type Item;
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut Self::Item;
}

#}</code></pre></pre>
<p>One annoying aspect of this definition is that we're hardcoding the fact
that the reference is the outermost object. This implies that Self::Item
has to be stored somewhere. What we'd really like to express is the
following:</p>
<pre><code class="language-rust ignore">trait RefIterator {
    type Item;
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Item&lt;'a&gt;;
}
</code></pre>
<p>This is strictly more general, because one can always choose <code>Self::Item = &amp;mut T</code>.
But this means that <code>Item</code> is now actually a type-constructor, and we're not allowed
to talk about those generically!</p>
<p>Ok so don't tell anyone I told you this, but Rust actually does let you talk
about type-constructors. Sort of. Terribly.</p>
<p>The key insight is that traits have input types and output types, so they're
basically type-level functions. In particular:</p>
<pre><code class="language-ignore ignore">trait TypeToType&lt;Input&gt; {
    type Output;
}
</code></pre>
<p>is exactly the shape of a type constructor. With this, we can actually
describe RefIter!</p>
<pre><pre class="playpen"><code class="language-rust">use std::marker::PhantomData;
use std::mem;
use std::cmp;

// A type we'd like to yield from a RefIter
struct MyType&lt;'a&gt; {
    slice: &amp;'a mut [u8],
    index: usize,
}

// Kind: Lifetime -&gt; Type
trait LifetimeToType&lt;'a&gt; {
    type Output;
}

// Stub types representing the type constructors
// that we want to work with.

/// &amp;'* T
struct Ref_&lt;T&gt;(PhantomData&lt;T&gt;);
/// &amp;'* mut T
struct RefMut_&lt;T&gt;(PhantomData&lt;T&gt;);
/// MyType&lt;*&gt;
struct MyType_;

// Describe the mapping each type constructor performs
impl&lt;'a, T: 'a&gt; LifetimeToType&lt;'a&gt; for Ref_&lt;T&gt; {
    type Output = &amp;'a T;
}
impl&lt;'a, T: 'a&gt; LifetimeToType&lt;'a&gt; for RefMut_&lt;T&gt; {
    type Output = &amp;'a mut T;
}
impl&lt;'a&gt; LifetimeToType&lt;'a&gt; for MyType_ {
    type Output = MyType&lt;'a&gt;;
}


// The actual trait we want to implement!
// `Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output`
// is the result of applying 'a to the TypeCtor.
//
// Note: &lt;X as Trait&gt;::AssociatedItem is &quot;the inverse turbofish&quot;,
// for referring to associated items unambiguously.
//
// Note: I don't think we can use HRTB here,
// because of the `T: 'a` requirement.
// `for&lt;'a&gt; Self::TypeCtor: LifetimeToType&lt;'a&gt;` would basically
// mandate that `&amp;'a T` is well-formed for all choices of `'a`,
// but this is only true if `T: 'static`!
// Instead use a &quot;last minute&quot; where clause on `next`.
trait RefIterator {
    type TypeCtor;
    fn next&lt;'a&gt;(&amp;'a mut self)
        -&gt; Option&lt;&lt;Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output&gt;
        where Self::TypeCtor: LifetimeToType&lt;'a&gt;;

}

// Iterators!
struct Iter&lt;'a, T: 'a&gt; {
    slice: &amp;'a [T],
}

struct IterMut&lt;'a, T: 'a&gt; {
    slice: &amp;'a mut [T],
}

struct MyIter&lt;'a&gt; {
    slice: &amp;'a mut [u8],
}


// FIXME: https://github.com/rust-lang/rust/issues/31580
// rustc is failing to resolve some types that it should.
// Passing them through these functions (which is a no-op)
// forces it to &quot;get it&quot;.
fn _hack_project_ref&lt;'a, T&gt;(v: &amp;'a T) -&gt; &lt;Ref_&lt;T&gt; as LifetimeToType&lt;'a&gt;&gt;::Output { v }
fn _hack_project_ref_mut&lt;'a, T&gt;(v: &amp;'a mut T) -&gt; &lt;RefMut_&lt;T&gt; as LifetimeToType&lt;'a&gt;&gt;::Output { v }
fn _hack_project_my_type&lt;'a&gt;(v: MyType&lt;'a&gt;) -&gt; &lt;MyType_ as LifetimeToType&lt;'a&gt;&gt;::Output { v }

// Actual implementations (nothing super notable)
impl&lt;'x, T&gt; RefIterator for Iter&lt;'x, T&gt; {
    type TypeCtor = Ref_&lt;T&gt;;
    fn next&lt;'a&gt;(&amp;'a mut self)
        -&gt; Option&lt;&lt;Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output&gt;
        where Self::TypeCtor: LifetimeToType&lt;'a&gt;
    {
        if self.slice.is_empty() {
            None
        } else {
            let (l, r) = self.slice.split_at(1);
            self.slice = r;
            Some(_hack_project_ref(&amp;l[0]))
        }
    }
}

impl&lt;'x, T&gt; RefIterator for IterMut&lt;'x, T&gt; {
    type TypeCtor = RefMut_&lt;T&gt;;
    fn next&lt;'a&gt;(&amp;'a mut self)
        -&gt; Option&lt;&lt;Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output&gt;
        where Self::TypeCtor: LifetimeToType&lt;'a&gt;
    {
        if self.slice.is_empty() {
            None
        } else {
            let (l, r) = mem::replace(&amp;mut self.slice, &amp;mut []).split_at_mut(1);
            self.slice = r;
            Some(_hack_project_ref_mut(&amp;mut l[0]))
        }
    }
}


impl&lt;'x&gt; RefIterator for MyIter&lt;'x&gt; {
    type TypeCtor = MyType_;
    fn next&lt;'a&gt;(&amp;'a mut self)
        -&gt; Option&lt;&lt;Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output&gt;
        where Self::TypeCtor: LifetimeToType&lt;'a&gt;
    {
        if self.slice.is_empty() {
            None
        } else {
            let split = cmp::min(self.slice.len(), 5);
            let (l, r) = mem::replace(&amp;mut self.slice, &amp;mut []).split_at_mut(split);
            self.slice = r;
            let my_type = MyType { slice: l, index: split / 2 };
            Some(_hack_project_my_type(my_type))
        }
    }
}

// Usage!

fn main() {
    let mut data: [u8; 12] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
    {
        let mut iter = Iter { slice: &amp;data };
        while let Some(v) = iter.next() {
            println!(&quot;{:?}&quot;, v);
        }
    }
    {
        let mut iter = IterMut { slice: &amp;mut data };
        while let Some(v) = iter.next() {
            println!(&quot;{:?}&quot;, v);
        }
    }
    {
        let mut iter = MyIter { slice: &amp;mut data };
        while let Some(v) = iter.next() {
            println!(&quot;{:?} {}&quot;, v.slice, v.index);
        }
    }
}
</code></pre></pre>
<p>I'm not sure I can give too much insight into how this works. It's just a
natural consequence of all the other systems in action. Can we also solve
the <code>Rc</code>/<code>Arc</code> problem with this trick?</p>
<p>Sort of!</p>
<p>We can do the following:</p>
<pre><pre class="playpen"><code class="language-rust">use std::rc::Rc;
use std::sync::Arc;
use std::ops::Deref;

// Kind: Type -&gt; Type
trait RcLike&lt;T&gt; {
    type Output;
    fn new(data: T) -&gt; Self::Output;
}

// Stubs
struct Rc_;
struct Arc_;

impl&lt;T&gt; RcLike&lt;T&gt; for Rc_ {
    type Output = Rc&lt;T&gt;;
    fn new(data: T) -&gt; Self::Output {
        Rc::new(data)
    }
}

impl&lt;T&gt; RcLike&lt;T&gt; for Arc_ {
    type Output = Arc&lt;T&gt;;
    fn new(data: T) -&gt; Self::Output {
        Arc::new(data)
    }
}

struct Node&lt;Ref, T&gt;
    // This `where` clause is the problem! (more on that later)
    where Ref: RcLike&lt;Node&lt;Ref, T&gt;&gt;,
{
    elem: T,
    // basically: Option&lt;Rc&lt;Node&lt;Rc_, T&gt;&gt;
    next: Option&lt;&lt;Ref as RcLike&lt;Node&lt;Ref, T&gt;&gt;&gt;::Output&gt;
}

struct List&lt;Ref, T&gt;
    where Ref: RcLike&lt;Node&lt;Ref, T&gt;&gt;,
{
    head: Option&lt;&lt;Ref as RcLike&lt;Node&lt;Ref, T&gt;&gt;&gt;::Output&gt;
}

impl&lt;Ref, T, RefNode&gt; List&lt;Ref, T&gt;
    where Ref: RcLike&lt;Node&lt;Ref, T&gt;, Output=RefNode&gt;,
          RefNode: Deref&lt;Target=Node&lt;Ref, T&gt;&gt;,
          RefNode: Clone,
{
    fn new() -&gt; Self {
        List {
            head: None
        }
    }

    fn push(&amp;self, elem: T) -&gt; Self {
        List {
            head: Some(Ref::new(Node {
                elem: elem,
                next: self.head.clone(),
            }))
        }
    }

    fn tail(&amp;self) -&gt; Self {
        List {
            head: self.head.as_ref().and_then(|head| head.next.clone())
        }
    }
}




fn main() {
    // Usage (pretend we bothered to impl proper iterators/accessors)

    let list: List&lt;Rc_, u32&gt; = List::new().push(0).push(1).push(2).tail();
    println!(&quot;{}&quot;, list.head.unwrap().elem); // 1

    let list: List&lt;Arc_, u32&gt; = List::new().push(10).push(11).push(12).tail();
    println!(&quot;{}&quot;, list.head.unwrap().elem); // 11
}
</code></pre></pre>
<p>This is <em>almost</em> perfect, there's just one problem: <code>where Ref: RcLike&lt;Node&lt;Ref, T&gt;&gt;</code>.
This is a breach of our abstraction boundary. We don't want users of our data structure
to know or care about Nodes, but we're forced to talk about them here. What we'd <em>really</em>
like is to be able to say is that Ref is RcLike for <em>everything</em>. In other words,
we'd like to write <code>where for&lt;T&gt; Ref: RcLike&lt;T&gt;</code>. This would allow us to hide
how we actually intend to use <code>Ref</code>.</p>
<p>Unfortunately, higher rank trait bounds don't work on non-lifetimes today.
They may work one day (wild speculation!), but today is not that day. If HRTBs
worked for types, we would actually be able to fully express HKTs!</p>
<p>Still, I hope you can see that talking about type constructors, even just in
the limited way we can, is a huge friggin' pain in Rust. Ideally, Rust would
support &quot;native&quot; HKT with its own syntax to make this more ergonomic.</p>
<a class="header" href="print.html#generativity" id="generativity"><h1>Generativity</h1></a>
<p>Have you ever though about the fact that two instances of a type are completely
interchangeable? If we have two Widgets we're allowed to swap them, and no one cares.
Most of the time, this is completely desirable. But what if it weren't? What if
we wanted two instances of the same type to <em>stop</em> being interchangeable?</p>
<p>Consider arrays. Normally, when we iterate an array we do it to get the elements.
However this requires us to provide various iterators for all the different modes
of access: <code>Iter</code>, <code>IterMut</code>, and <code>IntoIter</code>. Wouldn't it be more composable if
the iterator told us <em>where</em> to look, but let us decide how to perform the access?</p>
<p>Well, you can do that by having an array provide an iterator over its indices
themselves. <code>0, 1, 2, ..., len - 1</code>. Then we can just index into the array
however we please! Unfortunately, doing this would reduce the reliability of
iterators. Normal iterators have some nice properties: they're guaranteed to
never fail, and they're guaranteed to access each element at most once
(making <code>IterMut</code> sound).</p>
<p>With plain integer indices, iteration can become unreliable again. Indices can
be changed (forged), they can be held onto until after an array's length
changes (invalidated), and they can be used with a different array altogether
(mismatched)! Most of these problems are fairly easy to fix. To prevent forgeries,
we can simply wrap the integers up into a new type that hides the real values from
users. To prevent invalidation, we can tie the indices to the array by a lifetime.</p>
<p>But how do we prevent mismatches? If I have two arrays, the types of their indices
will be interchangeable, right? In order to do this, we need a way to solve that.
The solution to this problem is called <em>generativity</em>. Generativity is basically
the idea that different instances of the same type can have <em>different</em> associated
types. That is, which instance of a type an associated value is derived from really
matters.</p>
<p>I'm really, really tired. We're so close to done, so I'm just going to
copy-paste the demonstration of this that I wrote several months ago.
Explanation in the comments.</p>
<pre><pre class="playpen"><code class="language-rust">// This program demonstrates sound unchecked indexing
// by having slices generate valid indices, and &quot;signing&quot;
// them with an invariant lifetime. These indices cannot be used on another
// slice, nor can they be stored until the array is no longer valid
// (consider adapting this to Vec, and then trying to use indices after a push).
//
// This represents a design &quot;one step removed&quot; from iterators, providing greater
// control to the consumer of the API. Instead of getting references to elements
// we get indices, from which we can get references or hypothetically perform
// any other &quot;index-related&quot; operation (slicing?). Normally, these operations
// would need to be checked at runtime to avoid indexing out of bounds, but
// because the array knows it personally minted the indices, it can trust them.
// This hypothetically enables greater composition. Using this technique
// one could also do &quot;only once&quot; checked indexing (let idx = arr.validate(idx)).
//
// The major drawback of this design is that it requires a closure to
// create an environment that the signatures are bound to, complicating
// any logic that flows between the two (e.g. moving values in/out and try!).
// In principle, the compiler could be &quot;taught&quot; this trick to eliminate the
// need for the closure, as far as I know. Although how one would communicate
// that they're trying to do this to the compiler is another question.
// It also relies on wrapping the structure of interest to provide a constrained
// API (again, consider applying this to Vec -- need to prevent `push` and `pop`
// being called). This is the same principle behind Entry and Iterator.
//
// It also produces terrible compile errors (random lifetime failures),
// because we're hacking novel semantics on top of the borrowchecker which
// has no idea what's going on.
//
// This technique was first pioneered by gereeter to enable safely constructing
// search paths in BTreeMap. See Haskell's ST Monad for a related design.
//
// The example isn't maximally generic or fleshed out because I got bored trying
// to express the bounds necessary to handle &amp;[T] and &amp;mut [T] appropriately.

fn main() {
    use indexing::indices;

    let arr1: &amp;[u32] = &amp;[1, 2, 3, 4, 5];
    let arr2: &amp;[u32] = &amp;[10, 20, 30];

    // concurrent iteration (hardest thing to do with iterators)
    indices(arr1, |arr1, it1| {
        indices(arr2, move |arr2, it2| {
            for (i, j) in it1.zip(it2) {
                println!(&quot;{} {}&quot;, arr1.get(i), arr2.get(j));

                // should be invalid to idx wrong source
                // println!(&quot;{} &quot;, arr2.get(i));
                // println!(&quot;{} &quot;, arr1.get(j));
            }
        });
    });

    // can hold onto the indices for later, as long they stay in the closure
    let _a = indices(arr1, |arr, mut it| {
        let a = it.next().unwrap();
        let b = it.next_back().unwrap();
        println!(&quot;{} {}&quot;, arr.get(a), arr.get(b));
        // a    // should be invalid to return an index
    });

    // can get references out, just not indices
    let (x, y) = indices(arr1, |arr, mut it| {
        let a = it.next().unwrap();
        let b = it.next_back().unwrap();
        (arr.get(a), arr.get(b))
    });
    println!(&quot;{} {}&quot;, x, y);

    // Excercise to the reader: sound multi-index mutable indexing!?
    // (hint: it would be unsound with the current design)
}

mod indexing {
    use std::marker::PhantomData;
    use std::ops::Deref;
    use std::iter::DoubleEndedIterator;

    // Cell&lt;T&gt; is invariant in T; so Cell&lt;&amp;'id _&gt; makes `id` invariant.
    // This means that the inference engine is not allowed to shrink or
    // grow 'id to solve the borrow system.
    type Id&lt;'id&gt; = PhantomData&lt;::std::cell::Cell&lt;&amp;'id mut ()&gt;&gt;;

    pub struct Indexer&lt;'id, Array&gt; {
        _id: Id&lt;'id&gt;,
        arr: Array,
    }

    pub struct Indices&lt;'id&gt; {
        _id: Id&lt;'id&gt;,
        min: usize,
        max: usize,
    }

    #[derive(Copy, Clone)]
    pub struct Index&lt;'id&gt; {
        _id: Id&lt;'id&gt;,
        idx: usize,
    }

    impl&lt;'id, 'a&gt; Indexer&lt;'id, &amp;'a [u32]&gt; {
        pub fn get(&amp;self, idx: Index&lt;'id&gt;) -&gt; &amp;'a u32 {
            unsafe {
                self.arr.get_unchecked(idx.idx)
            }
        }
    }

    impl&lt;'id&gt; Iterator for Indices&lt;'id&gt; {
        type Item = Index&lt;'id&gt;;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            if self.min != self.max {
                self.min += 1;
                Some(Index { _id: PhantomData, idx: self.min - 1 })
            } else {
                None
            }
        }
    }

    impl&lt;'id&gt; DoubleEndedIterator for Indices&lt;'id&gt; {
        fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            if self.min != self.max {
                self.max -= 1;
                Some(Index { _id: PhantomData, idx: self.max })
            } else {
                None
            }
        }
    }

    pub fn indices&lt;Array, F, Out&gt;(arr: Array, f: F) -&gt; Out
        where F: for&lt;'id&gt; FnOnce(Indexer&lt;'id, Array&gt;, Indices&lt;'id&gt;) -&gt; Out,
              Array: Deref&lt;Target = [u32]&gt;,
    {
        // This is where the magic happens. We bind the indexer and indices
        // to the same invariant lifetime (a constraint established by F's
        // definition). As such, each call to `indices` produces a unique
        // signature that only these two values can share.
        //
        // Within this function, the borrow solver can choose literally any lifetime,
        // including `'static`, but we don't care what the borrow solver does in
        // *this* function. We only need to trick the solver in the caller's
        // scope. Since borrowck doesn't do interprocedural analysis, it
        // sees every call to this function produces values with some opaque
        // fresh lifetime and can't unify any of them.
        //
        // In principle a &quot;super borrowchecker&quot; that does interprocedural
        // analysis would break this design, but we could go out of our way
        // to somehow bind the lifetime to the inside of this function, making
        // it sound again. Borrowck will never do such analysis, so we don't
        // care.
        let len = arr.len();
        let indexer = Indexer { _id: PhantomData, arr: arr };
        let indices = Indices { _id: PhantomData, min: 0, max: len };
        f(indexer, indices)
    }
}
</code></pre></pre>
<p>Haha, totally simple right?! No, it's friggin' nightmare. And it's all really,
<em>really</em> unsafe and brittle. This is like the magnum-opus of the claim that
Unsafe Rust is something that contaminates the whole module. A single line
is marked as <code>unsafe</code>, but the safety of the whole system depends on getting
all the types right, and thinking about all the different corner cases.</p>
<p>Relying on generativity working right is really dangerous, which is why I'd
really like to see Rust explicitly support it, rather than simply having it
as an emergent behaviour of HRTBs.</p>
<a class="header" href="print.html#exeunt" id="exeunt"><h1>Exeunt</h1></a>
<p>That's it. That's everything I have the energy to write about. This got way too
long.</p>
<p>I'm sorry.</p>
<p>I'm sorry.</p>
<hr />
<p>layout: post
title: &quot;Mixing matching, mutation, and moves in Rust&quot;
author: Felix S. Klock II
description: &quot;A tour of matching and enums in Rust.&quot;</p>
<hr />
<p>One of the primary goals of the Rust project is to enable safe systems
programming. Systems programming usually implies imperative
programming, which in turns often implies side-effects, reasoning
about shared state, et cetera.</p>
<p>At the same time, to provide <em>safety</em>, Rust programs and data types
must be structured in a way that allows static checking to ensure
soundness. Rust has features and restrictions that operate in tandem
to ease writing programs that can pass these checks and thus ensure
safety. For example, Rust incorporates the notion of <em>ownership</em> deeply
into the language.</p>
<p>Rust's <code>match</code> expression is a construct that offers an interesting
combination of such features and restrictions. A <code>match</code> expression
takes an input value, classifies it, and then jumps to code written to
handle the identified class of data.</p>
<p>In this post we explore how Rust processes such data via <code>match</code>.
The crucial elements that <code>match</code> and its counterpart <code>enum</code> tie
together are:</p>
<ul>
<li>
<p>Structural pattern matching: case analysis with ergonomics vastly
improved over a C or Java style <code>switch</code> statement.</p>
</li>
<li>
<p>Exhaustive case analysis: ensures that no case is omitted
when processing an input.</p>
</li>
<li>
<p><code>match</code> embraces both imperative and functional styles of
programming: you can continue using <code>break</code> statements, assignments,
et cetera,
rather than being forced to adopt an expression-oriented mindset.</p>
</li>
<li>
<p><code>match</code> &quot;borrows&quot; or &quot;moves&quot;, as needed: Rust encourages the developer to
think carefully about ownership and borrowing. To ensure that
one is not forced to yield ownership of a value
prematurely, <code>match</code> is designed with support for merely <em>borrowing</em>
substructure (as opposed to always <em>moving</em> such substructure).</p>
</li>
</ul>
<p>We cover each of the items above in detail below, but first we
establish a foundation for the discussion: What does <code>match</code> look
like, and how does it work?</p>
<a class="header" href="print.html#the-basics-of-match" id="the-basics-of-match"><h3>The Basics of <code>match</code></h3></a>
<p>The <code>match</code> expression in Rust has this form:</p>
<pre><code class="language-rust ignore">match INPUT_EXPRESSION {
    PATTERNS_1 =&gt; RESULT_EXPRESSION_1,
    PATTERNS_2 =&gt; RESULT_EXPRESSION_2,
    ...
    PATTERNS_n =&gt; RESULT_EXPRESSION_n
}
</code></pre>
<p>where each of the <code>PATTERNS_i</code> contains at least one <em>pattern</em>. A
pattern describes a subset of the possible values to which
<code>INPUT_EXPRESSION</code> could evaluate.
The syntax <code>PATTERNS =&gt; RESULT_EXPRESSION</code> is called a &quot;match arm&quot;,
or simply &quot;arm&quot;.</p>
<p>Patterns can match simple values like integers or characters; they
can also match user-defined symbolic data, defined via <code>enum</code>.</p>
<p>The below code demonstrates generating the next guess (poorly) in a number
guessing game, given the answer from a previous guess.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
enum Answer {
    Higher,
    Lower,
    Bingo,
}

fn suggest_guess(prior_guess: u32, answer: Answer) {
    match answer {
        Answer::Higher =&gt; println!(&quot;maybe try {} next&quot;, prior_guess + 10),
        Answer::Lower  =&gt; println!(&quot;maybe try {} next&quot;, prior_guess - 1),
        Answer::Bingo  =&gt; println!(&quot;we won with {}!&quot;, prior_guess),
    }
}

#[test]
fn demo_suggest_guess() {
    suggest_guess(10, Answer::Higher);
    suggest_guess(20, Answer::Lower);
    suggest_guess(19, Answer::Bingo);
}

#}</code></pre></pre>
<p>(Incidentally, nearly all the code in this post is directly
executable; you can cut-and-paste the code snippets into a file
<code>demo.rs</code>, compile the file with <code>--test</code>, and run the resulting
binary to see the tests run.)</p>
<p>Patterns can also match <a href="http://en.wikipedia.org/wiki/Record_%28computer_science%29">structured data</a> (e.g. tuples, slices, user-defined
data types) via corresponding patterns. In such patterns, one often
binds parts of the input to local variables;
those variables can then be used in the result expression.</p>
<p>The special <code>_</code> pattern matches any single value, and is often used as
a catch-all; the special <code>..</code> pattern generalizes this by matching any
<em>series</em> of values or name/value pairs.</p>
<p>Also, one can collapse multiple patterns into one arm by separating the
patterns by vertical bars (<code>|</code>); thus that arm matches either this pattern,
or that pattern, et cetera.</p>
<p>These features are illustrated in the following revision to the
guessing-game answer generation strategy:</p>
<pre><code class="language-rust ignore">struct GuessState {
    guess: u32,
    answer: Answer,
    low: u32,
    high: u32,
}

fn suggest_guess_smarter(s: GuessState) {
    match s {
        // First arm only fires on Bingo; it binds `p` to last guess.
        GuessState { answer: Answer::Bingo, guess: p, .. } =&gt; {
     // ~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~  ~~~~~~~~  ~~
     //     |                 |                 |     |
     //     |                 |                 |     Ignore remaining fields
     //     |                 |                 |
     //     |                 |      Copy value of field `guess` into local variable `p`
     //     |                 |
     //     |   Test that `answer field is equal to `Bingo`
     //     |
     //  Match against an instance of the struct `GuessState`
     
            println!(&quot;we won with {}!&quot;, p);
        }

        // Second arm fires if answer was too low or too high.
        // We want to find a new guess in the range (l..h), where:
        //
        // - If it was too low, then we want something higher, so we
        //   bind the guess to `l` and use our last high guess as `h`.
        // - If it was too high, then we want something lower; bind
        //   the guess to `h` and use our last low guess as `l`.
        GuessState { answer: Answer::Higher, low: _, guess: l, high: h } |
        GuessState { answer: Answer::Lower,  low: l, guess: h, high: _ } =&gt; {
     // ~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~   ~~~~~~  ~~~~~~~~  ~~~~~~~
     //     |                 |                 |        |        |
     //     |                 |                 |        |    Copy or ignore
     //     |                 |                 |        |    field `high`,
     //     |                 |                 |        |    as appropriate
     //     |                 |                 |        |
     //     |                 |                 |  Copy field `guess` into
     //     |                 |                 |  local variable `l` or `h`,
     //     |                 |                 |  as appropriate
     //     |                 |                 |
     //     |                 |    Copy value of field `low` into local
     //     |                 |    variable `l`, or ignore it, as appropriate
     //     |                 |
     //     |   Test that `answer field is equal
     //     |   to `Higher` or `Lower`, as appropriate
     //     |
     //  Match against an instance of the struct `GuessState`

            let mid = l + ((h - l) / 2);
            println!(&quot;lets try {} next&quot;, mid);
        }
    }
}

#[test]
fn demo_guess_state() {
    suggest_guess_smarter(GuessState {
        guess: 20, answer: Answer::Lower, low: 10, high: 1000
    });
}
</code></pre>
<p>This ability to simultaneously perform case analysis <em>and</em> bind input
substructure leads to powerful, clear, and concise code, focusing the
reader's attention directly on the data relevant to the case at hand.</p>
<p>That is <code>match</code> in a nutshell.</p>
<p>So, what is the interplay between this construct and Rust's approach to
ownership and safety in general?</p>
<a class="header" href="print.html#exhaustive-case-analysis" id="exhaustive-case-analysis"><h3>Exhaustive case analysis</h3></a>
<blockquote>
<p>...when you have eliminated all which is impossible,
then whatever remains, however improbable, must be the truth.</p>
<p>-- Sherlock Holmes (Arthur Conan Doyle, &quot;The Blanched Soldier&quot;)</p>
</blockquote>
<p>One useful way to tackle a complex problem is to break it down
into individual cases and analyze each case individually.
For this method of problem solving to work, the breakdown must be
<em>collectively exhaustive</em>; all of the cases you identified must
actually cover all possible scenarios.</p>
<p>Using <code>enum</code> and <code>match</code> in Rust can aid this process, because
<code>match</code> enforces exhaustive case analysis:
Every possible input value for a <code>match</code> must be covered by the pattern
in a least one arm in the match.</p>
<p>This helps catch bugs in program logic and ensures that the value of a
<code>match</code> expression is well-defined.</p>
<p>So, for example, the following code is rejected at compile-time.</p>
<pre><code class="language-rust ignore">fn suggest_guess_broken(prior_guess: u32, answer: Answer) {
    let next_guess = match answer {
        Answer::Higher =&gt; prior_guess + 10,
        Answer::Lower  =&gt; prior_guess - 1,
        // ERROR: non-exhaustive patterns: `Bingo` not covered
    };
    println!(&quot;maybe try {} next&quot;, next_guess);
}
</code></pre>
<p>Many other languages offer a pattern matching construct (ML and
various macro-based <code>match</code> implementations in Scheme both come to
mind), but not all of them have this restriction.</p>
<p>Rust has this restriction for these reasons:</p>
<ul>
<li>
<p>First, as noted above, dividing a problem into cases only yields a
general solution if the cases are exhaustive. Exhaustiveness-checking
exposes logical errors.</p>
</li>
<li>
<p>Second, exhaustiveness-checking can act as a refactoring aid.  During
the development process, I often add new variants for a particular
<code>enum</code> definition.  The exhaustiveness-check helps points out all of
the <code>match</code> expressions where I only wrote the cases from the prior
version of the <code>enum</code> type.</p>
</li>
<li>
<p>Third, since <code>match</code> is an expression form, exhaustiveness ensures
that such expressions always either evaluate to a value of the correct type,
<em>or</em> jump elsewhere in the program.</p>
</li>
</ul>
<a class="header" href="print.html#jumping-out-of-a-match" id="jumping-out-of-a-match"><h4>Jumping out of a match</h4></a>
<p>The following code is a fixed version of the <code>suggest_guess_broken</code>
function we saw above; it directly illustrates &quot;jumping elsewhere&quot;:</p>
<pre><code class="language-rust ignore">fn suggest_guess_fixed(prior_guess: u32, answer: Answer) {
    let next_guess = match answer {
        Answer::Higher =&gt; prior_guess + 10,
        Answer::Lower  =&gt; prior_guess - 1,
        Answer::Bingo  =&gt; {
            println!(&quot;we won with {}!&quot;, prior_guess);
            return;
        }
    };
    println!(&quot;maybe try {} next&quot;, next_guess);
}

#[test]
fn demo_guess_fixed() {
    suggest_guess_fixed(10, Answer::Higher);
    suggest_guess_fixed(20, Answer::Lower);
    suggest_guess_fixed(19, Answer::Bingo);
}
</code></pre>
<p>The <code>suggest_guess_fixed</code> function illustrates that <code>match</code> can handle
some cases early (and then immediately return from the function),
while computing whatever values are needed from the remaining cases
and letting them fall through to the remainder of the function
body.</p>
<p>We can add such special case handling via <code>match</code> without fear
of overlooking a case, because <code>match</code> will force the case
analysis to be exhaustive.</p>
<a class="header" href="print.html#algebraic-data-types-and-structural-invariants" id="algebraic-data-types-and-structural-invariants"><h3>Algebraic Data Types and Structural Invariants</h3></a>
<p><a href="http://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic data types</a> succinctly describe classes of data and allow one
to encode rich structural invariants. Rust uses <code>enum</code> and <code>struct</code>
definitions for this purpose.</p>
<p>An <code>enum</code> type allows one to define mutually-exclusive classes of
values. The examples shown above used <code>enum</code> for simple symbolic tags,
but in Rust, enums can define much richer classes of data.</p>
<p>For example, a binary tree is either a leaf, or an internal node with
references to two child trees. Here is one way to encode a tree of
integers in Rust:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
enum BinaryTree {
    Leaf(i32),
    Node(Box&lt;BinaryTree&gt;, i32, Box&lt;BinaryTree&gt;)
}

#}</code></pre></pre>
<p>(The <code>Box&lt;V&gt;</code> type describes an owning reference to a heap-allocated
instance of <code>V</code>; if you own a <code>Box&lt;V&gt;</code>, then you also own the <code>V</code> it
contains, and can mutate it, lend out references to it, et cetera.
When you finish with the box and let it fall out of scope, it will
automatically clean up the resources associated with the
heap-allocated <code>V</code>.)</p>
<p>The above <code>enum</code> definition ensures that if we are given a <code>BinaryTree</code>, it
will always fall into one of the above two cases. One will never
encounter a <code>BinaryTree::Node</code> that does not have a left-hand child.
There is no need to check for null.</p>
<p>One <em>does</em> need to check whether a given <code>BinaryTree</code> is a <code>Leaf</code> or
is a <code>Node</code>, but the compiler statically ensures such checks are done:
you cannot accidentally interpret the data of a <code>Leaf</code> as if it were a
<code>Node</code>, nor vice versa.</p>
<p>Here is a function that sums all of the integers in a tree
using <code>match</code>.</p>
<pre><code class="language-rust ignore">fn tree_weight_v1(t: BinaryTree) -&gt; i32 {
    match t {
        BinaryTree::Leaf(payload) =&gt; payload,
        BinaryTree::Node(left, payload, right) =&gt; {
            tree_weight_v1(*left) + payload + tree_weight_v1(*right)
        }
    }
}

/// Returns tree that Looks like:
///
///      +----(4)---+
///      |          |
///   +-(2)-+      [5]
///   |     |   
///  [1]   [3]
///
fn sample_tree() -&gt; BinaryTree {
    let l1 = Box::new(BinaryTree::Leaf(1));
    let l3 = Box::new(BinaryTree::Leaf(3));
    let n2 = Box::new(BinaryTree::Node(l1, 2, l3));
    let l5 = Box::new(BinaryTree::Leaf(5));

    BinaryTree::Node(n2, 4, l5)
}

#[test]
fn tree_demo_1() {
    let tree = sample_tree();
    assert_eq!(tree_weight_v1(tree), (1 + 2 + 3) + 4 + 5);
}
</code></pre>
<p>Algebraic data types establish structural invariants that are strictly
enforced by the language. (Even richer representation invariants can
be maintained via the use of modules and privacy; but let us not
digress from the topic at hand.)</p>
<a class="header" href="print.html#both-expression--and-statement-oriented" id="both-expression--and-statement-oriented"><h3>Both expression- and statement-oriented</h3></a>
<p>Unlike many languages that offer pattern matching, Rust <em>embraces</em>
both statement- and expression-oriented programming.</p>
<p>Many functional languages that offer pattern matching encourage one to
write in an &quot;expression-oriented style&quot;, where the focus is always on
the values returned by evaluating combinations of expressions, and
side-effects are discouraged. This style contrasts with imperative
languages, which encourage a statement-oriented style that focuses on
sequences of commands executed solely for their side-effects.</p>
<p>Rust excels in supporting both styles.</p>
<p>Consider writing a function which maps a non-negative integer to a
string rendering it as an ordinal (&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, ...).</p>
<p>The following code uses range patterns to simplify things, but also,
it is written in a style similar to a <code>switch</code> in a statement-oriented
language like C (or C++, Java, et cetera), where the arms of the
<code>match</code> are executed for their side-effect alone:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn num_to_ordinal(x: u32) -&gt; String {
    let suffix;
    match (x % 10, x % 100) {
        (1, 1) | (1, 21...91) =&gt; {
            suffix = &quot;st&quot;;
        }
        (2, 2) | (2, 22...92) =&gt; {
            suffix = &quot;nd&quot;;
        }
        (3, 3) | (3, 23...93) =&gt; {
            suffix = &quot;rd&quot;;
        }
        _                     =&gt; {
            suffix = &quot;th&quot;;
        }
    }
    return format!(&quot;{}{}&quot;, x, suffix);
}

#[test]
fn test_num_to_ordinal() {
    assert_eq!(num_to_ordinal(   0),    &quot;0th&quot;);
    assert_eq!(num_to_ordinal(   1),    &quot;1st&quot;);
    assert_eq!(num_to_ordinal(  12),   &quot;12th&quot;);
    assert_eq!(num_to_ordinal(  22),   &quot;22nd&quot;);
    assert_eq!(num_to_ordinal(  43),   &quot;43rd&quot;);
    assert_eq!(num_to_ordinal(  67),   &quot;67th&quot;);
    assert_eq!(num_to_ordinal(1901), &quot;1901st&quot;);
}

#}</code></pre></pre>
<p>The Rust compiler accepts the above program. This is notable because
its static analyses ensure both:</p>
<ul>
<li>
<p><code>suffix</code> is always initialized before we run the <code>format!</code> at the end
of the function, and</p>
</li>
<li>
<p><code>suffix</code> is assigned <em>at most once</em> during the function's execution (because if
we could assign <code>suffix</code> multiple times, the compiler would force us
to mark <code>suffix</code> as mutable).</p>
</li>
</ul>
<p>To be clear, the above program certainly <em>can</em> be written in an
expression-oriented style in Rust; for example, like so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn num_to_ordinal_expr(x: u32) -&gt; String {
    format!(&quot;{}{}&quot;, x, match (x % 10, x % 100) {
        (1, 1) | (1, 21...91) =&gt; &quot;st&quot;,
        (2, 2) | (2, 22...92) =&gt; &quot;nd&quot;,
        (3, 3) | (3, 23...93) =&gt; &quot;rd&quot;,
        _                     =&gt; &quot;th&quot;
    })
}

#}</code></pre></pre>
<p>Sometimes expression-oriented style can yield very succinct code;
other times the style requires contortions that can be
avoided by writing in a statement-oriented style.
(The ability to return from one <code>match</code> arm in the
<code>suggest_guess_fixed</code> function <a href="print.html#jumping-out-of-a-match">earlier</a> was an example of this.)</p>
<p>Each of the styles has its use cases. Crucially, switching to a
statement-oriented style in Rust does not sacrifice every other
feature that Rust provides, such as the guarantee that a non-<code>mut</code>
binding is assigned at most once.</p>
<p>An important case where this arises is when one wants to
initialize some state and then borrow from it, but only on
<em>some</em> control-flow branches.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn sometimes_initialize(input: i32) {
    let string: String; // a dynamically-constructed string value
    let borrowed: &amp;str; // a reference to string data
    match input {
        0...100 =&gt; {
            // Construct a String on the fly...
            string = format!(&quot;input prints as {}&quot;, input);
            // ... and then borrow from inside it.
            borrowed = &amp;string[6..];
        }
        _ =&gt; {
            // String literals are *already* borrowed references
            borrowed = &quot;expected between 0 and 100&quot;;
        }
    }
    println!(&quot;borrowed: {}&quot;, borrowed);

    // Below would cause compile-time error if uncommented...

    // println!(&quot;string: {}&quot;, string);

    // ...namely: error: use of possibly uninitialized variable: `string`
}

#[test]
fn demo_sometimes_initialize() {
    sometimes_initialize(23);  // this invocation will initialize `string`
    sometimes_initialize(123); // this one will not
}

#}</code></pre></pre>
<p>The interesting thing about the above code is that after the <code>match</code>,
we are not allowed to directly access <code>string</code>, because the compiler
requires that the variable be initialized on every path through the
program before it can be accessed.
At the same time, we <em>can</em>, via <code>borrowed</code>, access data that
may held <em>within</em> <code>string</code>, because a reference to that data is held by the
<code>borrowed</code> variable when we go through the first match arm, and we
ensure <code>borrowed</code> itself is initialized on every execution path
through the program that reaches the <code>println!</code> that uses <code>borrowed</code>.</p>
<p>(The compiler ensures that no outstanding borrows of the
<code>string</code> data could possibly outlive <code>string</code> itself, and the
generated code ensures that at the end of the scope of <code>string</code>, its
data is deallocated if it was previously initialized.)</p>
<p>In short, for soundness, the Rust language ensures that data is always
initialized before it is referenced, but the designers have strived to
avoid requiring artificial coding patterns adopted solely to placate
Rust's static analyses (such as requiring one to initialize <code>string</code>
above with some dummy data, or requiring an expression-oriented style).</p>
<a class="header" href="print.html#matching-without-moving" id="matching-without-moving"><h3>Matching without moving</h3></a>
<p>Matching an input can <em>borrow</em> input substructure, without taking
ownership; this is crucial for matching a reference (e.g. a value of
type <code>&amp;T</code>).</p>
<p>The <a href="print.html#algebraic-data-types-and-structural-invariants">&quot;Algebraic Data Types&quot; section</a> above described a tree datatype, and
showed a program that computed the sum of the integers in a tree
instance.</p>
<p>That version of <code>tree_weight</code> has one big downside, however: it takes
its input tree by value. Once you pass a tree to <code>tree_weight_v1</code>, that
tree is <em>gone</em> (as in, deallocated).</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[test]
fn tree_demo_v1_fails() {
    let tree = sample_tree();
    assert_eq!(tree_weight_v1(tree), (1 + 2 + 3) + 4 + 5);

    // If you uncomment this line below ...
    
    // assert_eq!(tree_weight_v1(tree), (1 + 2 + 3) + 4 + 5);

    // ... you will get: error: use of moved value: `tree`
}

#}</code></pre></pre>
<p>This is <em>not</em> a consequence, however, of using <code>match</code>; it is rather
a consequence of the function signature that was chosen:</p>
<pre><code class="language-rust ignore">fn tree_weight_v1(t: BinaryTree) -&gt; i32 { 0 }
//                   ^~~~~~~~~~ this means this function takes ownership of `t`
</code></pre>
<p>In fact, in Rust, <code>match</code> is designed to work quite well <em>without</em>
taking ownership. In particular, the input to <code>match</code> is an <em><a href="https://doc.rust-lang.org/reference.html#lvalues,-rvalues-and-temporaries">L-value</a>
expression</em>; this means that the input expression is evaluated to a
<em>memory location</em> where the value lives.
<code>match</code> works by doing this evaluation and then
inspecting the data at that memory location.</p>
<p>(If the input expression is a variable name or a field/pointer
dereference, then the L-value is just the location of that variable or
field/memory.  If the input expression is a function call or other
operation that generates an unnamed temporary value, then it will be
conceptually stored in a temporary area, and that is the memory
location that <code>match</code> will inspect.)</p>
<p>So, if we want a version of <code>tree_weight</code> that merely borrows a tree
rather than taking ownership of it, then we will need to make use of
this feature of Rust's <code>match</code>.</p>
<pre><code class="language-rust ignore">fn tree_weight_v2(t: &amp;BinaryTree) -&gt; i32 {
    //               ^~~~~~~~~~~ The `&amp;` means we are *borrowing* the tree
    match *t {
        BinaryTree::Leaf(payload) =&gt; payload,
        BinaryTree::Node(ref left, payload, ref right) =&gt; {
            tree_weight_v2(left) + payload + tree_weight_v2(right)
        }
    }
}

#[test]
fn tree_demo_2() {
    let tree = sample_tree();
    assert_eq!(tree_weight_v2(&amp;tree), (1 + 2 + 3) + 4 + 5);
}
</code></pre>
<p>The function <code>tree_weight_v2</code> looks very much like <code>tree_weight_v1</code>.
The only differences are: we take <code>t</code> as a borrowed reference (the <code>&amp;</code>
in its type), we added a dereference <code>*t</code>, and,
importantly, we use <code>ref</code>-bindings for <code>left</code> and
<code>right</code> in the <code>Node</code> case.</p>
<p>The dereference <code>*t</code>, interpreted as an L-value expression, is just
extracting the memory address where the <code>BinaryTree</code> is represented
(since the <code>t: &amp;BinaryTree</code> is just a <em>reference</em> to that data in
memory). The <code>*t</code> here is not making a copy of the tree, nor moving it
to a new temporary location, because <code>match</code> is treating it as an
L-value.</p>
<p>The only piece left is the <code>ref</code>-binding, which
is a crucial part of how destructuring bind of
L-values works.</p>
<p>First, let us carefully state the meaning of a <em>non-ref</em> binding:</p>
<ul>
<li>
<p>When matching a value of type <code>T</code>, an identifier pattern <code>i</code> will, on
a successful match, <em>move</em> the value out of the original input and
into <code>i</code>. Thus we can always conclude in such a case that <code>i</code> has type
<code>T</code> (or more succinctly, &quot;<code>i: T</code>&quot;).</p>
<p>For some types <code>T</code>, known as <em>copyable</em> <code>T</code> (also pronounced &quot;<code>T</code>
implements <code>Copy</code>&quot;), the value will in fact be copied into <code>i</code> for such
identifier patterns. (Note that in general, an arbitrary type <code>T</code> is not copyable.)</p>
<p>Either way, such pattern bindings do mean that the variable <code>i</code> has
<em>ownership</em> of a value of type <code>T</code>.</p>
</li>
</ul>
<p>Thus, the bindings of <code>payload</code> in <code>tree_weight_v2</code> both have type
<code>i32</code>; the <code>i32</code> type implements <code>Copy</code>, so the weight is copied into
<code>payload</code> in both arms.</p>
<p>Now we are ready to state what a ref-binding is:</p>
<ul>
<li>When matching an L-value of type <code>T</code>, a <code>ref</code>-pattern <code>ref i</code>
will, on a successful match, merely <em>borrow</em> a reference into the
matched data. In other words, a successful <code>ref i</code> match of a value of
type <code>T</code> will imply that <code>i</code> has the type of a <em>reference</em> to <code>T</code>
(or more succinctly, &quot;<code>i: &amp;T</code>&quot;).</li>
</ul>
<p>Thus, in the <code>Node</code> arm of
<code>tree_weight_v2</code>, <code>left</code> will be a reference to the left-hand box (which
holds a tree), and <code>right</code> will likewise reference the right-hand tree.</p>
<p>We can pass these borrowed references to trees into the recursive calls to <code>tree_weight_v2</code>,
as the code demonstrates.</p>
<p>Likewise, a <code>ref mut</code>-pattern (<code>ref mut i</code>) will, on a successful
match, borrow a <em>mutable reference</em> into the input: <code>i: &amp;mut T</code>. This allows
mutation and ensures there are no other active references to that data
at the same time. A destructuring
binding form like <code>match</code> allows one to take mutable references to
disjoint parts of the data simultaneously.</p>
<p>This code demonstrates this concept by incrementing all of the
values in a given tree.</p>
<pre><code class="language-rust ignore">fn tree_grow(t: &amp;mut BinaryTree) {
    //          ^~~~~~~~~~~~~~~ `&amp;mut`: we have exclusive access to the tree
    match *t {
        BinaryTree::Leaf(ref mut payload) =&gt; *payload += 1,
        BinaryTree::Node(ref mut left, ref mut payload, ref mut right) =&gt; {
            tree_grow(left);
            *payload += 1;
            tree_grow(right);
        }
    }
}

#[test]
fn tree_demo_3() {
    let mut tree = sample_tree();
    tree_grow(&amp;mut tree);
    assert_eq!(tree_weight_v2(&amp;tree), (2 + 3 + 4) + 5 + 6);
}
</code></pre>
<p>Note that the code above now binds <code>payload</code> by a <code>ref mut</code>-pattern;
if it did not use a <code>ref</code> pattern, then <code>payload</code> would be bound to a
local copy of the integer, while we want to modify the actual integer
<em>in the tree itself</em>. Thus we need a reference to that integer.</p>
<p>Note also that the code is able to bind <code>left</code> and <code>right</code>
simultaneously in the <code>Node</code> arm. The compiler knows that the two
values cannot alias, and thus it allows both <code>&amp;mut</code>-references to live
simultaneously.</p>
<a class="header" href="print.html#conclusion" id="conclusion"><h2>Conclusion</h2></a>
<p>Rust takes the ideas of algebraic data types and pattern matching
pioneered by the functional programming languages, and adapts them to
imperative programming styles and Rust's own ownership and borrowing
systems. The <code>enum</code> and <code>match</code> forms provide clean data definitions
and expressive power, while static analysis ensures that the resulting
programs are safe.</p>
<p>For more information
on details that were not covered here, such as:</p>
<ul>
<li>
<p>how to say <code>Higher</code> instead of <code>Answer::Higher</code> in a pattern,</p>
</li>
<li>
<p>defining new named constants,</p>
</li>
<li>
<p>binding via <code>ident @ pattern</code>, or</p>
</li>
<li>
<p>the potentially subtle difference between <code>{ let id = expr; ... }</code> versus <code>match expr { id =&gt; { ... } }</code>,</p>
</li>
</ul>
<p>consult the Rust
<a href="https://doc.rust-lang.org/">documentation</a>, or quiz our awesome community (in <code>#rust</code> on IRC, or in
the <a href="http://users.rust-lang.org/">user group</a>).</p>
<p>(Many thanks to those who helped review this post, especially Aaron Turon
and Niko Matsakis, as well as
<code>Mutabah</code>, <code>proc</code>, <code>libfud</code>, <code>asQuirrel</code>, and <code>annodomini</code> from <code>#rust</code>.)</p>
<hr />
<p>layout: post
title: &quot;Reading Rust Function Signatures&quot;
author: &quot;Andrew Hobden&quot;
tags:</p>
<ul>
<li>Rust</li>
<li>Tutorials</li>
</ul>
<hr />
<p>In Rust, function signatures tell a story. Just from glancing at the signature of a function an experienced Rust user can tell much of the functions behaivor.</p>
<p>In this article we'll explore some signatures and talk about how to read them and extract information from them. While exploring, you can find many great function signature examples in the <a href="https://doc.rust-lang.org/stable/std/">Rust API docs</a>. You can play around on the <a href="https://play.rust-lang.org/">Playpen</a>.</p>
<p>This article assumes some knowledge of Rust, glossing over a bit of the <a href="https://doc.rust-lang.org/stable/book/README.html">book</a> should be quite sufficient if you are lacking that but have programmed before.</p>
<p>If you're used to programming in something like Python or Javascript, this all may seem a bit foreign to you. I hope by the end of it that you're convinced this additional information is both a good thing, and that it is not something you often have in dynamically typed languages.</p>
<p>If you're used to C++, C, or the other systemsy languages hopefully this should all seem very familiar, despite the syntax differences. Ideally by the end of your article you'll think more about your function signatures as you write them!</p>
<a class="header" href="print.html#baby-steps" id="baby-steps"><h1>Baby Steps</h1></a>
<p>Your first function definition in Rust almost definitely looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {}
</code></pre></pre>
<p>So since you've already most likely wrote this let's start here!</p>
<ul>
<li><code>fn</code>: is the syntax which tells Rust we're declaring a function.</li>
<li><code>main</code>: is the name of the function. <code>main</code> is special because it's what the program invokes when built and run as a binary. Function names are always <code>snake_case</code> and not <code>camelCase</code>.</li>
<li><code>()</code>: Is the arguments list. In this case, <code>main</code> accepts no arguments.</li>
<li><code>{}</code>: Are the delimiters for the inside of a function. In this case, it's empty.</li>
</ul>
<p>So what would we write for a function that does nothing useful?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn do_nothing_useful() {}

#}</code></pre></pre>
<p>Great, now you too can do nothing useful!</p>
<a class="header" href="print.html#visibility" id="visibility"><h1>Visibility</h1></a>
<p>By default, all functions are private and cannot be used outside of the module they are in. Making them usable by a different module is simple.</p>
<pre><pre class="playpen"><code class="language-rust">mod dog {
    fn private_function() {}
    pub fn public_function() {}
}

// Optional to avoid `foo::`
use dog::public_function;

fn main() {
    dog::public_function();
    // With `use`
    public_function();
}
</code></pre></pre>
<p>Like mutability, Rust is conservative in its assumptions about things like visibility. If you try to use a private function the compiler will let you know and help point you to where you need to make the function public.</p>
<p>If you have a function like <code>foo::bar::baz::rad()</code> in your project and want to make it usable as <code>foo::rad()</code> add <code>pub use bar::baz::rad;</code> to your <code>foo</code> module. This is called re-exporting.</p>
<a class="header" href="print.html#simple-parameters" id="simple-parameters"><h1>Simple Parameters</h1></a>
<p>No longer happy with <code>do_nothing_useful()</code> you decide to adopt a dog. Good for you! Now you have a new problem, you have to walk it and play with it!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn walk_dog(dog_name: String) {}
fn play_with(dog_name: String, game_name: String) {}

#}</code></pre></pre>
<p>Parameters are declared <code>variable_name: Type</code>, and are comma seperated. But c'mon! Our dog is a lot more than just a <code>String</code>! Good news, you can use your own types too.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
struct Dog;  // Let's not go overboard.
struct Game; // Simple types in demos!

fn walk_dog(dog: Dog) {}
fn play_with(dog: Dog, game: Game) {}

#}</code></pre></pre>
<p>Great, looking better already. Let's get that awesome day started.</p>
<pre><code class="language-rust ignore">fn main() {
    let rover = Dog;
    walk_dog(rover);

    let fetch = Game;
    play_with(rover, fetch); // Compiler Error!
}
</code></pre>
<p>Whoa whoa! That's a perfectly good day the compiler is totally <em>ruining</em> for us! Rover is going to be super sad.</p>
<p>Let's look at the error:</p>
<pre><code class="language-ignore">&lt;anon&gt;:11:15: 11:20 error: use of moved value: `rover`
&lt;anon&gt;:11     play_with(rover, fetch);
                        ^~~~~
&lt;anon&gt;:9:14: 9:19 note: `rover` moved here because it has type `Dog`, which is non-copyable
&lt;anon&gt;:9     walk_dog(rover);
                      ^~~~~
</code></pre>
<p>Here the compiler is telling us that <code>rover</code> was <em>moved</em> when we passed it into <code>walk_dog()</code>. That's because <code>fn walk_dog(dog: Dog) {}</code> accepts a <code>Dog</code> value and we haven't tell the compiler they are copyable! Values with <code>Copy</code> are implictly copied when passed to functions. You can make something <code>Copy</code> by adding <code>#[derive(Copy)]</code> above the declaration.</p>
<p><strong>We're going to keep <code>Dog</code> not copyable because, gosh darnit, you can't copy dogs.</strong> So how do we fix this?</p>
<p>We could clone <code>rover</code>. But our <code>Dog</code> struct isn't <code>Clone</code> either! <code>Clone</code> means we can explicitly make a copy of an object. You can make something <code>Clone</code> just like you did as <code>Copy</code>. To clone our dog you can do <code>rover.clone()</code></p>
<p>But really neither of those possible solutions solved the real problem: <em>We want to walk and play with the same dog!</em></p>
<a class="header" href="print.html#borrowing" id="borrowing"><h1>Borrowing</h1></a>
<blockquote>
<p>Can I borrow your dog?</p>
</blockquote>
<p>Instead of moving our <code>Dog</code> into the <code>walk_dog()</code> function we really just want to <em>lend</em> the function our <code>Dog</code>. When you walk your dog it (generally) ends up coming back to the house with you, right?</p>
<p>Rust uses <code>&amp;</code> to symbolize a borrow. Borrowing something tells the compiler that when the function is done the ownership of the value returns back to the caller.</p>
<pre><code class="language-rust ignore">fn walk_dog(dog: &amp;Dog) {}
fn play_with(dog: &amp;Dog, game: Game) {}
</code></pre>
<p>There are immutable borrows as well as mutable borrows (<code>&amp;mut</code>). You can have an immutable borrow passed to any number of things at once, and a mutable borrow only passed to one thing at a time. This provides data safety.</p>
<p>So our new borrowing functions don't really cut it, do they? We can't even mutate the <code>Dog</code>! Let's try anyways to see the error message.</p>
<pre><code class="language-rust ignore">struct Dog {
    walked: bool
}

fn walk_dog(dog: &amp;Dog) {
    dog.walked = true;
}

fn main() {
    let rover = Dog { walked: false };
    walk_dog(&amp;rover);
    assert_eq!(rover.walked, true);
}
</code></pre>
<p>As we expected:</p>
<pre><code class="language-ignore">&lt;anon&gt;:6:5: 6:22 error: cannot assign to immutable field `dog.walked`
&lt;anon&gt;:6     dog.walked = true;
             ^~~~~~~~~~~~~~~~~
error: aborting due to previous error
</code></pre>
<p>Changing the function signature to <code>fn walk_dog(dog: &amp;mut Dog) {}</code> and updating our <code>main()</code> we can solve this.</p>
<pre><code class="language-rust ignore">fn main() {
    let mut rover = Dog { walked: false };
    walk_dog(&amp;mut rover);
    assert_eq!(rover.walked, true);
}
</code></pre>
<p>As you can see, the function signature tells the programmer <em>if a value is mutable</em> and <em>if the value is consumed or referenced</em>.</p>
<a class="header" href="print.html#returning" id="returning"><h1>Returning</h1></a>
<p>Let's revisit exactly <em>how</em> we get Rover, because thats how we can explore return types! Let's say we want a function <code>adopt_dog()</code> which takes a name and gives us a <code>Dog</code>.</p>
<pre><pre class="playpen"><code class="language-rust">struct Dog {
    name: String,
    walked: bool,
}

fn adopt_dog(name: String) -&gt; Dog {
    Dog { name: name, walked: false }
}

fn main() {
    let rover = adopt_dog(String::from(&quot;Rover&quot;));
    assert_eq!(rover.name, &quot;Rover&quot;);
}
</code></pre></pre>
<p>So the <code>-&gt; Dog</code> part of the function signature tells us that the function returns a <code>Dog</code>. Note that the <code>name</code> is <em>moved</em> in and given to the dog, not copied or cloned.</p>
<a class="header" href="print.html#inside-traits" id="inside-traits"><h1>Inside Traits</h1></a>
<p>If you're implementing functions in a trait you also have access the following two tools:</p>
<ul>
<li>The <code>Self</code> return type which represents the current type.</li>
<li>The <code>self</code> parameter which specifies the borrowing/moving/mutability of the structure instance. In <code>walk()</code> below we take a mutable borrow, a bare <code>self</code> moves the value.</li>
</ul>
<p>An example:</p>
<pre><code class="language-rust ignore">// ... `Dog` struct from before.
impl Dog {
    pub fn adopt(name: String) -&gt; Self {
        Dog { name: name, walked: false }
    }
    pub fn walk(&amp;mut self) {
        self.walked = true
    }
}

fn main() {
    let mut rover = Dog::adopt(String::from(&quot;Rover&quot;));
    assert_eq!(rover.name, &quot;Rover&quot;);
    rover.walk();
    assert_eq!(rover.walked, true);
}
</code></pre>
<a class="header" href="print.html#generics-1" id="generics-1"><h1>Generics</h1></a>
<p>Let's face it, there are a lot of different kinds of dogs! But moreso, there are a lot of types of animals! Some of these we might want to walk too, like our <code>Bear</code>.</p>
<p>Generics let us do this. We can have a <code>Dog</code> and <code>Bear</code> struct that implement the <code>Walk</code> trait, then have a <code>walk_pet()</code> function accept any <code>Walk</code> traited structure!</p>
<p>Generics are specified to functions in between the name and the parameters using sharp brackets. The important thing to note about generics is when you're accepting a generic <em>you may only use the functions from the constraints</em>. This means that if you pass a <code>Read</code> to a function that wants <code>Write</code>, it still can't <code>Read</code> in it unless the constraints include it.</p>
<pre><pre class="playpen"><code class="language-rust">struct Dog { walked: bool, }
struct Bear { walked: bool, }

trait Walk {
    fn walk(&amp;mut self);
}
impl Walk for Dog {
    fn walk(&amp;mut self) {
        self.walked = true
    }
}
impl Walk for Bear {
    fn walk(&amp;mut self) {
        self.walked = true
    }
}

fn walk_pet&lt;W: Walk&gt;(pet: &amp;mut W) {
    // Try setting `pet.walked` here!
    // You can't!
    pet.walk();
}

fn walk_pet_2(pet: &amp;mut Walk) {
    // Try setting `pet.walked` here!
    // You can't!
    pet.walk();
}

fn main() {
    let mut rover = Dog { walked: false, };
    walk_pet(&amp;mut rover);
    assert_eq!(rover.walked, true);
}
</code></pre></pre>
<p>You can also use a different <code>where</code> syntax as function signatures with complex generics can get rather long.</p>
<pre><code class="language-rust ignore">fn walk_pet&lt;W&gt;(pet: &amp;mut W)
where W: Walk {
    pet.walk();
}
</code></pre>
<p>If you have multiple generics you can comma seperate them in both cases. If you'd like more than one trait contraint you can use <code>where W: Walk + Read</code> or <code>&lt;W: Walk + Read&gt;</code>.</p>
<pre><code class="language-rust ignore">fn stuff&lt;R, W&gt;(r: &amp;R, w: &amp;mut W)
where W: Write, R: Read + Clone {}
</code></pre>
<p>Look at all of the information you can derive from that function signature! It's not helpfully named but you can still tell <em>almost for sure</em> what it does!</p>
<p>There are also these crazy things called <strong>Associated Types</strong> which are used in stuff like <code>Iterator</code>. When being written in a signature you want to use something like <code>Iterator&lt;Item=Dog&gt;</code> to say an iterator of <code>Dog</code>s.</p>
<a class="header" href="print.html#passing-functions" id="passing-functions"><h1>Passing Functions</h1></a>
<p>Sometimes it's desirable to pass functions into other functions. In Rust, accepting a function as an argument is fairly straightforward. Functions have traits and they are passed like generics!</p>
<blockquote>
<p>You should definitely use the <code>where</code> syntax here.</p>
</blockquote>
<pre><code class="language-rust ignore">struct Dog {
    walked: bool
}

fn do_with&lt;F&gt;(dog: &amp;mut Dog, action: F)
where F: Fn(&amp;mut Dog) {
    action(dog);
}

fn walk(dog: &amp;mut Dog) {
    dog.walked = true;
}

fn main() {
    let mut rover = Dog { walked: false, };
    // Fn
    do_with(&amp;mut rover, walk);
    // Closure
    do_with(&amp;mut rover, |dog| dog.walked = true);
}
</code></pre>
<p>Functions in Rust implement traits which determine where (and how) they are passed:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/core/ops/trait.FnOnce.html"><code>FnOnce</code></a> - Takes a by-value reciever.</li>
<li><a href="https://doc.rust-lang.org/stable/core/ops/trait.FnMut.html"><code>FnMut</code></a> - Takes a mutable reciever.</li>
<li><a href="https://doc.rust-lang.org/stable/core/ops/trait.Fn.html"><code>Fn</code></a> - Takes a immutable reciever.</li>
</ul>
<p>A particular <a href="http://stackoverflow.com/a/30232500/2084424">Stack Overflow answer</a> summises the differences very well:</p>
<blockquote>
<p>A closure <code>|...| ...</code> will automatically implement as many of those as it can.</p>
</blockquote>
<blockquote>
<ul>
<li>All closures implement <code>FnOnce</code>: a closure that can't be called once doesn't deserve the name. Note that if a closure only implements <code>FnOnce</code>, it can be called only once.</li>
<li>Closures that don't move out of their captures implement <code>FnMut</code>, allowing them to be called more than once (if there is unaliased access to the function object).</li>
<li>Closures that don't need unique/mutable access to their captures implement <code>Fn</code>, allowing them to be called essentially everywhere.</li>
</ul>
</blockquote>
<p>Essentially, the differences between the different types is how they interact with their environment. In my experience, you only <em>really</em> need to worry about the distinction for Closures, which may capture variables in scope (in our above example, the <code>main()</code> function).</p>
<p>Have no fear, though! The compiler messages when one type is provided when another are needed are very helpful!</p>
<a class="header" href="print.html#lifetimes" id="lifetimes"><h1>Lifetimes</h1></a>
<p>So, you're probably feeling pretty good about yourself right now. I mean, look at that scrollbar, it's almost to the bottom of the page! You'll be a Rust function signature <strong>master</strong> in no time!</p>
<p>Let's finish up with a bit of talk about lifetimes because you'll eventually come across them and likely get quite confused.</p>
<blockquote>
<p>Let me be honest with you upfront here. Lifetimes are an arcane art to me. I used them a bit back in 0.7-0.10 and then I haven't really had to use them since. If you know really anything at all about them you're much more qualified to write this section than I am.</p>
</blockquote>
<p>Modern Rust has a really robust and effective <em>lifetime ellision</em> which removes the vast majority of lifetime gymnastics we used to need to concern ourselves with. But <em>when</em> you do things can start to untangle.</p>
<p>So, if you start dealing with a lot of lifetimes, your first step should really be to <strong>sit back and think about it</strong>. Unless your code is quite complex it's quite likely you won't need to deal with lifetimes. If you're bumping into lifetimes in a simple example your notion of the problem is probably <strong>incorrect</strong>.</p>
<p>Here is a function with lifetimes from <a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.as_slice"><code>Option</code>'s implementation</a>.</p>
<pre><code class="language-rust ignore">as_slice&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a [T]
</code></pre>
<p>Lifetimes are denoted by the tick (<code>'</code>) and given a name. In this case, <code>'a</code> but they can also be things like <code>'burrito</code> if you prefer inside jokes. Essentially what this is saying is:</p>
<blockquote>
<p>The lifetime of the <code>Option&lt;T&gt;</code> this is called upon is the same as the lifetime of the returned <code>[T]</code></p>
</blockquote>
<p>Great! I'm really not qualified to write anymore about lifetimes but if you have anything to add let me know and I'll credit you for sure.</p>
<a class="header" href="print.html#challenge-time" id="challenge-time"><h1>Challenge Time</h1></a>
<p>Below, you'll find a set of functions pulled from the standard library along with links to their documentation. Can you tell from their function signature what they do? (For added fun, I've removed the function name!)</p>
<pre><code class="language-rust ignore">// In `File`
fn name&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;File&gt;
</code></pre>
<p><a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create">Source</a></p>
<pre><code class="language-rust ignore">// In `Option&lt;T&gt;`
fn name&lt;E, T&gt;(self, err: E) -&gt; Result&lt;T, E&gt;
</code></pre>
<p><a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.ok_or">Source</a></p>
<pre><code class="language-rust ignore">// In `Iterator&lt;Item=T&gt;`
fn name&lt;B: FromIterator&lt;Self::Item&gt;&gt;(self) -&gt; B
where Self: Sized
</code></pre>
<p><a href="https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html#method.collect">Source</a></p>
<pre><code class="language-rust ignore">// In `Iterator&lt;Item=T&gt;`
fn name&lt;B, F&gt;(self, init: B, f: F) -&gt; B
where Self: Sized, F: FnMut(B, Self::Item) -&gt; B
</code></pre>
<p><a href="https://doc.rust-lang.org/stable/core/iter/trait.Iterator.html#method.fold">Source</a></p>
<pre><code class="language-rust ignore">// In `Result&lt;T,E&gt;`
fn name&lt;F, O: FnOnce(E) -&gt; F&gt;(self, op: O) -&gt; Result&lt;T, F&gt;
</code></pre>
<p><a href="https://doc.rust-lang.org/stable/core/result/enum.Result.html#method.map_err">Source</a></p>
<p>I hope that went <strong>fantastically</strong>, I was just over here cheering you on!</p>
<a class="header" href="print.html#finding-closure-in-rust" id="finding-closure-in-rust"><h1>Finding Closure in Rust</h1></a>
<p>Have you ever used an <a href="http://doc.rust-lang.org/std/iter/trait.Iterator.html">iterator adapter</a> in <a href="http://rust-lang.org">Rust</a>?
Called a method on <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>? <a href="http://doc.rust-lang.org/std/thread/fn.spawn.html">Spawned</a> a thread?
You've almost certainly used a <a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29">closure</a>. The design in Rust may seem
a little complicated, but it slides right into Rust's normal ownership
model so let's reinvent it from scratch.</p>
<p>The new design was introduced in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0114-closures.md">RFC 114</a>, moving Rust to a
model for closures similar to C++11's. The design builds on Rust's
standard trait system to allow for allocation-less
statically-dispatched closures, but also giving the choice to opt-in
to type-erasure and dynamic dispatch and the benefits that brings. It
incorporates elements of inference that &quot;just work&quot; by ensuring that
ownership works out.</p>
<blockquote>
<p>Steve Klabnik has written
<a href="http://doc.rust-lang.org/book/closures.html">some docs on Rust's closures</a> for the official
documentation. I've explicitly avoided reading it so far because
I've always wanted to write this, and I think it's better to give a
totally independent explanation while I have the chance. If
something is confusing here, maybe they help clarify.</p>
</blockquote>
<a class="header" href="print.html#whats-a-closure" id="whats-a-closure"><h2>What's a closure?</h2></a>
<p>In a sentence: a closure is a function that can directly use variables
from the scope in which it is defined. This is often described as the
closure <em>closing over</em> or <em>capturing</em> variables (the
<em>captures</em>). Collectively, the variables are called the <em>environment</em>.</p>
<p>Syntactically, a closure in Rust is an anonymous function<sup class="footnote-reference"><a href="print.html#anon">1</a></sup> value
defined a little like Ruby, with pipes: <code>|arguments...| body</code>. For
example, <code>|a, b| a + b</code> defines a closure that takes two arguments and
returns their sum. It's just like a normal function declaration, with
more inference:</p>
<pre><code class="language-rust ignore">// function:
fn foo(a: i32, b: i32) -&gt; i32 { a + b }
// closure:
      |a,      b|               a + b
</code></pre>
<p>Just like a normal function, they can be called with parentheses:
<code>closure(arguments...)</code>.</p>
<div class="footnote-definition" id="anon"><sup class="footnote-definition-label">1</sup>
<p>The Rust <code>|...| ...</code> syntax is more than just a closure: it's
an <a href="http://en.wikipedia.org/wiki/Anonymous_function">anonymous function</a>. In general, it's possible to have things
that are closures but aren't anonymous (e.g. in Python,
functions declared with <code>def foo():</code> are closures too, they
can refer to variables in any scopes in which the <code>def foo</code>
is contained). The anonymity refers to the fact that the
closure expression is a value, it's possible to just use it
directly and there's no separate <code>fn foo() { ... }</code> with the
function value referred to via <code>foo</code>.</p>
</div>
<p>To illustrate the capturing, this code snippet calls
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>map</code></a> on an <code>Option&lt;i32&gt;</code>, which will call a closure on
the <code>i32</code> (if it exists) and create a new <code>Option</code> containing the
return value of the call.</p>
<pre><code class="language-rust ignore">fn main() {
    let option = Some(2);

    let x = 3;
    // explicit types:
    let new: Option&lt;i32&gt; = option.map(|val: i32| -&gt; i32 { val + x });
    println!(&quot;{:?}&quot;, new); // Some(5)

    let y = 10;
    // inferred:
    let new2 = option.map(|val| val * y);
    println!(&quot;{:?}&quot;, new2); // Some(20)
}
</code></pre>
<p>The closures are capturing the <code>x</code> and <code>y</code> variables, allowing them to
be used while mapping. (To be more convincing, imagine they were only
known at runtime, so that one couldn't just write <code>val + 3</code> inside the
closure.)</p>
<a class="header" href="print.html#back-to-basics" id="back-to-basics"><h2>Back to basics</h2></a>
<p>Now that we have the semantics in mind, take a step back and riddle me
this: how would one implement that sort of generic <code>map</code> if Rust
didn't have closures?</p>
<p>The functionality of <code>Option::map</code> we're trying to duplicate is (equivalently):</p>
<pre><code class="language-rust ignore">fn map&lt;X, Y&gt;(option: Option&lt;X&gt;, transformer: ...) -&gt; Option&lt;Y&gt; {
    match option {
        Some(x) =&gt; Some(transformer(x)), // (closure syntax for now)
        None =&gt; None,
    }
}
</code></pre>
<p>We need to fill in the <code>...</code> with something that transforms an <code>X</code> into
a <code>Y</code>. The biggest constraint for perfectly replacing <code>Option::map</code> is
that it needs to be generic in some way, so that it works with
absolutely any way we wish to do the transformation. In Rust, that
calls for a generic bounded by a trait.</p>
<pre><code class="language-rust ignore">fn map&lt;X, Y, T&gt;(option: Option&lt;X&gt;, transform: T) -&gt; Option&lt;Y&gt;
    where T: /* the trait */
{
</code></pre>
<p>This trait needs to have a method that converts some specific type
into another. Hence there'll have to be form of type parameters to
allow the exact types to be specified in generic bounds like
<code>map</code>. There's two choices: generics in the trait definition (&quot;input
type parameters&quot;) and associated types (&quot;output type parameters&quot;). The
quoted names hint at the choices we should take: the type that gets
input into the transformation should be a generic in the trait, and
the type that is output by the transformation should be an associated
type.<sup class="footnote-reference"><a href="print.html#assoc-vs-not">2</a></sup></p>
<div class="footnote-definition" id="assoc-vs-not"><sup class="footnote-definition-label">2</sup>
<p>This choice is saying that transformers can be
overloaded by the starting type, but the ending type
is entirely determined by the pair of the transform
and the starting type. Using an associated type for
the return value is more restrictive (no overloading
on return type only) but it gives the compiler a much
easier time when inferring types. Using an associated
type for the input value too would be too
restrictive: it is very useful for the output type to
depend on the input type, e.g. a transformation <code>&amp;'a [i32]</code> to <code>&amp;'a i32</code> (by e.g. indexing) has the two
types connected via the generic lifetime <code>'a</code>.</p>
<p>So, our trait looks something like:</p>
<pre><code class="language-rust ignore">trait Transform&lt;Input&gt; {
    type Output;

    fn transform(/* self?? */, input: Input) -&gt; Self::Output;
}
</code></pre>
<p>The last question is what sort of <code>self</code> (if any) the method should
take?</p>
<p>The transformation should be able to incorporate arbitrary information
beyond what is contained in <code>Input</code>. Without any <code>self</code> argument, the
method would look like <code>fn transform(input: Input) -&gt; Self::Output</code>
and the operation could only depend on <code>Input</code> and global
variables (ick). So we do need one.</p>
<p>The most obvious options are by-reference <code>&amp;self</code>,
by-mutable-reference <code>&amp;mut self</code>, or by-value <code>self</code>. We want to allow
the users of <code>map</code> to have as much power as possible while still
enabling <code>map</code> to type-check. At a high-level <code>self</code> gives
<em>implementers</em> (i.e. the types users define to implement the trait)
the most flexibility, with <code>&amp;mut self</code> next and <code>&amp;self</code> the least
flexible. Conversely, <code>&amp;self</code> gives <em>consumers</em> of the trait
(i.e. functions with generics bounded by the trait) the most
flexibility, and <code>self</code> the least.</p>
<table><thead><tr><th align="right">             </th><th> <strong>Implementer</strong>                </th><th> <strong>Consumer</strong>                                 </th></tr></thead><tbody>
<tr><td align="right">      <code>self</code> </td><td> Can move out and mutate    </td><td> Can only call method once                       </td></tr>
<tr><td align="right"> <code>&amp;mut self</code> </td><td> Can't move out, can mutate </td><td> Can call many times, only with unique access </td></tr>
<tr><td align="right">     <code>&amp;self</code> </td><td> Can't move out or mutate   </td><td> Can call many times, with no restrictions       </td></tr>
</tbody></table>
<div class="join"></div>
<p>(&quot;Move out&quot; and &quot;mutate&quot; in the implementer column are referring to data stored inside <code>self</code>.)</p>
<p>Choosing between them is a balance, we usually want to chose the
highest row of the table that still allows the consumers to do what
they need to do, as that allows the external implementers to do as
much as possible.</p>
<p>Starting at the top of that table: we can try <code>self</code>. This gives <code>fn transform(self, input: Input) -&gt; Self::Output</code>. The by-value <code>self</code>
will consume ownership, and hence <code>transform</code> can only be called
once. Fortunately, <code>map</code> only needs to do the transformation once, so
by-value <code>self</code> works perfectly.</p>
<p>In summary, our <code>map</code> and its trait look like:</p>
<pre><code class="language-rust ignore">trait Transform&lt;Input&gt; {
    type Output;

    fn transform(self, input: Input) -&gt; Self::Output;
}

fn map&lt;X, Y, T&gt;(option: Option&lt;X&gt;, transform: T) -&gt; Option&lt;Y&gt;
    where T: Transform&lt;X, Output = Y&gt;
{
    match option {
        Some(x) =&gt; Some(transform.transform(x)),
        None =&gt; None,
    }
}
</code></pre>
</div>
<p>The example from before can then be reimplemented rather verbosely, by
creating structs and implementing <code>Transform</code> to do the appropriate
conversion for that struct.</p>
<pre><code class="language-rust ignore">// replacement for |val| val + x
struct Adder { x: i32 }

impl Transform&lt;i32&gt; for Adder {
    type Output = i32;

    // ignoring the `fn ... self`, this looks similar to |val| val + x
    fn transform(self, val: i32) -&gt; i32 {
        val + self.x
    }
}

// replacement for |val| val * y
struct Multiplier { y: i32 }

impl Transform&lt;i32&gt; for Multiplier {
    type Output = i32;

    // looks similar to |val| val * y
    fn transform(self, val: i32) -&gt; i32 {
        val * self.y
    }
}

fn main() {
    let option = Some(2);

    let x = 3;
    let new: Option&lt;i32&gt; = map(option, Adder { x: x });
    println!(&quot;{:?}&quot;, new); // Some(5)

    let y = 10;
    let new2 = map(option, Multiplier { y: y });
    println!(&quot;{:?}&quot;, new2); // Some(20)
}
</code></pre>
<p>We've manually implemented something that seems to have the same
semantics as Rust closures, using traits and some structs to store and
manipulate the captures. In fact, the struct has some uncanny
similarities to the &quot;environment&quot; of a closure: it stores a pile of
variables that need to be used in the body of <code>transform</code>.</p>
<a class="header" href="print.html#how-do-real-closures-work" id="how-do-real-closures-work"><h2>How do real closures work?</h2></a>
<p>Just like that, plus a little more flexibility and syntactic
sugar. The real definition of <code>Option::map</code> is:</p>
<pre><code class="language-rust ignore">impl&lt;X&gt; Option&lt;X&gt; {
    pub fn map&lt;Y, F: FnOnce(X) -&gt; Y&gt;(self, f: F) -&gt; Option&lt;Y&gt; {
        match self {
            Some(x) =&gt; Some(f(x)),
            None =&gt; None
        }
    }
}
</code></pre>
<p><code>FnOnce(X) -&gt; Y</code> is another name for our <code>Transform&lt;X, Output = Y&gt;</code>
bound, and, <code>f(x)</code> for <code>transform.transform(x)</code>.</p>
<p>There are three traits for closures, all of which provide the
<code>...(...)</code> call syntax (one could regard them as different kinds of
<code>operator()</code> in C++). They differ only by the <code>self</code> type of the call
method, and they cover all of the <code>self</code> options listed above.</p>
<ul>
<li><code>&amp;self</code> is <a href="http://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a></li>
<li><code>&amp;mut self</code> is <a href="http://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></li>
<li><code>self</code> is <a href="http://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnOnce</code></a></li>
</ul>
<p>These traits are covering exactly the three core ways to handle data
in Rust, so having each of them meshes perfectly with Rust's
type-system.</p>
<p>When you write <code>|args...| code...</code> the compiler will implicitly define
a unique new struct type storing the captured variables, and then
implement one of those traits using the closure's body, rewriting any
mentions of captured variables to go via the closure's
environment. The struct type doesn't have a user visible name, it is
purely internal to the compiler. When the program hits the closure
definition at runtime, it fills in an instance of struct and passes
that instance into whatever it needs to (like we did with our <code>map</code>
above).</p>
<p>There's two questions left:</p>
<ol>
<li>how are variables captured? (what type are the fields of the environment struct?)</li>
<li>which trait is used? (what type of <code>self</code> is used?)</li>
</ol>
<p>The compiler answers both by using some local rules to choose the
version that will give the most flexibility. The local rules are
designed to be able to be checked only knowing the definition
the closure, and the types of any variables it captures.<sup class="footnote-reference"><a href="print.html#i-think">3</a></sup></p>
<div class="footnote-definition" id="i-think"><sup class="footnote-definition-label">3</sup>
<p>This statement isn't precisely true in practice,
e.g. <code>rustc</code> will emit different errors if closures are
misused in certain equivalent-but-non-identical
ways. However, I believe these are just improved
diagnostics, not a fundamental language thing... however,
I'm not sure.</p>
<p>By &quot;flexibility&quot; I mean the compiler chooses the option that (it
thinks) will compile, but imposes the least on the programmer.</p>
<a class="header" href="print.html#structs-and-captures" id="structs-and-captures"><h3>Structs and captures</h3></a>
<p>If you're familiar with closures in C++11, you may recall the <code>[=]</code>
and <code>[&amp;]</code> capture lists: capture variables by-value<sup class="footnote-reference"><a href="print.html#copy">4</a></sup> and
by-reference respectively. Rust has similar capability: variables can
be captured by-value---the variable is moved into the closure
environment---or by-reference---a reference to the variable is stored
in the closure environment.</p>
</div>
<div class="footnote-definition" id="copy"><sup class="footnote-definition-label">4</sup>
<p>&quot;By-value&quot; in C++, including <code>[=]</code>, is really &quot;by-copy&quot; (with
some copy-elision rules to sometimes elide copies in certain
cases), whereas in Rust it is always &quot;by-move&quot;, more similar
to rvalue references in C++.</p>
<p>By default, the compiler looks at the closure body to see how captured
variables are used, and uses that to infers how variables should be
captured:</p>
<ul>
<li>if a captured variable is only ever used through a shared reference,
it is captured by <code>&amp;</code> reference,</li>
<li>if it used through a mutable reference (including assignment), it is
captured by <code>&amp;mut</code> reference,</li>
<li>if it is moved, it is forced to be captured by-value. (NB. using a
<a href="http://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> type
by-value only needs a <code>&amp;</code> reference, so this rule only applies to
non-<code>Copy</code> ones.)</li>
</ul>
<p>The algorithm seems a little non-trivial, but it matches exactly the
mental model of a practiced Rust programmer, using ownership/borrows
as precisely as it can. In fact, if a closure is &quot;non-escaping&quot;, that
is, never leaves the stack frame in which it is created, I believe
this algorithm is perfect: code will compile without needing any
annotations about captures.</p>
<p>To summarise, the compiler will capture variables in the way that is
least restrictive in terms of continued use outside the closure (<code>&amp;</code>
is preferred, then <code>&amp;mut</code> and lastly by-value), and that still works
for all their uses within the closure. This analysis happens on a
per-variable basis, e.g.:</p>
<pre><code class="language-rust ignore">struct T { ... }

fn by_value(_: T) {}
fn by_mut(_: &amp;mut T) {}
fn by_ref(_: &amp;T) {}

let x: T = ...;
let mut y: T = ...;
let mut z: T = ...;

let closure = || {
    by_ref(&amp;x);
    by_ref(&amp;y);
    by_ref(&amp;z);

    // forces `y` and `z` to be at least captured by `&amp;mut` reference
    by_mut(&amp;mut y);
    by_mut(&amp;mut z);

    // forces `z` to be captured by value
    by_value(z);
};
</code></pre>
<p>To focus on the flexibility: since <code>x</code> is only captured by shared
reference, it is legal for it be used while <code>closure</code> exists, and
since <code>y</code> is borrowed (by mutable reference) it can be used once
<code>closure</code> goes out of scope, but <code>z</code> cannot be used at all, even once
<code>closure</code> is gone, since it has been moved into the <code>closure</code> value.</p>
<p>The compiler would create code that looks a bit like:</p>
<pre><code class="language-rust ignore">struct Environment&lt;'x, 'y&gt; {
    x: &amp;'x T,
    y: &amp;'y mut T,
    z: T
}

/* impl of FnOnce for Environment */

let closure = Environment {
    x: &amp;x,
    y: &amp;mut y,
    z: z
};
</code></pre>
<p>The struct desugaring allows the full power of Rust's type system is
brought to bear on ensuring it isn't possible to accidentally get a
dangling reference or use freed memory or trigger any other memory
safety violation by misusing a closure. If there is problematic code,
the compiler will point it out.</p>
<a class="header" href="print.html#move-and-escape" id="move-and-escape"><h3><code>move</code> and escape</h3></a>
<p>I stated above that the inference is perfect for non-escaping
closures... which implies that it is not perfect for &quot;escaping&quot; ones.</p>
<p>If a closure is escaping, that is, if it might leave the stack frame
where it is created, it must not contain any references to values
inside that stack frame, since those references would be dangling when
the closure is used outside that frame: very bad. Fortunately the
compiler will emit an error if there's a risk of that, but returning
closures can be useful and so should be possible; for example<sup class="footnote-reference"><a href="print.html#trait-object">5</a></sup>:</p>
</div>
<div class="footnote-definition" id="trait-object"><sup class="footnote-definition-label">5</sup>
<p>Since closure types are unique and unnameable, the
only way to return one is via a trait object, at
least until Rust gets something like the &quot;abstract
return types&quot; of <a href="https://github.com/rust-lang/rfcs/pull/105">RFC 105</a>, something much
desired for handling closures. This is a little like
an interface-checked version of C++11's
<code>decltype(auto)</code>, which, I believe, was also partly
motivated by closures with unnameable types.</p>
<pre><code class="language-rust ignore">/// Returns a closure that will add `x` to its argument.
fn make_adder(x: i32) -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|y| x + y)
}

fn main() {
    let f = make_adder(3);

    println!(&quot;{}&quot;, f(1)); // 4
    println!(&quot;{}&quot;, f(10)); // 13
}
</code></pre>
<div class="join"></div>
<p>Looks good, except... it doesn't actually compile:</p>
<pre><code class="language-text">...:3:14: 3:23 error: closure may outlive the current function, but it borrows `x`, which is owned by the current function [E0373]
...:3     Box::new(|y| x + y)
                   ^~~~~~~~~
...:3:18: 3:19 note: `x` is borrowed here
...:3     Box::new(|y| x + y)
                       ^
</code></pre>
<p>The problem is clearer when everything is written as explicit structs:
<code>x</code> only needs to be captured by reference to be used with <code>+</code>, so the
compiler is inferring that the code can look like:</p>
<pre><code class="language-rust ignore">struct Closure&lt;'a&gt; {
    x: &amp;'a i32
}

/* impl of Fn for Closure */

fn make_adder(x: i32) -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(Closure { x: &amp;x })
}
</code></pre>
<p><code>x</code> goes out of scope at the end of <code>make_adder</code> so it is illegal to
return something that holds a reference to it.</p>
<p>So how do we fix it? Wouldn't it be nice if the compiler could tell
us...</p>
<p>Well, actually, I omitted the last two lines of the error message above:</p>
<pre><code class="language-text">...:3:14: 3:23 help: to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword, as shown:
...:      Box::new(move |y| x + y)
</code></pre>
<p>A new keyword! The <code>move</code> keyword can be placed in front of a closure
declaration, and overrides the inference to capture all variables by
value. Going back to the previous section, if the code used <code>let closure = move || { /* same code */ }</code> the environment struct would
look like:</p>
<pre><code class="language-rust ignore">struct Environment {
    x: T,
    y: T,
    z: T
}
</code></pre>
<p>Capturing entirely by value is also strictly more general than
capturing by reference: the reference types are first-class in Rust,
so &quot;capture by reference&quot; is the same as &quot;capture a reference by
value&quot;. Thus, unlike C++, there's little fundamental distinction
between capture by reference and by value, and the analysis Rust does
is not actually <em>necessary</em>: it just makes programmers' lives easier.</p>
<p>To demonstrate, the following code will have the same behaviour and
same environment as the first version, by capturing references using
<code>move</code>:</p>
<pre><code class="language-rust ignore">let x: T = ...;
let mut y: T = ...;
let mut z: T = ...;

let x_ref: &amp;T = &amp;x;
let y_mut: &amp;mut T = &amp;mut y;

let closure = move || {
    by_ref(x_ref);
    by_ref(&amp;*y_mut);
    by_ref(&amp;z);

    by_mut(y_mut);
    by_mut(&amp;mut z);

    by_value(z);
};
</code></pre>
<p>The set of variables that are captured is exactly those that are used
in the body of the closure, there's no fine-grained capture lists like
in C++11. The <code>[=]</code> capture list exists as the <code>move</code> keyword, but
that is all.</p>
<p>We can now solve the original problem of returning from <code>make_adder</code>:
by writing <code>move</code> we force the compiler to avoid any
implicit/additional references, ensuring that the closure isn't tied
to the stack frame of its birth. If we take the compiler's suggestion
and write <code>Box::new(move |y| x + y)</code>, the code inside the compiler
will look more like:</p>
<pre><code class="language-rust ignore">struct Closure {
    x: i32
}

/* impl of Fn for Closure */

fn make_adder(x: i32) -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(Closure { x: x })
}
</code></pre>
<p>It is clear that the compiler doesn't infer when <code>move</code> is required
(or else we wouldn't need to write it), but the fact that the <code>help</code>
message exists suggests that the compiler does know enough to infer
when <code>move</code> is necessary or not... in some cases. Unfortunately, doing
so in general in a reliable way (a <code>help</code> message can be
heuristic/best-effort, but inference built into the language cannot
be), would require more than just an analysis of the internals of the
closure body: it would require more complicated machinery to look at
how/where the closure value is used.</p>
</div>
<a class="header" href="print.html#traits-3" id="traits-3"><h3>Traits</h3></a>
<p>The actual &quot;function&quot; bit of closures are handled by the traits
mentioned above. The implicit struct types will also have implicit
implementations of some of those traits, exactly those traits that
will actually work for the type.</p>
<p>Let's start with an example: for the <code>make_adder</code> example, the <code>Fn</code>
trait is implemented for the implicit closure struct:</p>
<pre><code class="language-rust ignore">// (this is just illustrative, see the footnote for the gory details)
impl Fn(i32) -&gt; i32 for Closure {
    fn call(&amp;self, y: i32) -&gt; i32 {
    // |y|   x + y
        self.x + y
    }
}
</code></pre>
<div class="footnote-definition" id="invalid"><sup class="footnote-definition-label">6</sup>
<p>I wrote an invalid <code>Fn</code> implementation because the real
version is ugly and much less clear, and doesn't work with
stable compilers at the moment. But since you asked, here
is what's required:</p>
<pre><code class="language-rust ignore">        #![feature(unboxed_closures, core)]

        impl Fn&lt;(i32,)&gt; for Closure {
            extern &quot;rust-call&quot; fn call(&amp;self, (y,): (i32,)) -&gt; i32 {
                self.x + y
            }
        }
        impl FnMut&lt;(i32,)&gt; for Closure {
            extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: (i32,)) -&gt; i32 {
                self.call(args)
            }
        }
        impl FnOnce&lt;(i32,)&gt; for Closure {
            type Output = i32;
            extern &quot;rust-call&quot; fn call_once(self, args: (i32,)) -&gt; i32 {
                self.call(args)
            }
        }
</code></pre>
<p>Just looking at that, one might be able to guess at a few of the
reasons that manual implementations of the function traits aren't
stabilised for general use. The only way to create types
implementing those traits with the 1.0 compiler is with a closure
expression.</p>
<p>In reality, there are also implicit implementations<sup class="footnote-reference"><a href="print.html#invalid">6</a></sup> of
<code>FnMut</code> and <code>FnOnce</code> for <code>Closure</code>, but <code>Fn</code> is the &quot;fundamental&quot; one
for this closure.</p>
<p>There's three traits, and so seven non-empty sets of traits that <em>could</em><sup class="footnote-reference"><a href="print.html#inherit">7</a></sup> possibly be
implemented... but there's actually only three interesting
configurations:</p>
</div>
<div class="footnote-definition" id="inherit"><sup class="footnote-definition-label">7</sup>
<p>I'm ignoring the inheritance, which means that certain
sets are actually statically illegal, i.e., without other
constraints there are seven possibilities.</p>
<ul>
<li><code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code>,</li>
<li><code>FnMut</code> and <code>FnOnce</code>,</li>
<li>only <code>FnOnce</code>.</li>
</ul>
<p>Why? Well, the three closure traits are actually three nested sets:
every closure that implements <code>Fn</code> can also implement <code>FnMut</code> (if
<code>&amp;self</code> works, <code>&amp;mut self</code> also works; proof: <code>&amp;*self</code>), and similarly
every closure implementing <code>FnMut</code> can also implement <code>FnOnce</code>. This
hierarchy is enforced at the type level,
e.g. <a href="http://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>
has declaration:</p>
<pre><code class="language-rust ignore">pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    ...
}
</code></pre>
<div class="join"></div>
In words: anything that implements `FnMut` *must* also implement
`FnOnce`.
<p>There's no subtlety required when inferring what traits to implement
as the compiler can and will just implement <em>every</em> trait for which
the implementation is legal. This is in-keeping with the &quot;offer
maximum flexibility&quot; rule that was used for the inference of the
capture types, since more traits means more options. The subset nature
of the <code>Fn*</code> traits means that following this rule will always result
in one of the three sets listed above being implemented.</p>
<p>As an example, this code demonstrates a closure for which an
implementation of <code>Fn</code> is illegal but both <code>FnMut</code> and <code>FnOnce</code> are
fine.</p>
<pre><code class="language-rust ignore">let mut v = vec![];

// nice form
let closure = || v.push(1);

// explicit form
struct Environment&lt;'v&gt; {
    v: &amp;'v mut Vec&lt;i32&gt;
}

// let's try implementing `Fn`
impl&lt;'v&gt; Fn() for Environment&lt;'v&gt; {
    fn call(&amp;self) {
        self.v.push(1) // error: cannot borrow data mutably
    }
}
let closure = Environment { v: &amp;mut v };
</code></pre>
<p>It is illegal to mutate via a <code>&amp; &amp;mut ...</code>, and <code>&amp;self</code> is creating
that outer shared reference. If it was <code>&amp;mut self</code> or <code>self</code>, it would
be fine: the former is more flexible, so the compiler implements
<code>FnMut</code> for <code>closure</code> (and also <code>FnOnce</code>).</p>
<p>Similarly, if <code>closure</code> was to be <code>|| drop(v);</code>---that is, move out of
<code>v</code>---it would be illegal to implement either <code>Fn</code> or <code>FnMut</code>, since
the <code>&amp;self</code> (respectively <code>&amp;mut self</code>) means that the method would be
trying to steal ownership out of borrowed data: criminal.</p>
<a class="header" href="print.html#flexibility" id="flexibility"><h2>Flexibility</h2></a>
<p>One of Rust's goals is to leave choice in the hands of the programmer,
allowing their code to be efficient, with abstractions compiling away
and just leaving fast machine code. The design of closures to use
unique struct types and traits/generics is key to this.</p>
<p>Since each closure has its own type, there's no compulsory need for
heap allocation when using closures: as demonstrated above, the
captures can just be placed directly into the struct value. This is a
property Rust shares with C++11, allowing closures to be used in
essentially any environment, including bare-metal environments.</p>
<p>The unique types does mean that one can't use different closures
together automatically, e.g. one can't create a vector of several
distinct closures. They may have different sizes and require different
invocations (different closures correspond to different internal code,
so a different function to call). Fortunately, the use of traits to
abstract over the closure types means one can opt-in to these features
and their benefits &quot;on demand&quot;, via [trait objects][pito]: returning
the <code>Box&lt;Fn(i32) -&gt; i32&gt;</code> above used a trait object.</p>
<pre><code class="language-rust ignore">let mut closures: Vec&lt;Box&lt;Fn()&gt;&gt; = vec![];

let text = &quot;second&quot;;

closures.push(Box::new(|| println!(&quot;first&quot;)));
closures.push(Box::new(|| println!(&quot;{}&quot;, text)));
closures.push(Box::new(|| println!(&quot;third&quot;)));

for f in &amp;closures {
    f(); // first / second / third
}
</code></pre>
<p>[pito]: {% post_url 2015-01-10-peeking-inside-trait-objects %}</p>
<p>An additional benefit to the approach of unique types and generics
means that, by default, the compiler has full information about what
closure calls are doing at each call site, and so has the choice to
perform key optimisations like inlining. For example, the following
snippets compile to the same code,</p>
<pre><code class="language-rust ignore">x.map(|z| z + 3)

match x {
    Some(z) =&gt; Some(z + 3),
    None =&gt; None
}
</code></pre>
<div class="join"></div>
<p>(When I tested it by placing them into separate functions in a single
binary, the compiler actually optimised the second function to a
direct call to the first.)</p>
<p>This is all due to how Rust implements generics via monomorphisation,
where generic functions are compiled for each way their type
parameters are chosen, explicitly substituting the generic type with a
concrete one. Unfortunately, this isn't always an optimisation, as it
can result in code bloat, where there are many similar copies of a
single function, which is again something that trait objects can
tackle: by using a trait object instead, one can use dynamically
dispatched closures to ensure there's only one copy of a function,
even if it is used with many different closures.</p>
<pre><code class="language-rust ignore">fn generic_closure&lt;F: Fn(i32)&gt;(f: F) {
    f(0);
    f(1);
}

generic_closure(|x| println!(&quot;{}&quot;, x)); // A
generic_closure(|x| { // B
    let y = x + 2;
    println!(&quot;{}&quot;, y);
});


fn closure_object(f: &amp;Fn(i32)) {
    f(0);
    f(1);
}

closure_object(&amp;|x| println!(&quot;{}&quot;, x));
closure_object(&amp;|x| {
    let y = x + 2;
    println!(&quot;{}&quot;, y);
});
</code></pre>
<p>The final binary will have two copies of <code>generic_closure</code>, one for
<code>A</code> and one for <code>B</code>, but only one copy of <code>closure_object</code>. In fact,
there are implementations of the <code>Fn*</code> traits for pointers, so one can
even use a trait object directly with <code>generic_closure</code>,
e.g. <code>generic_closure((&amp;|x| { ... }) as &amp;Fn(_))</code>: so users of
higher-order functions can choose which trade-off they want themselves.</p>
<p>All of this flexibility falls directly out of using traits<sup class="footnote-reference"><a href="print.html#stdfunction">8</a></sup> for
closures, and the separate parts are independent and very
compositional.</p>
</div>
<div class="footnote-definition" id="stdfunction"><sup class="footnote-definition-label">8</sup>
<p>C++ has a similar choice, with <code>std::function</code> able to
provide type erasure/dynamic dispatch for closure
types, although it requires separate definition as a
library type, and requires allocations. The Rust trait
objects are a simple building block in the language,
and don't require allocations (e.g. <code>&amp;Fn()</code> is a trait
object that can be created out of a pointer to the
stack).</p>
<p>The power closures offer allow one to build high-level, &quot;fluent&quot; APIs
without losing performance compared to writing out the details by
hand. The prime example of this is
<a href="http://doc.rust-lang.org/std/iter">iterators</a>: one can write long
chains of calls to adapters like <code>map</code> and <code>filter</code> which get
optimised down to efficient C-like code. (For example, I wrote
[a post][knn] that demonstrates this, and the situation has only
improved since then: the closure design described here was implemented
months later.)</p>
<p>[knn]: {% post_url 2014-06-10-comparing-knn-in-rust %}</p>
<a class="header" href="print.html#in-closing" id="in-closing"><h2>In closing</h2></a>
<p>Rust's C++11-inspired closures are powerful tools that allow for
high-level and efficient code to be build, marrying two properties
often in contention. The moving parts of Rust's closures are built
directly from the normal type system with traits, structs and
generics, which allows them to automatically gain features like heap
allocation and dynamic dispatch, but doesn't require them.</p>
<p>(Thanks to Steve Klabnik and Aaron Turon for providing feedback on a
draft, and many commenters on [/r/rust]({{ page.comments.r_rust }})
and on IRC for finding inaccuracies and improvements.)</p>
<hr />
<p>layout: default
title: &quot;Finding Closure in Rust&quot;
description: &gt;
Closures in Rust are powerful and flexible, building on traits,
generics and ownership.</p>
<p>comments:
users: &quot;https://users.rust-lang.org/t/finding-closure-in-rust/1285&quot;
r_rust: &quot;http://www.reddit.com/r/rust/comments/359tj5/finding_closure_in_rust/&quot;</p>
<hr />
<blockquote>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/"><em>Originally published 2015-05-08</em></a></p>
<p><em>License: TBD</em></p>
</blockquote>
</div>
<a class="header" href="print.html#rusts-built-in-traits-the-when-how--why" id="rusts-built-in-traits-the-when-how--why"><h1>Rust's Built-in Traits, the When, How &amp; Why</h1></a>
<p>As the title not quite subtly hints, today I'm going to write about the
<em>traits</em> that come with <a href="http://rust-lang.org">Rust</a>'s standard library,
specifically from the context of a library writer yearning to give their users
a good experience.</p>
<p>Note that I define built-in as &quot;came with the box that you downloaded Rust
in&quot;. This includes traits that have no special language semantics.</p>
<p>Rust uses traits for a good number of things, from the quite obvious operator
overloading to the very subtle like <code>Send</code> and <code>Sync</code>. Some traits can be
<em>auto-derived</em> (which means you can just write
<code>#[derive(Copy, Clone, PartialEq, Eq, Debug, Default, Hash, …)]</code> and get a
magically appearing implementation that usually does the right thing. with
Send and Sync, you actually have to actively opt out of implementing them.</p>
<p>So I'll try to go from the obvious and specific to the nebulous and (perhaps)
surprising:</p>
<a class="header" href="print.html#partialeqord" id="partialeqord"><h3>(Partial)–Eq/Ord</h3></a>
<p><a href="http://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> defines
partial equality. This means the relation is
<a href="https://en.wikipedia.org/wiki/Symmetric_relation">symmetric</a> (<code>a == b</code> →
<code>b == a</code> for all <code>a</code> and <code>b</code> of the respective type) and
<a href="https://en.wikipedia.org/wiki/Transitive_relation">transitive</a> (<code>a == b</code>
∧ <code>b == c</code> → <code>a == c</code> for all <code>a</code>, <code>b</code> and <code>c</code> of the type).</p>
<p><a href="http://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a> is used as a marker to
declare that <code>PartialEq</code> is also
<a href="https://en.wikipedia.org/wiki/Reflexive_relation">reflexive</a> (<code>a == a</code> for
all <code>a</code> of the respective type). Counter-Example: The <code>f32</code> and <code>f64</code> types
implement <code>PartialEq</code>, but not <code>Eq</code>, because <code>NAN != NAN</code>.</p>
<p>It is useful to implement both traits, for a good number of <code>std</code>'s types use
them as trait bounds for one thing or another, e.g. <code>Vec</code>'s <code>dedup()</code> function.
Auto-deriving <code>PartialEq</code> will make the <code>eq</code>-method check equality of all parts
of your type (e.g. for <code>struct</code>s, all parts will be checked, while for <code>enum</code>
types, the variant along with all its contents is checked).</p>
<p>Since <code>Eq</code> is basically empty (apart from a
<a href="http://doc.rust-lang.org/src/core/cmp.rs.html#81">pre-defined marker method</a>
that is used by the auto-deriving logic to ensure that it actually worked and
probably shouldn't be used anywhere else), auto-deriving has no chance of doing
something interesting, so it won't.</p>
<p><a href="http://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> defines
a partial order, and extends the equality of <code>PartialEq</code> by the
<a href="http://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>Ordering</code></a> relation.
Partial in this case means there may be instances of your type that cannot be
meaningfully compared.</p>
<p><a href="http://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a> requires a full order
relation. In contrast to <code>PartialEq</code>/<code>Eq</code>, those two traits actually have a
different interface (the <code>partial_cmp(…)</code> method returns <code>Option&lt;Ordering&gt;</code>, so
it can return <code>None</code> for incomparable instances, while <code>Ord</code>'s <code>cmp(…)</code> returns
the <code>Ordering</code> directly), and their only relation is that if you wish to
implement <code>Ord</code>, you have to implement <code>PartialOrd</code> as well, for the latter is
a trait bound for the former.</p>
<p>Auto-deriving both will order structs
<a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>, enums
by the appearance of the variant in the definition (unless you define values
for the variants).</p>
<p>Should you opt to implement the relation manually, be careful to ensure a stable
result that follows the rules of ordering relations, lest your program break in
confusing ways.</p>
<p>The order imposed by (<code>Partial</code>)<code>Ord</code> is used for the <code>&lt;</code>, <code>&lt;=</code>, <code>=&gt;</code> and <code>&gt;</code>
operators.</p>
<a class="header" href="print.html#arithmetic-operators" id="arithmetic-operators"><h3>Arithmetic Operators</h3></a>
<p>The following table shows the relation between arithmetic operators and traits:</p>
<table><thead><tr><th>Operator</th><th>Trait</th></tr></thead><tbody>
<tr><td><code>a + b</code> </td><td><a href="http://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td></tr>
<tr><td><code>a - b</code> </td><td><a href="http://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td></tr>
<tr><td><code>-a</code>    </td><td><a href="http://doc.rust-lang.org/std/ops/trait.Neg.html"><code>Neg</code></a></td></tr>
<tr><td><code>a * b</code> </td><td><a href="http://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td></tr>
<tr><td><code>a / b</code> </td><td><a href="http://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td></tr>
<tr><td><code>a % b</code> </td><td><a href="http://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td></tr>
</tbody></table>
<p>Apart from <a href="http://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a>, which is
an abbreviation for <em>Remainder</em>, also  known as <code>mod</code> in some other languages,
those are pretty obvious. The binary operator traits all have a <code>RHS</code>
(=right-hand-side) generic type bound which defaults to <code>Self</code>, as well as an
associated <code>Output</code> type that the implementation has to declare.</p>
<p>This means you can implement e.g. addition of a <code>Foo</code> and a <code>Bar</code> to return a
<code>Baz</code> if you so desire. Note that while the operations do not constrain their
semantics in any way, it is strongly advisable not to make them mean something
entirely different than their arithmetical counterparts shown above, lest your
implementation become a
<a href="http://www.urbandictionary.com/define.php?term=footgun">footgun</a> for other
developers.</p>
<p>Aside: Just before Rust 1.0.0, someone actually implemented <code>Add</code> for <code>String</code>
and <code>Vec</code> to mean concatenation. It took yours truly (among others) a
heartrending plea to the Rust gods until they mended this particular error at
least for <code>Vec</code>. This means that you can write <code>my_string + &quot; etc.&quot;</code> as long
as <code>my_string</code> is a <code>String</code> – note that this will actually consume
<code>my_string</code> by value, which may be confusing to some.</p>
<a class="header" href="print.html#bit-operators" id="bit-operators"><h3>Bit-Operators</h3></a>
<p>The following operators are defined to be used bitwise. Note that unlike the
<code>!</code>-operator, the short-circuiting <code>&amp;&amp;</code> and <code>||</code> cannot be overloaded – because
this would require them to avoid eagerly evaluating their arguments, which
isn't easily possible in Rust – and even if it were possible, e.g. using
closures as a workaround, it would just be confusing other developers.</p>
<table><thead><tr><th>Operator</th><th>Trait</th></tr></thead><tbody>
<tr><td><code>!a</code>    </td><td><a href="http://doc.rust-lang.org/std/ops/trait.Not.html"><code>Not</code></a></td></tr>
<tr><td><code>a &amp; b</code> </td><td><a href="http://doc.rust-lang.org/std/ops/trait.BitAnd.html"><code>BitAnd</code></a></td></tr>
<tr><td>`a </td><td> b` </td><td><a href="http://doc.rust-lang.org/std/ops/trait.BitOr.html"><code>BitOr</code></a></td></tr>
<tr><td><code>a ^ b</code> </td><td><a href="http://doc.rust-lang.org/std/ops/trait.BitXor.html"><code>BitXor</code></a></td></tr>
<tr><td><code>a &lt;&lt; b</code></td><td><a href="http://doc.rust-lang.org/std/ops/trait.Shl.html"><code>Shl</code></a></td></tr>
<tr><td><code>a &gt;&gt; b</code></td><td><a href="http://doc.rust-lang.org/std/ops/trait.Shr.html"><code>Shr</code></a></td></tr>
</tbody></table>
<p>Like with all operators, be wary of implementing those for your type unless you
have specific reason to, e.g. it may make sense to define some of them on
<code>BitSet</code>s (which by the way are no longer part of the standard library as of
Rust 1.3.0) or on types representing large integers.</p>
<a class="header" href="print.html#index-and-indexmut" id="index-and-indexmut"><h3>Index and IndexMut</h3></a>
<p>The <a href="http://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a> and
<a href="http://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a> traits
specify the indexing operation with immutable and mutable results. The former
is read-only, while the latter allows both assigning and mutating the value,
that is calling a function that takes a <code>&amp;mut</code> argument (note that this may,
but need not be self).</p>
<p>You will most likely want to implement them with any sort of collection
classes. Apart from those, use of those traits would be a
<a href="http://www.urbandictionary.com/define.php?term=footgun">footgun</a> anyway.</p>
<a class="header" href="print.html#fn-fnmut-and-fnonce" id="fn-fnmut-and-fnonce"><h3>Fn, FnMut and FnOnce</h3></a>
<p>the <code>Fn*</code>-traits abstract the act of calling something. The difference between
those traits is simply how the <code>self</code> is taken:
<a href="http://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a> takes it by reference,
<a href="http://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a> by mutable
reference and <a href="http://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>
consumes it by value (which is after all why it can only be called once, as
there is no <code>self</code> to call afterwards).</p>
<p>Note that this distinction is just about <code>self</code>, not any of the other
arguments. It is perfectly fine to call a <code>Fn</code> with mutably referenced or even
owned/moved arguments.</p>
<p>The traits are auto-derived for functions and closures and I have yet to see
a different case where they are useful. stebalien also points out that they
actually <em>cannot</em> be implemented in stable Rust.</p>
<a class="header" href="print.html#display-and-debug" id="display-and-debug"><h3>Display and Debug</h3></a>
<p><a href="http://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> and
<a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> are used for
formatting values. The former is meant to produce user-facing output and as
such cannot be auto-derived, while the latter will usually produce a JSON-like
representation of your type and can safely be auto-derived for most types.</p>
<p>Should you decide to implement <code>Debug</code> manually, you may want to distinguish
between the normal <code>{:?}</code> format specifier and the pretty-printing <code>{:#?}</code> one.
The easiest way to do this is to use the Debug Builder method. The
<a href="http://doc.rust-lang.org/std/fmt/struct.Formatter.html"><code>Formatter</code></a> type has
some (unfortunately unstable as of yet, but soon to be stabilized) very helpful
methods, look for <code>debug_struct(&amp;mut self, &amp;str)</code>,
<code>debug_tuple(&amp;mut self, &amp;str)</code>, etc.</p>
<p>Otherwise you can do this by querying the <code>Formatter::flags()</code> method, which
will have the <code>4</code> bit set (which I found out by
<a href="https://play.rust-lang.org/?gist=f9024a36b7e0e61c1ce7&amp;version=stable">experiment</a>).
Thus, if <code>(f.flags() &amp; 4) == 4</code> is <code>true</code>, the caller asked you to produce
pretty-printed output. Note that this is expressly <em>not</em> a public part of
<code>Debug</code>/<code>Formatter</code>'s interface, so the Rust gods could change this the moment
I write this.</p>
<p>Seriously, if you can help it, use auto-derived <code>Debug</code> or debug builders.</p>
<p>Aside: It's not very common, but there may be cyclic object graphs in Rust,
which would send the debug logic into infinite recursion (well, usually the
application will crash with a stack overflow). In most cases, this is
acceptable, because cycles <em>are</em> quite uncommon. In case you suspect your
type to form cycles more often than average, you may want to do something
about it.</p>
<a class="header" href="print.html#copy-and-clone" id="copy-and-clone"><h3>Copy and Clone</h3></a>
<p>Those two traits take care of duplicating objects.</p>
<p><a href="http://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> declares that
your type can be safely copied. This means that if you copy the memory a value
of your type resides in, you get a new valid value that has no references to
data of the original. It can be auto-derived (and requires
<a href="http://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, because all
<code>Copy</code>able types are also <code>Clone</code>able by definition). In fact there is no use
in implementing it manually anywhere.</p>
<p>There are exactly three reasons <em>not</em> to implement <code>Copy</code>:</p>
<ol>
<li>Your type cannot be <code>Copy</code>able, because it contains mutable references
or implements <code>Drop</code>.</li>
<li><s>Your type is so big that copying it would be prohibitively expensive (e.g.
it could contain an <code>[f64; 65536]</code>)</s> Rust Guru eddyb notes that Rust
would still copy the whole thing unless you work with references.</li>
<li>You actually want <em>move semantics</em> for your type</li>
</ol>
<p>The third reason should be explained further. By default, Rust has <em>move</em>
semantics – if you assign a value from <code>a</code> to <code>b</code>, <code>a</code> no longer holds the
value. However, for types that have a <code>Copy</code> implementation, the value is
actually copied (unless the original value is no longer used, in which case
LLVM <em>may</em> elide the copy to improve performance). The
<a href="http://doc.rust-lang.org/std/marker/trait.Copy.html">docs</a> for <code>Copy</code> go into
more detail.</p>
<p><a href="http://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> is a more
generic solution that will take care of any references. You will probably want
to auto-derive it in most cases (as being able to clone values is rather
useful), and only implement it manually for things like custom refcounting
schemes, garbage collection or something similar.</p>
<p>In contrast to <code>Copy</code> which actually alters assignment semantics, <code>Clone</code> is
explicit: It defines the <code>.clone()</code> method which you have to call manually to
clone something.</p>
<a class="header" href="print.html#drop" id="drop"><h3>Drop</h3></a>
<p>The <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait is about
giving back resources when things go out of scope. Much has been written about
it, and how you shouldn't rely on it being called should something go wrong.
Still, it's very nice especially for wrapping FFI constructs that have to
somehow be reclaimed later, also it's used on files, sockets, database handles
and the kitchen sink.</p>
<p>Unless you have an instance where this applies, you should refrain from
implementing <code>Drop</code> at all – your values will be <code>Drop</code>ped correctly by default
anyway. A (temporary) exception is to insert some tracing output to find out
when a specific value has been dropped.</p>
<a class="header" href="print.html#default" id="default"><h3>Default</h3></a>
<p><a href="http://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> is a trait
to declare a default value for your type. It can be auto-derived, but <em>only</em>
for <code>struct</code>s whose members all have a <code>Default</code> implementations.</p>
<p>It is implemented for a great many types in the standard libraries, and also
used in a surprising number of places. So if your type has a value that can
be construed as being &quot;default&quot;, it is a good idea to implement this trait.</p>
<p>A great thing with <code>struct</code>s that have a <code>Default</code> implementation, is you can
instantiate them with only the non-default values like:</p>
<pre><code class="language-rust ignore">let x = Foo { bar: baz, ..Default::default() }
</code></pre>
<p>and have all other fourtytwo fields of Foo be filled with default values. How
cool is that? Honestly, the only single reason not to have <code>Default</code> is if
your type has no single value that works as a default.</p>
<a class="header" href="print.html#error" id="error"><h3>Error</h3></a>
<p><a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> is a base trait
for all values representing an error in Rust. For those coming from Java, it is
akin to <code>Throwable</code> – and behaves similarly (apart from the fact that we
neither <code>catch</code> nor <code>throw</code> them).</p>
<p>It is a <em>very</em> good idea to implement <code>Error</code> for any type you intend to use in
the latter part of
<a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>. Doing so will
make your functions <em>much</em> more composable, especially when you can simply
<a href="http://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> the Error as a
trait object.</p>
<p>Look at the
<a href="http://doc.rust-lang.org/nightly/book/error-handling.html#using-try!">Using <code>try!</code></a>
section of the Rust book for further information.</p>
<a class="header" href="print.html#hash" id="hash"><h3>Hash</h3></a>
<p>Hashing is the process of reducing a bag of data into a single value that still
distinguishes different data items while returning the same value for equal
items without requiring as much bits as the processed data.</p>
<p>In Rust, the <a href="http://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a> trait
denotes values to which this process can be applied. Note that this trait does
not relate any information about the hash <em>algorithm</em> used (this is
encapsulated within the
<a href="http://doc.rust-lang.org/std/hash/trait.Hasher.html"><code>Hasher</code></a> trait), it
basically just orders the bits to be hashed.</p>
<p>Aside: This is also the reason why
<a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> does
not implement <code>Hash</code> itself, because two equal hash maps could still store
their contents in different order, resulting in different hashes, which would
break the hashing contract. Even if the items were ordered (see <code>Ord</code> above),
hashing them would require sorting, which would be too expensive to be useful.
One could also xor the entry hash values, but that would require re-using the
<code>Hasher</code>, which would at least require a <code>Clone</code> bound, which the interface
lacks. In any event, use a
<a href="http://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a>
as key for your maps if you must have maps as keys to a hashmap. In that case,
you should probably also be thinking about a career change.</p>
<p>Unless you have some very specific constraints regarding equality, you can
safely auto-derive <code>Hash</code>. Should you choose to implement it manually, be
careful not to break its contract, lest your programs fail in surprising and
hard to debug ways.</p>
<a class="header" href="print.html#iterator-and-friends" id="iterator-and-friends"><h3>Iterator and Friends</h3></a>
<p>Rust's <code>for</code> loops work can iterate over everything that implements
<a href="http://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>.
Yes, that includes
<a href="http://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> itself.
Apart from that, the <code>Iterator</code> trait has a lot of cool methods for working
with the iterated values, like <code>filter</code>, <code>map</code>, <code>enumerate</code>, <code>fold</code>, <code>any</code>,
<code>all</code>, <code>sum</code>, <code>min</code> and much more.</p>
<p>Did I tell you I love iterators? If your type contains more than one value of
something, and it makes sense to do the same thing to all of them, consider
providing an <code>Iterator</code> over them just in case. :-)</p>
<p>Implementing <code>Iterator</code> is actually pretty easy – you just need to declare the
<code>Item</code> type and write the <code>next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;</code> method. This
method should return <code>Some(value)</code> as long as you have values, then return
<code>None</code> to stop the iteration.</p>
<p>Note that if you have a <em>slice</em> of values (or an array or vec, from which you
can <em>borrow</em> a slice), you can get its iterator directly, so you don't even
need to implement it yourself. This may not be as cool as auto-deriving, but
it's nice nonetheless.</p>
<p>While writing <a href="https://github.com/llogiq/optional">optional</a>, I found that
using a const slice's iterator is faster in the boolean case, but creating a
slice of the value is still slower than copying it for most values. Your
mileage may vary.</p>
<a class="header" href="print.html#from-into-and-various-variations" id="from-into-and-various-variations"><h3>From, Into and Various Variations</h3></a>
<p>I said it before, whoever designed the
<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and
<a href="http://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> traits is a
genius. They abstract over <em>conversions</em> between types (which are used quite
often) and allow library authors to make their libraries much more
interoperable, e.g. by using <code>Into&lt;T&gt;</code> instead of <code>T</code> as arguments.</p>
<p>For obvious reasons, those traits cannot be auto-derived, but writing them
should be trivial in most cases. If you choose to implement them – and you
should wherever you find a worthwhile conversion! – implement <code>From</code> wherever
possible, and failing that implement <code>Into</code>.</p>
<p>Why? There is a blanket implementation of <code>Into&lt;U&gt;</code> for <code>T</code> where <code>U: From&lt;T&gt;</code>.
This means if you have implemented <code>From</code>, you get an <code>Into</code> delivered to your
home free of charge.</p>
<p>Why not implement <code>From</code> everywhere? The orphan rule unfortunately forbids
implementing <code>From</code> for types not defined in other crates. For example, I have
an <code>Optioned&lt;T&gt;</code> type, that I may want to convert into an
<a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code></a>. Trying to
implement <code>From</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T: Noned + Copy&gt; From&lt;Optioned&lt;T&gt;&gt; for Option&lt;T&gt; {
    #[inline]
    fn from(self) -&gt; Option&lt;T&gt; { self.map_or_else(|| none(), wrap) }
}
</code></pre>
<p>I get an error: type parameter <code>T</code> must be used as the type parameter for some
local type (e.g. <code>MyStruct&lt;T&gt;</code>); only traits defined in the current crate can
be implemented for a type parameter <code>[E0210]</code></p>
<p>Note that you can implement <code>From</code> and <code>Into</code> with multiple classes, you can
have a <code>From&lt;Foo&gt;</code> and a <code>From&lt;Bar&gt;</code> for the same type.</p>
<p>There are a good number of traits starting with <code>Into</code> – <code>IntoIterator</code>, which
is stable and which we already have discussed above, just being one of them.
There also is
<a href="http://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a>,
which does the reverse, namely constructing a value of your type from an
iterator of items.</p>
<p>Then there is <a href="http://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>
for any types that can be parsed from a string, which is very useful for types
that you want read from any textual source, e.g. configuration or user input.
Note that its interface differs from <code>From&lt;&amp;str&gt;</code> in that it returns a
<code>Result</code>, and thus allows to relate parsing errors to the caller.</p>
<a class="header" href="print.html#derefmut-asrefasmut-borrowmut-and-toowned" id="derefmut-asrefasmut-borrowmut-and-toowned"><h3>Deref(Mut), AsRef/AsMut, Borrow(Mut) and ToOwned</h3></a>
<p>Those all have to do with references and borrowing, so I grouped them into one
section.</p>
<p>The prefix-<code>*</code>-operator <em>dereferences</em> a reference, producing the value. This
is directly represented by the
<a href="http://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> trait; if we
require a mutable value (e.g. to assign somehing or call a mutating function),
we invoke the
<a href="http://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> trait.</p>
<p>Note that this does not necessarily mean <em>consuming</em> the value – maybe we take
a reference to it in the same expression, e.g. <code>&amp;*x</code> (which you will likely
find in code that deals with special kinds of pointers, e.g. <code>syntax::ptr::P</code>
is widely used in <a href="https://github.com/Manishearth/rust-clippy">clippy</a> and
other lints / compiler plugins. Perhaps <code>as_ref()</code> would be clearer in those
cases (see below), but here we are.</p>
<p>The <code>Deref</code> trait has but one method: <code>fn deref(&amp;'a self) -&gt; &amp;'a Self::Target;</code>
where <code>Target</code> is an associated type of the trait. The lifetime bound on the
result requires that the returned value live as long as self. This requirement
restricts the possible implementation strategies to two options:</p>
<ol>
<li>
<p>Dereference to a value <em>within</em> your type, e.g. if you have a
<code>struct Foo { b: Bar }</code>, you could dereference to <code>Bar</code>. Note that this doesn't
mean you <em>should</em> do it, but it's possible and may in some cases be useful.
This obviously works as long as the part's lifetime is the one of the whole,
which is the default with Rust's lifetime elision.</p>
</li>
<li>
<p>Dereference to a constant <code>'static</code> value – I
<a href="https://github.com/llogiq/optional/blob/db2b4c742e41f4607e64b9e855ae4638d839e828/src/lib.rs#L76">do this</a>
in optional to have <code>OptionBool</code> dereference to a const <code>Option&lt;bool&gt;</code>. This
works because the result is guaranteed to outlive our value, because it is
alive for the rest of the program. This is only useful if you have a finite
value domain. Even then, it is probably clearer to use
<a href="http://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> instead of
<code>Deref</code>. I doubt that we will see this too often.</p>
</li>
</ol>
<p><a href="http://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> only has the
former strategy. Its usefulness is limited to implementing special kinds of
pointers.</p>
<p>To see why no other implementation can be possible, let's make a thought
experiment: If we had a return value that is neither static, nor bound to the
lifetime <code>'a</code> of our dereferenced value, it would by definition have a lifetime
<code>'b</code> that is <em>distinct</em> from <code>'a</code>. There is no way we could unify those two
lifetimes – QED.</p>
<p>As for the other traits, they exist mainly to abstract away the act of
borrowing / referencing for some types (because e.g. with <code>Vec</code>s it is possible
to borrow a slice of them). As such, they fall into the same category as the
<code>From</code>/<code>Into</code> traits – they don't get invoked behind the scenes, but exist to
make some interfaces more adaptable.</p>
<p>The relation between
<a href="http://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a>,
<a href="http://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a>/<a href="http://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a>
and <a href="http://doc.rust-lang.org/std/borrow/trait.ToOwned.html"><code>ToOwned</code></a> is as
follows:</p>
<table><thead><tr><th>From↓ / To→  </th><th>Reference      </th><th>Owned</th></tr></thead><tbody>
<tr><td><strong>Reference</strong></td><td><code>AsRef</code>/<code>AsMut</code></td><td><code>ToOwned</code></td></tr>
<tr><td><strong>Owned</strong>    </td><td><code>Borrow</code>(<code>Mut</code>)</td><td>(perhaps <code>Copy</code> or <code>Clone</code>?)</td></tr>
</tbody></table>
<p>For an example where this applies, look no further than my earlier
<a href="/2015/07/09/cow.html">detective story about <code>std::borrow::Cow</code></a>.</p>
<p>Should you decide to implement <code>Borrow</code> and/or <code>BorrowMut</code>, you need to ensure
that the result of <code>borrow()</code> has the same hash value as the borrowed original
value, lest your program fail in strange and confusing ways.</p>
<p>In fact, unless your type does something interesting with ownership (like
<code>Cow</code> or <a href="https://github.com/Kimundi/owning-ref-rs"><code>owning_ref</code></a>), you should
probably leave <code>Borrow</code>, <code>BorrowMut</code> and <code>ToOwned</code> alone and use a <code>Cow</code> if
you want to abstract over owned/borrowed values.</p>
<p>I have not yet divined in what cases <code>AsRef</code>/<code>AsMut</code> may be useful unless you
count the predefined <code>impl</code>s that <code>std</code> already provides.</p>
<a class="header" href="print.html#send-and-sync" id="send-and-sync"><h3>Send and Sync</h3></a>
<p>Those two traits testify that the types transfer trouble-free 'tween threads.</p>
<p>You will never need to implement them – in fact Rust will do it for you by
default unless you explicitly opt out (or your type contains a non-threadsafe
part). You can opt out by saying:</p>
<pre><code class="language-Rust">impl !Send for MyType {} // this type cannot be sent to other threads
impl !Sync for MyType {} // nor can it be used by two of them
</code></pre>
<p>Note that this is currently not possible in stable Rust (which means that only
<code>std</code> gets to pull this trick).</p>
<p><a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> says that you can
<em>move</em> your type between thread barriers, while
<a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Sync</code></a> allows <em>sharing</em>
a value between threads. Let's take a step back and look at what that means,
probably best with an example.</p>
<p>Say we have some problem that we intend to solve by calculating some values in
parallel (because concurrency is the way, baby!). For that we need some
immutable data that will be the same in all threads – we want <em>shared</em> data.
This data needs to be <code>Sync</code>able.</p>
<p>Next, we want to give some part of the problem to each thread. To do this, we
need to <code>Send</code> it to them. But wait! How do we get the shared data to each
thread? Easy: We <code>Send</code> a reference to it – this works because of the following
blanket definition in the standard library:</p>
<pre><code class="language-Rust">impl&lt;'a, T&gt; Send for &amp;'a T where T: Sync + ?Sized
</code></pre>
<p>This means if something can be <code>Sync</code>ed, you can <code>Send</code> a reference to it
between threads. Cool.</p>
<p>For a more thorough treatment, see Manish Goregaokar's
<a href="http://manishearth.github.io/blog/2015/05/30/how-rust-achieves-thread-safety/">How Rust Achieves Thread Safety</a>
or the <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code> docs</a>.</p>
<hr />
<p>Thanks go to stebalien and carols10cents for (proof)reading a draft of this and
donating their time, effort and awesome comments! This post wouldn't have been
half as good without them.</p>
<p>Have I missed, or worse, misunderstood a trait (or a facet of one)? Please
write your extension requests on
<a href="https://www.reddit.com/r/rust/comments/3f77j0/blog_rusts_builtin_traits_the_when_how_why/">/r/rust</a>
or <a href="https://users.rust-lang.org/t/blog-rusts-built-in-traits-the-when-how-and-why/2268">rust-lang users</a>.</p>
<blockquote>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/"><em>Originally published 2015-07-30</em></a></p>
<p><em>License: TBD</em></p>
</blockquote>
<hr />
<p>layout: default
title: Myths and Legends about Integer Overflow in Rust</p>
<p>description: &gt;
Integer overflow detection/handling in Rust is sometimes misunderstood.</p>
<p>comments:
users: &quot;https://users.rust-lang.org/t/myths-and-legends-about-integer-overflow-in-rust/5612&quot;
r_rust: &quot;https://www.reddit.com/r/rust/comments/4gz93u/myths_and_legends_about_integer_overflow_in_rust/&quot;</p>
<a class="header" href="print.html#r_programming-httpswwwredditcomrprogrammingcomments4gz996myths_and_legends_about_integer_overflow_in_rust" id="r_programming-httpswwwredditcomrprogrammingcomments4gz996myths_and_legends_about_integer_overflow_in_rust"><h1>r_programming: &quot;https://www.reddit.com/r/programming/comments/4gz996/myths_and_legends_about_integer_overflow_in_rust/&quot;</h1></a>
<a class="header" href="print.html#hn-httpsnewsycombinatorcomitemid11595398" id="hn-httpsnewsycombinatorcomitemid11595398"><h1>hn: &quot;https://news.ycombinator.com/item?id=11595398&quot;</h1></a>
<hr />
<p>The primitive integer types supported by CPUs are finite
approximations to the infinite set of integers we're all used to. This
approximation breaks down and some computations will give results that
don't match real integers, like <code>255_u8 + 1 == 0</code>. Often, this
mismatch is something the programmer didn't think about, and thus can
easily result in bugs.</p>
<p>Rust is a programming language designed to protect against bugs; it
does focus on outlawing the most insidious class of them---memory
unsafety---but it also likes to assist the programmer in avoiding
others: [memory leaks][ml], <a href="https://doc.rust-lang.org/std/result/#results-must-be-used">ignoring errors</a>, and, in this case,
[integer overflow][io].</p>
<p>[ml]: {% post_url 2016-04-04-memory-leaks-are-memory-safe %}#not-all-is-lost
[io]: https://en.wikipedia.org/wiki/Integer_overflow</p>
<a class="header" href="print.html#overflow-in-rust" id="overflow-in-rust"><h2>Overflow in Rust</h2></a>
<p>The status of detecting and avoiding overflow in Rust changed several
times in the lead up to the 1.0.0 release last year. That fluid
situation means there's still quite a bit of confusion about exactly
how overflow is handled and mitigated, and what the consequences are.</p>
<p>Before 1.0.0-alpha, overflow was handled by wrapping, giving the
result one would expect from a two's complement representation (as
most modern CPUs use). However, this was thought to be suboptimal:
unexpected and unintended overflow is a common source of bugs. It is
particularly bad in C and C++ due to signed overflow being undefined,
and the lack of protection against memory safety violations---overflow
can easily cascade into memory corruption---but it is still
problematic in more defensive languages like Rust: there are numerous
examples of overflows, they've cropped up in many video games (in
<a href="http://www.gamasutra.com/blogs/MaxWoolf/20130508/191959/Diablo_III_Economy_Broken_by_an_Integer_Overflow_Bug.php">their economies</a>, in <a href="http://www.codeproject.com/Articles/802368/Integer-Overflow-in-Hearthstone">health bars</a>, and more),
<a href="http://googleresearch.blogspot.com.au/2006/06/extra-extra-read-all-about-it-nearly.html">binary search</a> and even <a href="http://www.nytimes.com/2015/05/01/business/faa-orders-fix-for-possible-power-loss-in-boeing-787.html?_r=0">aircraft</a>. More prosaically,
code like <code>max(x - y, z)</code> turns up semiregularly, and it can give
wildly wrong results when the numbers are unsigned and <code>x - y</code>
overflows through 0. Thus, there was a push to make Rust more
defensive about integer overflows.</p>
<p>The current status in Rust was decided in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a>:</p>
<ul>
<li>in debug mode, arithmetic (<code>+</code>, <code>-</code>, etc.) on signed and unsigned primitive integers
is <strong>checked for overflow</strong>, panicking if it occurs, and,</li>
<li>in release mode, overflow is not checked and is <strong>specified to wrap
as two's complement</strong>.</li>
</ul>
<p>These<sup class="footnote-reference"><a href="print.html#unconditional">1</a></sup> overflow checks can be manually disabled or
enabled independently of the compilation mode both globally and at a
per-operation level.</p>
<div class="footnote-definition" id="unconditional"><sup class="footnote-definition-label">1</sup>
<p>There are some unconditional and uncontrollable
overflow checks for arithmetic: <code>x / 0</code>, and <a href="http://blog.regehr.org/archives/887"><code>MIN / -1</code></a> (for
signed integer types), and similarly for <code>%</code>. These computations
are actually undefined behaviour in C and LLVM (which is the
historical reason for why rustc has them unconditional), although,
it seems to me that Rust could theoretically consider the
latter a normal overflow and return <code>MIN</code> when the checks are off.</p>
<p>By checking for overflow in some modes, overflow bugs in Rust code are
hopefully found earlier. Furthermore, code that actually wants
wrapping behaviour is explicit about this requirement, meaning fewer
false positives for both future static analyses and for code that
enables overflow checking in all modes.</p>
<a class="header" href="print.html#myth-overflow-is-undefined" id="myth-overflow-is-undefined"><h2>Myth: overflow is undefined</h2></a>
<p>One way to allow compilers to catch overflow is to make it
<em>undefined</em>, that is, there's absolutely no guarantees about behaviour
when overflow occurs and hence it is legal to panic instead of trying
to return something. However, Rust's core goal is ensuring memory
safety, and leaving things <em>undefined</em> ---in the sense of C undefined
behaviour---is in direct contradiction to this. For one, a variable
that is undefined does not have to have a consistent value from use to
use:</p>
<p>{% highlight rust linenos %}
// pseudo-Rust
let x = undefined;</p>
<p>let y = x;
let z = x;
assert_eq!(y, z); // this could fail
{% endhighlight %}</p>
<p>This has disastrous consequences for things that rely on checking a
value for safety, like indexing an array with bounds checks <code>foo[x]</code>:</p>
<p>{% highlight rust linenos %}
let x = undefined;</p>
<p>// let y = foo[x]; is equivalent to</p>
<p>let y = if x &lt; foo.len() {
unsafe { *foo.get_unchecked(x) }
} else {
panic!(&quot;index out of bounds&quot;)
};
{% endhighlight %}</p>
<p>If the value of <code>x</code> isn't consistent from the <code>x &lt; foo.len()</code>
comparison to the actual access of the array, there's no guarantee the
access will be in-bounds: the comparison might be <code>0 &lt; foo.len()</code>,
while the index might be <code>foo.get_unchecked(123456789)</code>. Problematic!</p>
<p>Therefore, unlike signed integers in C, integer overflow cannot be
undefined in Rust. In other words, compilers must assume that overflow
may happen (unless they can prove otherwise). This has a
possibly unintuitive consequence that <code>x + 1 &gt; x</code> is not always true,
something C compilers <em>do</em> assume is true if <code>x</code> is signed.</p>
<p>&quot;But what about performance?&quot; I hear you ask. It is true that
undefined behaviour drives optimisations by allowing the compiler to
make assumptions, and hence removing this ability could impact
speed. Overflow of signed integers being undefined is particularly
useful in C because such integers are often used as the induction
variables on loops, and hence the ability to make assumptions allows
more precise analysis of loop trip counts: <code>for (int i = 0; i &lt; n; i++)</code> will repeat <code>n</code> times, as <code>n</code> can be assumed to not be
negative. Rust sidesteps much of this by using unsigned integers for
indexing (<code>0..n</code> will always be <code>n</code> steps), and also by allowing easy
custom iterators, which can be used to loop directly over data
structures like <code>for x in some_array { ... }</code>. These iterators can
exploit guarantees about the data structures internally without having
to expose undefined behaviour to the user.</p>
<p>Another thing Rust misses compared to C is optimising <code>x * 2 / 2</code> to
just <code>x</code>, when <code>x</code> is signed. In this case, there's no built-in
feature for getting the optimisation (beyond just writing <code>x</code> instead
of the complicated arithmetic of course), however in my experience,
expressions like that most often occur with <code>x</code> known at compile time,
and hence the whole expression can be constant-folded.</p>
<a class="header" href="print.html#myth-overflow-is-unspecified" id="myth-overflow-is-unspecified"><h2>Myth: overflow is unspecified</h2></a>
<p>Similar to leaving the result of overflow undefined, it could be left
just unspecified, meaning the compiler must assume it could happen,
but is allowed to make the operation return any particular result (or
not return at all). Indeed, <a href="https://github.com/nikomatsakis/rfcs/blob/630dd70a51c0c7e166be78cd3bc8f1247664db28/text/0000-integer-overflow.md#semantics-of-overflow-with-the-built-in-types">the first version</a> of
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a> for checking integer overflow, proposed:</p>
<blockquote>
<p>Change this to define them, on overflow, as either returning an
unspecified result, or task panic, depending on whether the overflow
is checked.</p>
<p>[...]</p>
<ul>
<li>In theory, the implementation returns an unspecified result. In practice, however, this will most likely be the same as the wraparound result. Implementations should avoid needlessly exacerbating program errors with additional unpredictability or surprising behavior.</li>
<li>Most importantly: this is not undefined behavior in the C sense. Only the result of the operation is left unspecified, as opposed to the entire program's meaning, as in C. The programmer would not be allowed to rely on a specific, or any, result being returned on overflow, but the compiler would also not be allowed to assume that overflow won't happen and optimize based on this assumption.</li>
</ul>
</blockquote>
<p>There was a lot of discussion about the RFC and about the
&quot;unspecified&quot; result of arithmetic, meaning that <code>127_i8 + 1</code> could
theoretically return <code>-128</code> (per two's complement) or <code>0</code> or <code>127</code>, or
anything else. This idea took hold in the community... and then it was
changed.</p>
<p>With strong encouragement from a few people, the RFC was tightened up
to actually specify the result: arithmetic on primitives that
overflows either doesn't return (e.g. it panics), or returns the
wrapped result one would expect from two's complement. <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md#arithmetic-operations-with-error-conditions">It</a> now says:</p>
<blockquote>
<p>The operations +, -, *, can underflow and overflow. When checking is
enabled this will panic. When checking is disabled this will two's
complement wrap.</p>
</blockquote>
<p>Specifying the result is a defensive measure: errors are more likely
to cancel out when overflow isn't caught. An expression like <code>x - y + z</code> is evaluated like <code>(x - y) + z</code> and hence the subtraction could
overflow (e.g. <code>x = 0</code> and <code>y = 1</code> both unsigned), but as long as <code>z</code>
is large enough (<code>z &gt;= 1</code> in that example), the result will be what
one expects from true integers.</p>
<p>The change happened towards the end of the 160 comment long RFC
discussion and so it was easy for people to miss, making it easy for
people to still think the result is unspecified.</p>
<a class="header" href="print.html#myth-the-programmer-has-no-control-of-overflow-handling" id="myth-the-programmer-has-no-control-of-overflow-handling"><h2>Myth: the programmer has no control of overflow handling</h2></a>
<p>One of the main objections to adding overflow checking was the
existance of programs/algorithms that <em>want</em> two's complement
overflow, such as hashing algorithms, certain data structures (ring
buffers, particularly) and even image codecs. For these algorithms,
using <code>+</code> in debug mode would be incorrect: the code would panic even
though it was executing as intended. Additionally, some more
security-minded domains wish to have overflow checks on in all modes
by default.</p>
<p>The RFC and the standard library provide <em>four</em>
sets of methods beyond the pure operators:</p>
<ul>
<li><a href="http://doc.rust-lang.org/std/primitive.i32.html#method.wrapping_add"><code>wrapping_add</code></a>, <a href="http://doc.rust-lang.org/std/primitive.i32.html#method.wrapping_sub"><code>wrapping_sub</code></a>, ...</li>
<li><a href="http://doc.rust-lang.org/std/primitive.i32.html#method.saturating_add"><code>saturating_add</code></a>, <a href="http://doc.rust-lang.org/std/primitive.i32.html#method.saturating_sub"><code>saturating_sub</code></a>, ...</li>
<li><a href="http://doc.rust-lang.org/std/primitive.i32.html#method.overflowing_add"><code>overflowing_add</code></a>, <a href="http://doc.rust-lang.org/std/primitive.i32.html#method.overflowing_sub"><code>overflowing_sub</code></a>, ..</li>
<li><a href="http://doc.rust-lang.org/std/primitive.i32.html#method.checked_add"><code>checked_add</code></a>, <a href="http://doc.rust-lang.org/std/primitive.i32.html#method.checked_sub"><code>checked_sub</code></a>, ...</li>
</ul>
<p>These should cover all bases of &quot;don't want overflow to panic in some
modes&quot;:</p>
<ul>
<li><code>wrapping_...</code> returns the straight two's complement result,</li>
<li><code>saturating_...</code> returns the largest/smallest value (as appropriate) of
the type when overflow occurs,</li>
<li><code>overflowing_...</code> returns the two's
complement result along with a boolean indicating if overflow occured,
and</li>
<li><code>checked_...</code> returns an <code>Option</code> that's <code>None</code> when overflow
occurs.</li>
</ul>
<p>All of these can be implemented in terms of <code>overflowing_...</code>, but the
standard library is trying to make it easy for programmers to do the
right thing in the most common cases.</p>
<p>Code that truly wants two's complement wrapping can be written like
<code>x.wrapping_sub(y).wrapping_add(z)</code>. This works, but clearly can get a
little verbose, verbosity that can be reduced in some cases via the
standard library's <a href="http://doc.rust-lang.org/std/num/struct.Wrapping.html"><code>Wrapping</code></a> wrapper type.</p>
<p>The current state isn't necessarily the final state of overflow
checking: the RFC even mentioned some <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md#alternatives-and-possible-future-directions">future directions</a>. Rust
could introduce operators like Swift's wrapping <code>&amp;+</code> in future,
something that was not done initially because Rust tries to be
conservative and reasonably minimal, as well as hypothetically having
scoped disabling of overflow checking (e.g. a single function could be
explicitly marked, and its internals would thus be unchecked in all
modes). There's interest in the latter particularly, from some of
Rust's keenest (potential) users <a href="https://github.com/rust-lang/cargo/issues/2262">Servo</a> and <a href="https://wiki.mozilla.org/Oxidation#Rust_.2F_Cargo_nice-to-haves">Gecko</a>.</p>
<p>For code that wants overflow checking everywhere, one can either use
<code>checked_add</code> pervasively (annoying!), or explicitly enable
them. Although they are tied to debug assertions by default, overflow
checks can be turned on by passing <code>-C debug-assertions=on</code> to rustc,
or setting the <code>debug-assertions</code> field of a
<a href="http://doc.crates.io/manifest.html#the-profile-sections">cargo profile</a>. There's also work on having them able to be
activated independently of other debug assertions (rustc currently has
the unstable <code>-Z force-overflow-checks</code> flag).</p>
<a class="header" href="print.html#myth-the-approach-to-overflow-checks-makes-code-slow" id="myth-the-approach-to-overflow-checks-makes-code-slow"><h2>Myth: the approach to overflow checks makes code slow</h2></a>
<p>Rust aims to be as fast as possible, and the design of the current
overflow checking approach took various performance considerations
seriously. Performance is one of the main motivations for checks being
disabled in release builds by default, and indeed means that there's
no speed penalty to the way in which Rust helps mitigate/flag
integer overflow bugs during development.</p>
<p>It's an unfortunate reality that checking for overflow requires more
code and more instructions:</p>
<p>{% highlight rust linenos %}
#[no_mangle]
pub fn unchecked(x: i32, y: i32) -&gt; i32 {
x.wrapping_add(y)
}</p>
<p>#[no_mangle]
pub fn checked(x: i32, y: i32) -&gt; i32 {
x + y
}
{% endhighlight %}</p>
<p>With <code>-O -Z force-overflow-checks</code>, on x86<sup class="footnote-reference"><a href="print.html#arm">2</a></sup>, this compiles to (with some
editing for clarity):</p>
</div>
<div class="footnote-definition" id="arm"><sup class="footnote-definition-label">2</sup>
<p>On 32-bit ARM, LLVM <a href="https://llvm.org/bugs/show_bug.cgi?id=27571">currently decides</a> to emit a
chain of redundant comparisons and register manipulations, so the
penalty is even higher!</p>
<p>{% highlight asm linenos %}
unchecked:
leal (%rdi,%rsi), %eax
retq</p>
<p>checked:
pushq   %rax
addl    %esi, %edi
jo  .overflow_occurred
movl    %edi, %eax
popq    %rcx
retq
.overflow_occurred:
leaq    panic_loc2994(%rip), %rdi
callq   _ZN9panicking5panic20h4265c0105caa1121SaME@PLT
{% endhighlight %}</p>
<p>It is definitely annoying that there are all<sup class="footnote-reference"><a href="print.html#extra">3</a></sup> those extra
instructions, as is the fact that implementations are forced to use
<code>add</code> rather than having the option to use <code>lea</code><sup class="footnote-reference"><a href="print.html#lea">4</a></sup>. However, an
even bigger performance hit is how overflow checks inhibit other
optimisations, both because the checks themselves serialise code
(inhibiting things like loop unrolling/reordering and vectorisation)
and because the panic/stack unwinding forces the compiler to
<a href="http://danluu.com/integer-overflow/">be more conservative</a>.</p>
</div>
<div class="footnote-definition" id="extra"><sup class="footnote-definition-label">3</sup>
<p>There's more instructions in the function version than there
would be when <code>checked</code> is inlined (as it should be): the
<code>pushq</code>/<code>pop</code>/<code>movl</code> register management wouldn't be
necessary. Also, even without inlining I believe the
<code>pushq</code>/<code>popq</code> stack management isn't necessary, but
unfortunately the published Rust binaries <s>don't use a new
enough version of LLVM to get its new <a
href="http://reviews.llvm.org/D9210">&quot;shrink wrapping&quot;
optimisation pass</a></s> use a version of LLVM that
contains <a href="https://llvm.org/bugs/show_bug.cgi?id=25614">a bug in its &quot;shrink-wrapping&quot; pass</a>
(thanks for <a href="https://users.rust-lang.org/t/myths-and-legends-about-integer-overflow-in-rust/5612/2?u=huon">the correction</a>, Eli Friedman).</p>
</div>
<div class="footnote-definition" id="lea"><sup class="footnote-definition-label">4</sup>
<p>On x86, it can be extremely useful to be able to use <code>lea</code>
(load effective address) for arithmetic: it can do relatively
complicated computations, and is usually computed in a different
part of the CPU and its pipeline than <code>add</code>, allowing exploiting
more instruction-level parallelism. The x86 ISA allows
dereferencing complicated pointer computations: the most general
form is <code>A(r1, r2, B)</code> (in AT&amp;T syntax), which is equal to <code>r1 + B * r2 + A</code> for registers <code>r1</code> and <code>r2</code> and constants <code>A</code> and
<code>B</code>. Normally these are used directly in memory instructions like
<code>mov</code> (e.g. <code>let y = array_of_u32[x];</code> could compile to something
along the lines of <code>mov (array_of_u32.as_ptr(), x, 4), y</code> ,
because each element is of size 4), but <code>lea</code> allows just doing
the arithmetic without hitting memory.  All-in-all, being able to
use <code>lea</code> for arithmetic is quite nice. The downside is of course
<code>lea</code> doesn't integrate directly with overflow detection: it
doesn't set the CPU flags that signal it.</p>
<p>All these considerations explain why overflow checks are not enabled
in release mode, where usually getting the highest performance
possible is desirable.</p>
<p>That said, even when the checks are enabled in release mode, the
performance hit can be reduced like with bounds checked arrays.  For
one, compilers can do range analysis/inductive proofs to deduce that
certain overflow checks are sure to never fail; indeed,
<a href="http://blog.regehr.org/archives/1384">significant</a> <a href="https://github.com/apple/swift/blob/16b3d6c8d5b2d610cdfd72898f6ab384e632b69b/lib/SILOptimizer/Transforms/RedundantOverflowCheckRemoval.cpp">effort</a> has been <a href="https://github.com/llvm-mirror/llvm/blob/8b47c17a53d683f313eaaa93c4a53de26d8fcba5/lib/Transforms/InstCombine/InstCombineAddSub.cpp#L893-L987">devoted</a> to <a href="https://github.com/gcc-mirror/gcc/blob/fd3211e13bbbb6882f477aa75a36eb0ccdec485f/gcc/tree-vrp.c#L9792-L9884">the topic</a>. Additionally,
the significant pain caused by using panics can be reduced by
application authors <a href="https://github.com/rust-lang/rfcs/blob/master/text/1513-less-unwinding.md">converting panics into aborts</a>, if it's
appropriate for their domain.</p>
<p>The integer overflow RFC gives itself some room for optimisation too:
it <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md#delayed-panics">allows &quot;delayed panics&quot;</a>, meaning a Rust implementation
is allowed to perform a sequence of operations like <code>a + b + c + d</code>
and only panic once at the end if any intermediate overflow occurred,
instead of having to separately check for overflow (and panic) in <code>tmp = a + b</code> and then in <code>tmp + c</code> etc. No known implementation actually
does this yet, but they could.</p>
<a class="header" href="print.html#myth-the-checks-find-no-bugs" id="myth-the-checks-find-no-bugs"><h2>Myth: the checks find no bugs</h2></a>
<p>All the design/discussion/implementation of this scheme for handling
integer overflow would be wasted if it didn't actually find any bugs
in practice. I personally have had quite a few bugs found nearly as I
write them, with expressions like <code>cmp::max(x - y, z)</code> (they never hit
the internet, so no links for them), especially when combined with
testing infrastructure like <a href="https://crates.io/crates/quickcheck"><code>quickcheck</code></a>.</p>
<p>The overflow checks have found bugs through out the ecosystem; for instance, (not exhaustive!)</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/pull/22532#issuecomment-75168901">the standard library</a></li>
<li><a href="https://github.com/rust-lang/rust/pull/31281">the compiler</a></li>
<li><a href="https://github.com/rust-lang/rust/pull/23127">the built-in benchmark harness</a></li>
<li><a href="https://github.com/servo/servo/issues/6040">Servo</a></li>
<li><a href="https://github.com/PistonDevelopers/image/pull/412"><code>image</code></a></li>
<li><a href="https://github.com/servo/rust-url/issues/124"><code>url</code></a></li>
<li><a href="https://github.com/servo/webrender/pull/243"><code>webrender</code></a></li>
</ul>
</div>
<p>Beyond Rust, there's a lot of evidence for the dangers of integer overflow and
desire for detecting/protecting against them. It was on the
<a href="http://cwe.mitre.org/top25/">CWE/SANS list of top 25 errors in 2011</a>, languages like Swift
will unconditionally check for overflow, and others like Python 3 and
Haskell will avoid overflow entirely by default, via arbitrary
precision integers. Furthermore, in C, several compilers have options
to both make signed overflow defined as two's complement wrapping
(<code>-fwrapv</code>) and to catch it when it does happen
(<code>-fsanitize=signed-integer-overflow</code>).</p>
<p><em>Thanks to <a href="https://github.com/ubsan">Nicole Mazzuca</a>, <a href="https://github.com/Aatch">James Miller</a>,
<a href="https://github.com/tsion">Scott Olson</a>, and 👻👻👻 for reading and giving feedback on
this post.</em></p>
<p>{% include comments.html c=page.comments %}</p>
<hr />
<p>layout: post
title: &quot;Effectively Using Iterators In Rust&quot;
tags:</p>
<ul>
<li>rustlang
status: publish
type: post
published: true</li>
</ul>
<hr />
<p>In Rust, you quickly learn that vector and slice types are not iterable themselves. Depending on which tutorial or example you see first, you call <code>.iter()</code> or <code>.into_iter()</code>. If you do not realize both of these functions exist or that they do different things, you may find yourself fighting with the compiler to get your code to work. Let us take a journey through the world of iterators and figure out the differences between iter() and into_iter() in Rust.</p>
<a class="header" href="print.html#iter" id="iter"><h2>Iter</h2></a>
<p>Most examples I have found use <code>.iter()</code>. We can call <code>v.iter()</code> on something like a vector or slice. This creates an <code>Iter&lt;'a, T&gt;</code> type and it is this <code>Iter&lt;'a, T&gt;</code> type that implements the <code>Iterator</code> trait and allows us to call functions like <code>.map()</code>. It is important to note that this <code>Iter&lt;'a, T&gt;</code> type only has a reference to <code>T</code>. This means that calling <code>v.iter()</code> will create a struct that <em>borrows</em> from <code>v</code>. Use the <code>iter()</code> function if you want to iterate over the values by <em>reference</em>.</p>
<p>Let us write a simple map/reduce example:</p>
<pre><pre class="playpen"><code class="language-rust">fn use_names_for_something_else(_names: Vec&lt;&amp;str&gt;) {
}

fn main() {
    let names = vec![&quot;Jane&quot;, &quot;Jill&quot;, &quot;Jack&quot;, &quot;John&quot;];
    
    let total_bytes = names
        .iter()
        .map(|name: &amp;&amp;str| name.len())
        .fold(0, |acc, len| acc + len );
        
    assert_eq!(total_bytes, 16);
    use_names_for_something_else(names);
}
</code></pre></pre>
<p>In this example, we are using <code>.map()</code> and <code>.fold()</code> to count the number of bytes (not characters! Rust strings are UTF-8) for all strings in the <code>names</code> vector. We <a href="/2015/06/09/strategies-for-solving-cannot-move-out-of-borrowing-errors-in-rust.html">know</a> that the <code>len()</code> function can use an immutable reference. As such, we prefer <code>iter()</code> instead of <code>iter_mut()</code> or <code>into_iter()</code>. This allows us to <em>move</em> the <code>names</code> vector later if we want. I put a bogus <code>use_names_for_something()</code> function in the example just to prove this. If we had used <code>into_iter()</code> instead, the compiler would have given us an <em>error: use of moved value: <code>names</code></em> response.</p>
<p>The closure used in <code>map()</code> does not require the <code>name</code> parameter to have a type, but I specified the type to show how it is being passed as a reference. Notice that the type of name is <code>&amp;&amp;str</code> and not <code>&amp;str</code>. The string <code>&quot;Jane&quot;</code> is of type <code>&amp;str</code>. The <code>iter()</code> function creates an iterator that has a <em>reference</em> to each element in the <code>names</code> vector. Thus, we have a <em>reference</em> to a <em>reference</em> of a string slice. This can get a little unwieldy and I generally do not worry about the type. However, if we are destructuring the type, we do need to specify the reference:</p>
<pre><code class="language-rust ignore">fn main() {
    let player_scores = [
        (&quot;Jack&quot;, 20), (&quot;Jane&quot;, 23), (&quot;Jill&quot;, 18), (&quot;John&quot;, 19),
    ];

    let players = player_scores
        .iter()
        .map(|(player, _score)| {
            player
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    assert_eq!(players, [&quot;Jack&quot;, &quot;Jane&quot;, &quot;Jill&quot;, &quot;John&quot;]);
}
</code></pre>
<p>In the above example, the compiler will complain that we are specifying the type <code>(_, _)</code> instead of <code>&amp;(_, _)</code>. Changing the pattern to <code>&amp;(player, _score)</code> will satisfy the compiler.</p>
<p>Rust is immutable by default and iterators make it easy to manipulate data without needing mutability. If you do find yourself wanting to mutate some data, you can use the <code>iter_mut()</code> method to get a mutable reference to the values. Example use of <code>iter_mut()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut teams = [
        [ (&quot;Jack&quot;, 20), (&quot;Jane&quot;, 23), (&quot;Jill&quot;, 18), (&quot;John&quot;, 19), ],
        [ (&quot;Bill&quot;, 17), (&quot;Brenda&quot;, 16), (&quot;Brad&quot;, 18), (&quot;Barbara&quot;, 17), ]
    ];
    
    let teams_in_score_order = teams
        .iter_mut()
        .map(|team| {
            team.sort_by(|&amp;a, &amp;b| a.1.cmp(&amp;b.1).reverse());
            team
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
        
    println!(&quot;Teams: {:?}&quot;, teams_in_score_order);
}
</code></pre></pre>
<p>Here we are using a mutable reference to sort the list of players on each team by highest score. The <code>sort_by()</code> function performs the sorting of the Vector/slice in place. This means we need the ability to mutate <code>team</code> in order to sort. I do not use <code>.iter_mut()</code> often, but sometimes functions like <code>.sort_by()</code> provide no immutable alternative.</p>
<p>I tend to use <code>.iter()</code> most. I try to be very concious and deliberate about when I <em>move</em> resources and default to borrowing (or referencing) first. The reference created by <code>.iter()</code> is short-lived, so we can <em>move</em> or use our original value afterwards. If you find yourself running into <em>does not live long enough</em>, <em>move</em> errors or using the <code>.clone()</code> function, this is a sign that you probably want to use <code>.into_iter()</code> instead.</p>
<a class="header" href="print.html#intoiter" id="intoiter"><h2>IntoIter</h2></a>
<p>Use the <code>into_iter()</code> function when you want to <em>move</em>, instead of <em>borrow</em>, your value. The <code>.into_iter()</code> function creates a <code>IntoIter&lt;T&gt;</code> type that now has ownership of the original value. Like <code>Iter&lt;'a, T&gt;</code>, it is this <code>IntoIter&lt;T&gt;</code> type that actually implements the <code>Iterator</code> trait. The word <em>into</em> is commonly used in Rust to signal that <code>T</code> is being <em>moved</em>. The docs also use the words <em>owned</em> or <em>consumed</em> interchangeably with <em>moved</em>. I normally find myself using <code>.into_iter()</code> when I have a function that is transforming some values:</p>
<pre><pre class="playpen"><code class="language-rust">fn get_names(v: Vec&lt;(String, usize)&gt;) -&gt; Vec&lt;String&gt; {
    v.into_iter()
        .map(|(name, _score)| name)
        .collect()
}

fn main() {
    let v = vec!( (&quot;Herman&quot;.to_string(), 5));
    let names = get_names(v);

    assert_eq!(names, [&quot;Herman&quot;]);
}
</code></pre></pre>
<p>The <code>get_names</code> function is plucking out the name from a list of tuples. I chose <code>.into_iter()</code> here because we are transforming the tuple into a <code>String</code> type.</p>
<p>The concept behind <code>.into_iter()</code> is similar to the <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html">core::convert::Into</a> trait we discussed when accepting <code>&amp;str</code> and <code>String</code> in a function. In fact, the <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html">std::iter::Iterator</a> type implements <a href="https://github.com/rust-lang/rust/blob/b5b3a99f84f2b4dbf9495dccd7112c74f4357acc/src/libcore/iter.rs#L1184-1192">std::iter::IntoIterator</a> too. That means we can do something like <code>vec![1, 2, 3, 4].into_iter().into_iter().into_iter()</code>. In each subsequent call to <code>.into_iter()</code> just returns itself. This is an example of the <a href="https://en.wikipedia.org/wiki/Identity_function">identity function</a>. I mention that only because I find it interesting to identify functional concepts that I see being used in the wild.</p>
<a class="header" href="print.html#how-for-loops-actually-work" id="how-for-loops-actually-work"><h3>How for Loops Actually Work</h3></a>
<p>One of the first errors a new Rustacean will run into is the <em>move</em> error after using a for loop:</p>
<pre><code class="language-rust ignore">fn main() {
    let values = vec![1, 2, 3, 4];

    for x in values {
        println!(&quot;{}&quot;, x);
    }

    let y = values; // move error
}
</code></pre>
<p>The question we immediately ask ourselves is &quot;How do I create a for loop that uses a reference?&quot;. A <a href="https://doc.rust-lang.org/stable/std/iter/index.html">for loop</a> in Rust is really just syntatic sugar around <code>.into_iter()</code>. From the manual:</p>
<pre><code class="language-rust ignore">// Rough translation of the iteration without a `for` iterator.
let mut it = values.into_iter();
loop {
    match it.next() {
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; break,
    }
}
</code></pre>
<p>Now that we know <code>.into_iter()</code> creates a type <code>IntoIter&lt;T&gt;</code> that <em>moves</em> <code>T</code>, this behavior makes perfect sense. If we want to use <code>values</code> after the for loop, we just need to use a reference instead:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let values = vec![1, 2, 3, 4];

    for x in &amp;values {
        println!(&quot;{}&quot;, x);
    }

    let y = values; // perfectly valid
}
</code></pre></pre>
<p>Instead of moving <code>values</code>, which is type <code>Vec&lt;i32&gt;</code>, we are moving <code>&amp;values</code>, which is type <code>&amp;Vec&lt;i32&gt;</code>. The for loop only <em>borrows</em> <code>&amp;values</code> for the duration of the loop and we are able to <em>move</em> <code>values</code> as soon as the for loop is done.</p>
<a class="header" href="print.html#coreitercloned" id="coreitercloned"><h2>core::iter::Cloned</h2></a>
<p>There are times when you want create a new value when iterating over your original value. You might first try something like:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = vec![&quot;Jill&quot;, &quot;Jack&quot;, &quot;Jane&quot;, &quot;John&quot;];

    let _ = x
        .clone()
        .into_iter()
        .collect::&lt;Vec&lt;_&gt;&gt;();
}
</code></pre></pre>
<p>Exercise for the reader: <em>Why would <code>.iter()</code> not work in this example?</em></p>
<p>While this is valid, we want to give Rust every chance to optimize our code. What if we only wanted the first two names from that list?</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = vec![&quot;Jill&quot;, &quot;Jack&quot;, &quot;Jane&quot;, &quot;John&quot;];

    let _ = x
        .clone()
        .into_iter()
        .take(2)
        .collect::&lt;Vec&lt;_&gt;&gt;();
}
</code></pre></pre>
<p>If we clone all of <code>x</code>, then we are cloning all four elements, but we only need two of them. We can do better by using <code>.map()</code> to clone the elements of the underlying iterator:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = vec![&quot;Jill&quot;, &quot;Jack&quot;, &quot;Jane&quot;, &quot;John&quot;];

    let y = x
        .iter()
        .map(|i| i.clone())
        .take(2)
        .collect::&lt;Vec&lt;_&gt;&gt;();
}
</code></pre></pre>
<p>The Rust compiler can now optimize this code and only clone two out of the four elements of <code>x</code>. This pattern is used so often that Rust core now has a special function that does this for us called <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.cloned">cloned()</a>. This is a recent addition and will be stable in Rust 1.1. Our code now looks something like:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = vec![&quot;Jill&quot;, &quot;Jack&quot;, &quot;Jane&quot;, &quot;John&quot;];

    let y = x
        .iter()
        .cloned()
        .take(2)
        .collect::&lt;Vec&lt;_&gt;&gt;();
}
</code></pre></pre>
<a class="header" href="print.html#iterators-outside-of-core" id="iterators-outside-of-core"><h2>Iterators Outside of Core</h2></a>
<p>There is a really great crate, called <a href="https://crates.io/crates/itertools">itertools</a>, that provides extra iterator adaptors, iterator methods and macros. If you are looking for some iterator functionality in the Rust docs and do not see it, there is a good chance it is part of itertools. I recently added an <a href="http://bluss.github.io/rust-itertools/doc/itertools/trait.Itertools.html#method.sort_by">itertools::IterTools::sort_by()</a> function so we can sort collections without needed to use a mutable iterator. One of the nice things about working with Rust is that the documentation looks the same across all these crates. The <a href="http://bluss.github.io/rust-itertools/doc/itertools/index.html">documentation for itertools</a> looks the same as the <a href="https://doc.rust-lang.org/std/">documentation for Rust std library</a>.</p>
<a class="header" href="print.html#related" id="related"><h2>Related</h2></a>
<ul>
<li><a href="/2015/05/06/creating-a-rust-function-that-accepts-string-or-str.html">Creating a Rust function that accepts String or &amp;str</a></li>
</ul>
<hr />
<p>layout: default
title: What does Rust's “unsafe” mean?
description: &gt;
Exploring Rust's escape hatch for writing low-level code that the
powerful type system of Rust cannot guarantee to be safe.
comments:
r_rust: &quot;http://www.reddit.com/r/rust/comments/2bhwgc/what_does_rusts_unsafe_mean/&quot;
r_programming: &quot;http://www.reddit.com/r/programming/comments/2bhwhl/what_does_rusts_unsafe_mean/&quot;
# hn: &quot;https://news.ycombinator.com/item?id=8288572&quot;</p>
<hr />
<p><a href="http://rust-lang.org/">Rust</a> is an in-development<sup class="footnote-reference"><a href="print.html#version">1</a></sup> systems
programming language with a strong focus on no-overhead memory
safety. This is achieved through a powerful type system (with
similarities to Haskell), and careful tracking of ownership and
pointers, guaranteeing safety. However, this is too restrictive for a
low-level systems language, an escape hatch is occasionally
required. Enter the <code>unsafe</code> keyword.</p>
<div class="footnote-definition" id="version"><sup class="footnote-definition-label">1</sup>
<p>The code in this post compiles with <code>rustc 0.12.0-pre-nightly (aa0e35bc6 2014-07-22 00:26:21 +0000)</code>.</p>
<a class="header" href="print.html#poking-holes-in-memory-safety" id="poking-holes-in-memory-safety"><h2>Poking holes in memory safety</h2></a>
<p>Rust aims to be memory safe, so that, by default, code cannot crash
(or be exploited) due to dangling pointers or iterator
invalidation. However, there are things that cannot fit into the type
system, for example, it is not possible to get the raw interactions
with the operating system and system libraries (like memory allocators
and thread spawning) to be truly safe. Detailed human knowledge about
how to use them safely is required to be encoded at some point, and
this is not easily checkable by a compiler: mistakes can be made.</p>
<p>Other memory safe languages (e.g. managed ones like Python or Haskell)
have all this knowledge encoded in the implementations of their
underlying virtual machines/runtime systems, usually written in
C. Rust doesn't have a heavy-weight VM or runtime, but still needs to
provide (preferably safe) interfaces in some manner.</p>
<p>Rust fills these holes with the <code>unsafe</code> keyword, which opts in to
possibly dangerous behaviour; like calling into the operating system
and external libraries via
<a href="http://doc.rust-lang.org/master/guide-ffi.html">the foreign function interface (FFI)</a>,
or handling possibly-invalid machine pointers directly.</p>
<p>Rust uses <code>unsafe</code> to build all the abstractions seen in the standard
library: the vast majority of it is written in Rust, including
fundamental types like
<a href="http://doc.rust-lang.org/master/std/rc/struct.Rc.html">the reference counted <code>Rc</code></a>,
<a href="http://doc.rust-lang.org/master/std/vec/struct.Vec.html">the dynamic vector <code>Vec</code></a>,
and
<a href="http://doc.rust-lang.org/master/std/collections/hashmap/struct.HashMap.html"><code>HashMap</code></a>,
with only
<a href="https://github.com/rust-lang/rust/tree/82ec1aef293ddc5c6373bd7f5ec323fafbdf7901/src/rt">a few small C shims</a>
and some external non-Rust libraries like jemalloc and libuv.</p>
<a class="header" href="print.html#unsafe" id="unsafe"><h2><code>unsafe</code></h2></a>
<p>There are two ways in which one can opt-in to these possibly dangerous
behaviours: with an <code>unsafe</code> block, or with an <code>unsafe</code> function.</p>
<p>{% highlight rust linenos %}
// calling some C functions imported via FFI:</p>
<p>unsafe fn foo() {
some_c_function();
}
fn bar() {
unsafe {
another_c_function();
}
}
fn baz() {
// illegal, not inside an <code>unsafe</code> context
// yet_another_c_function();
}
{% endhighlight %}</p>
<p>Being inside an <code>unsafe</code> context allows one to (not necessarily
complete):</p>
<ol>
<li>call functions marked <code>unsafe</code> (this includes FFI functions)</li>
<li>dereference raw pointers (the <code>*const</code> and <code>*mut</code> types), which can
possibly be <code>NULL</code>, or otherwise invalid</li>
<li>access a mutable global variable</li>
<li>use inline assembly</li>
</ol>
<p>All of these can easily cause large problems. For example, a shared
reference <code>&amp;T</code> is a machine pointer, but it <em>must</em> always point to a
valid value of type <code>T</code>; all four of the above can cause this to be
violated:</p>
<ol>
<li>
<p>There is an <code>unsafe</code> function
<a href="http://doc.rust-lang.org/master/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a>
which takes the bytes of its argument and pretends they are of any
type one wants, thus, one can create an invalid <code>&amp;</code> pointer by
reinterpreting an integer: <code>transmute::&lt;uint, &amp;Vec&lt;int&gt;&gt;(0)</code>.</p>
</li>
<li>
<p>A raw pointer <code>p: *const T</code> can legally be <code>NULL</code>. The
&quot;rereferencing&quot; operation <code>&amp;*p</code> creates a reference <code>&amp;T</code> pointing to
<code>p</code>s data, a no-op at runtime, since <code>*const T</code> and <code>&amp;T</code> are both
just a single pointer under the hood. If <code>p</code> is <code>NULL</code> this allows
one to create a <code>NULL</code> <code>&amp;T</code>: invalid!</p>
</li>
<li>
<p>If one has <code>static mut X: Option&lt;i64&gt; = Some(1234);</code>, one can use
pattern matching to get a reference <code>r: &amp;i64</code> pointing to the <code>1234</code>
integer, but another thread can overwrite <code>X</code> with <code>None</code>, leaving
<code>r</code> dangling.</p>
</li>
<li>
<p>Inline assembly can set arbitrary registers to arbitrary values,
including setting a register meant to be holding a <code>&amp;T</code> to zero.</p>
</li>
</ol>
<a class="header" href="print.html#what-does-unsafe-really-mean" id="what-does-unsafe-really-mean"><h2>What does <code>unsafe</code> really mean?</h2></a>
<p>An <code>unsafe</code> context is the programmer telling the compiler that the
code is guaranteed to be safe due to invariants impossible to express
in the type system, and that it satisfies
<a href="http://doc.rust-lang.org/nightly/reference.html#behavior-considered-undefined">the invariants that Rust itself imposes</a>.</p>
<p>These invariants are assumed to never be broken, even inside <code>unsafe</code>
code blocks, and the compiler compiles and optimises with this
assumption. Thus, breaking any of those invariants is
<a href="https://en.wikipedia.org/wiki/Undefined_behaviour">undefined behaviour</a><sup class="footnote-reference"><a href="print.html#ub-llvm">2</a></sup>
and can leave a program doing &quot;anything&quot;, even making
<a href="http://www.catb.org/jargon/html/N/nasal-demons.html">demons fly out your nose</a>.</p>
</div>
<div class="footnote-definition" id="ub-llvm"><sup class="footnote-definition-label">2</sup>
<p><a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">&quot;What Every C Programmer Should Know About Undefined Behaviour&quot;</a>
is a series of articles highlighting how insidious undefined behaviour
can be, leading to subtly (or not so subtly) broken programs.</p>
<p>That is, an <code>unsafe</code> context is not a free pass to mutate anything and
everything, nor is it a free pass to mangle pointers and alias
references: all the normal rules of Rust still apply, the compiler is
just giving the programmer more power, at the expense of leaving it up
to the programmer to ensure everything is safe.</p>
<p>A non-<code>unsafe</code> function using <code>unsafe</code> internally <em>should</em> be
implemented to be safe to call; that is, there is no circumstance or
set of arguments that can make the function violate
<a href="http://doc.rust-lang.org/nightly/reference.html#behavior-considered-undefined">any invariants</a>. If
there are such circumstances, it should be marked <code>unsafe</code>.</p>
<p>This rule is most important for public, exported functions; private
functions are guaranteed to only be called in a limited set of
configurations (since all calls are in the crate/module in which it is
defined), so the author has more flexibility about what sort of safety
guarantees they give. However, marking possibly-dangerous things
<code>unsafe</code> helps the compiler help the programmer do the right thing, so
is encouraged even for private items.</p>
</div>
<a class="header" href="print.html#case-study-vec" id="case-study-vec"><h3>Case study: <code>Vec</code></h3></a>
<p>The <code>Vec&lt;T&gt;</code> type is
<a href="https://github.com/rust-lang/rust/blob/82ec1aef293ddc5c6373bd7f5ec323fafbdf7901/src/libcollections/vec.rs#L55-L59">defined</a>
as:</p>
<p>{% highlight rust linenos %}
pub struct Vec<T> {
len: uint,
cap: uint,
ptr: *mut T
}
{% endhighlight %}</p>
<p>There are (at least) two invariants here:</p>
<ol>
<li><code>ptr</code> holds an allocation with enough space for <code>cap</code> values of type <code>T</code></li>
<li>That allocation holds <code>len</code> valid values of type <code>T</code> (i.e. the
first <code>len</code> out of <code>cap</code> of the <code>T</code>s are valid, implying <code>len &lt;= cap</code>)</li>
</ol>
<p>It's not feasible to express these in Rust's type system, so they are
guaranteed by a careful implementation. The implementation is then
forced to use <code>unsafe</code> to assuage the compiler's doubts about certain
operations. The compiler does not and cannot understand the invariants
stated above, and so cannot be sure that
<a href="https://github.com/rust-lang/rust/blob/82ec1aef293ddc5c6373bd7f5ec323fafbdf7901/src/libcollections/vec.rs#L1430">creating a slice view into the vector</a>
is safe. It is implemented like so:</p>
<p>{% highlight rust linenos %}
fn as_slice&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a [T] {
unsafe { mem::transmute(Slice { data: self.as_ptr(), len: self.len }) }
}
{% endhighlight %}</p>
<p>And you can see that it could easily be unsafe e.g. if one
accidentally wrote <code>self.cap</code> instead of <code>self.len</code>, the resulting
slice would be too long and the last elements of it would be
uninitialised data. The compiler can't verify that this is correct,
and so assumes the worst, disallowing it without the explicit opt-in.</p>
<p>Another thing to note is these <code>Vec</code> invariants are required to always
hold or else <code>Vec</code> will be allowing incorrect behaviour to happen via
the safe methods it exposes (e.g. if someone could increase <code>len</code>
without initialising the elements appropriately, the <code>as_slice</code> method
above would be broken).</p>
<p>Unfortunately, it's not possible to get the Rust compiler to directly
enforce them, so the <code>Vec</code> API has to be careful to guarantee that
they can't be violated; part of this is keeping the fields private, so
they cannot be directly changed, another part is being careful to mark
the <code>unsafe</code> parts of the API as <code>unsafe</code>, e.g.
<a href="http://doc.rust-lang.org/master/collections/vec/struct.Vec.html#method.set_len">the <code>set_len</code> method</a>
can directly change the <code>len</code> field.</p>
<a class="header" href="print.html#case-study-malloc" id="case-study-malloc"><h3>Case study: <code>malloc</code></h3></a>
<p>The C function <code>malloc</code> is described by my man page as the following:</p>
<blockquote>
<p>The <code>malloc()</code> function allocates size bytes and returns a pointer to the
allocated memory.  The memory is not initialized.  If size is  0,  then
<code>malloc()</code>  returns either <code>NULL</code>, or a unique pointer value that can later
be successfully passed to <code>free()</code>.</p>
<p>The <code>malloc()</code> and <code>calloc()</code> functions return a pointer to  the  allocated
memory,  which  is  suitably  aligned for any built-in type.  On error,
these functions return <code>NULL</code>.  [...].</p>
</blockquote>
<p>The <code>libc</code> crate predefines most of the common symbols from the <code>libc</code>
on various platforms, including <code>libc::malloc</code>. Let's write a safe
program that creates memory for, stores and prints an 8-byte <code>i64</code>
integer, carefully justifying why we know more than the compiler, and
thus why each <code>unsafe</code> is safe (in a perfect world all <code>unsafe</code> blocks
would be justified/proved correct).</p>
<pre><code class="language-rust ignore">extern crate libc;
use std::ptr;

fn main() {
    let pointer: *mut i64 = unsafe {
        // rustc doesn't know what `malloc` does, and so doesn't know
        // that calling it with argument 8 is always safe; but we do,
        // so we override the compiler's concern with
        // `unsafe`. (`malloc` returns a `*mut libc::c_void` so we
        // need to cast it to the type we want.)
        libc::malloc(8) as *mut i64
    };

    // we know that the only failure condition is the pointer being
    // NULL, in any other circumstance the pointer points to a valid
    // memory allocation of at least 8 bytes.
    if pointer.is_null() {
        println!(&quot;could not allocate&quot;);
    } else {
        // here, the only thing missing is initialisation, the memory
        // is valid but uninitialised, so lets fix that. Since it is
        // not initialised, we have to be careful to avoid running
        // destructors on the old memory; via `std::ptr::write`.
        unsafe {
            // allocation is valid, and the memory is uninitialised,
            // so this is safe and correct.
            ptr::write(pointer, 1234i64);
        }

        // now `pointer` is looking at initialised, valid memory, so
        // it is valid to read from it, and to obtain a reference to
        // it.
        let data: &amp;i64 = unsafe { &amp;*pointer };
        println!(&quot;The data is {}&quot;, *data);
        // prints: The data is 1234
    }

    // (leaking memory is not `unsafe`.)
}
</code></pre>
<p>(Keen eyes will note that <code>i64</code> doesn't have a destructor and so the
<a href="http://doc.rust-lang.org/master/std/ptr/fn.write.html"><code>ptr::write</code></a>
call isn't strictly required, but it's good practice.)</p>
<a class="header" href="print.html#faq-why-isnt-unsafe-viral" id="faq-why-isnt-unsafe-viral"><h2>FAQ: Why isn't <code>unsafe</code> viral?</h2></a>
<p>One <em>might</em> expect a function containing an <code>unsafe</code> block to be
<code>unsafe</code> to call, that is, <code>unsafe</code>ty infects everything it touches,
similar to how Haskell forces one to mark all impure calculations with
the <code>IO</code> type.</p>
<p>However, this is not the case, <code>unsafe</code> is just an implementation
detail; if a safe function uses <code>unsafe</code> internally, it just means the
author has been forced to step around the type system, but still
exposes a safe interface.</p>
<p>More pragmatically, if <code>unsafe</code> were viral, every Rust program ever
would be entirely <code>unsafe</code>, since the whole standard library is
written in Rust, built on top of <code>unsafe</code> internals.</p>
<a class="header" href="print.html#conclusion-1" id="conclusion-1"><h2>Conclusion</h2></a>
<p>The <code>unsafe</code> marker is a way to step around Rust's type system; by
telling <code>rustc</code> that there are external conditions/invariants that
guarantee correctness: the compiler steps back and locally leaves the
programmer to verify that
<a href="http://doc.rust-lang.org/reference.html#behavior-considered-undefined">various properties</a>
hold. This allows Rust to write very low-level code like C, but still
be memory safe by default, by forcing programmers to opt-in to the
risky behaviour.</p>
<p>The
<a href="http://doc.rust-lang.org/master/guide-unsafe.html">&quot;Writing Safe Unsafe and Low-Level Code&quot;</a>
provides guidance and tips about using <code>unsafe</code> correctly.</p>
<p>{% include comments.html c=page.comments %}</p>
<hr />
<p>title: Memory Leaks are Memory Safe
layout: default</p>
<p>description: &gt;
Memory unsafety and memory leaks are distinct concepts, despite
their names. Languages that are merely memory safe (both Rust and
GC-reliant managed ones) have no guarantee of preventing memory leaks.</p>
<p>comments:
r_rust: &quot;https://www.reddit.com/r/rust/comments/4dgvvh/memory_leaks_are_memory_safe_huon_on_the_internet/&quot;
users: &quot;https://users.rust-lang.org/t/memory-leaks-are-memory-safe/5288?u=huon&quot;
--    r_programming: &quot;&quot;
--    hn: &quot;&quot;</p>
<hr />
<p><a href="https://en.wikipedia.org/wiki/Memory_safety"><em>Memory unsafety</em></a> and <a href="https://en.wikipedia.org/wiki/Memory_leak"><em>memory leaks</em></a> are arguably the two
categories of bugs that have received the most attention for
prevention and mitigation. As their names suggest, they are in the
same part of &quot;bug space&quot;, however they are in some ways diametric
opposites, and solving one does not solve the other. The widespread
use of memory-safe managed languages hammers this point home: they
avoid some memory unsafety by presenting a &quot;leak everything&quot; model to
programmers.</p>
<p>Put simply: <strong>memory unsafety is doing something with invalid data,
a memory leak is <em>not</em> doing something with valid data</strong>. In table
form:</p>
<table><thead><tr></tr></thead><tbody>
<tr><td> Used           </td><td> 👍 </td><td> Memory unsafety </td></tr>
<tr><td> Not used            </td><td> Memory leak </td><td> 👍 </td></tr>
</tbody></table>
<p>The best programs lie in the 👍 cells only: they manipulate valid
things, and don't manipulate invalid ones. Passable programs might
also have some valid data that they don't use (leak memory), but bad
ones will try to use invalid data.</p>
<p>When a language, such as Rust, advertises itself as memory <em>safe</em>, it
isn't saying anything about whether memory <em>leaks</em> are impossible.</p>
<a class="header" href="print.html#consequences" id="consequences"><h2>Consequences</h2></a>
<p>The most important difference between memory unsafety and memory leaks
in practice is the scope of their possible results, with one easily
very serious, and the other usually just annoying.</p>
<p>Memory safety is a key building block in any other form of
safety/program correctness. If a program is not memory safe, there are
very few guarantees about its behaviour, due to the possibility of
memory corruption. A malicious party interacting with a memory unsafe
program may be able to exploit the unsafety to
<a href="https://en.wikipedia.org/wiki/Heartbleed">read private keys straight out of a server's memory</a> or
to execute arbitrary code on someone else's computer.</p>
<p>On the other hand, a memory leak will generally, at worst, lead to a
denial-of-service, where a useful program is killed due to using too
much memory (and, as it grows to this stage, the computer may be
rendered essentially inoperable due to memory pressure). This also can
be caused by a malicious attacker, but the damage is usually very much
more controlled. Of course, a denial-of-service can be extremely
annoying, and there are places where this is a critical problem, but
memory unsafety would generally be equally problematic---more likely,
more problematic. (Additionally, given memory unsafety's inherent lack
of control, a problem there could easily lead to a denial-of-service
similar/identical to that which a memory leak can cause.)</p>
<p>Given this, most programming languages choose to tolerate memory leaks
(they allow data not be deallocated/cleaned up after the last time it
is used), but not memory unsafety. That is, most &quot;memory safe
languages&quot; guarantee all programs written in them have no
unsafety<sup class="footnote-reference"><a href="print.html#optin">1</a></sup>, and they only try---usually, try hard---to help
programmers avoid leaks, but without making a hard promise.</p>
<div class="footnote-definition" id="optin"><sup class="footnote-definition-label">1</sup>
<p>More specifically, programming languages will guarantee that
one can only get unsafety by explicitly opting in to it, in some
form, such as via Python's <code>ctypes</code> module, or Rust's <code>unsafe</code>
keyword.</p>
<a class="header" href="print.html#delete-free" id="delete-free"><h2><code>delete free</code></h2></a>
<p>There are a few different ways to get memory unsafety, but there's one
category (from the Wikipedia article) that stands out when we're
discussing memory management:</p>
<blockquote>
<ul>
<li><strong>Dynamic memory errors</strong> - incorrect management of dynamic memory and pointers:
<ul>
<li><strong>Dangling pointer</strong> - a pointer storing the address of an object that has been deleted.</li>
<li><strong>Double free</strong> - repeated calls to free may prematurely free a new object at the same address. If the exact address has not been reused, other corruption may occur, especially in allocators that use free lists.</li>
<li><strong>Invalid free</strong> - passing an invalid address to free can corrupt the heap.</li>
<li><strong>Null pointer accesses</strong> will cause an exception or program termination in most environments, but can cause corruption in operating system kernels or systems without memory protection, or when use of the null pointer involves a large or negative offset.</li>
</ul>
</li>
</ul>
</blockquote>
<p>In that list, only null pointer accesses aren't caused by deallocating
memory---calling the <code>free</code> function to mark an allocation as
unused/return it to the operating system---incorrectly. And thus, one
way to be guaranteed to avoid three quarters of those possibilities is
to just never call <code>free</code>: if memory is never released, it is
impossible to suffer from the problems caused by releasing it. In
terms of the table above, removing <code>free</code> is removing the &quot;Invalid
data&quot; column: all data is always valid.</p>
<p>Of course, just disallowing <code>free</code> has some downsides<sup class="footnote-reference"><a href="print.html#lockfree">2</a></sup>, particularly
making it very annoying to write programs that don't eventually use
all available memory. However, computers are infallible in ways humans
are not, so maybe we could allow them to call <code>free</code>...</p>
</div>
<div class="footnote-definition" id="lockfree"><sup class="footnote-definition-label">2</sup>
<p>It also has some upsides beyond just less memory
unsafety: if one is OK without <code>free</code>, it becomes much easier to
write programs where the lifetime of data is unclear, which makes
many concurrent algorithms easier to write. That said, there are
schemes for writing such code when manual <code>free</code>s are required,
such as <a href="https://en.wikipedia.org/wiki/Hazard_pointer">hazard pointers</a> and the simpler
<a href="http://aturon.github.io/blog/2015/08/27/epoch/">epoch-based memory reclamation</a>.</p>
</div>
<a class="header" href="print.html#optimising-leaks" id="optimising-leaks"><h2>Optimising leaks</h2></a>
<p>A large fraction of modern code is written in languages designed to be
memory safe, languages like Java, Javascript, Python and Ruby. They
have no explicit <code>free</code>, and so automatically manage memory (hence
&quot;managed language&quot;) via a <em>garbage collector</em> built into the runtime
systems shipped with the languages' compilers and interpreters.</p>
<p>At its core<sup class="footnote-reference"><a href="print.html#layers">3</a></sup>, garbage collection is a way to make it feasible
to expose a programming model where all allocations leak. Letting a
garbage collector manage every allocation theoretically allows
programs (and programmers) to pretend that memory is infinite, not
needing to carefully track when memory isn't needed any more: programs
do whatever they want, and the GC will automatically and dynamically
free chunks of memory that are guaranteed to be unneeded, ensuring the
program's memory use remains under control. Almost all garbage
collectors determine neededness conservatively by finding things no longer
accessible from the main program (the garbage collector itself needs
to keep track of/have access to all allocations).</p>
<div class="footnote-definition" id="layers"><sup class="footnote-definition-label">3</sup>
<p>It's worth noting that the detailed knowledge of memory
layout required for a top-flight garbage collectors lends itself
to other tricks, such as allocations usually being a cheap pointer
bump with a generational GC, and the ability for a moving GC to
shift data around, improving cache locality (especially useful
given the generally pointer-heavy nature of most managed
languages). However, these tricks are orthogonal to both memory
safety and memory leaks.</p>
<p>In practice, the programmer has to think about non-infinite
memory and its consequences a little more often than never, but memory
unsafety concerns <em>are</em> removed, as desired. High-performance code
often has to chose particular coding patterns to work-around
deficiencies with garbage collectors (such as object pools to avoid
touching the GC in tight loops), and one can accidentally create
<a href="https://en.wikipedia.org/wiki/Lapsed_listener_problem">chains of references</a> that keep large trees of data
unnecessarily alive.</p>
<p>However, even in the face of practical concerns, the point stands:
without <code>free</code>, there's no scope for some types of memory unsafety.</p>
<!--(Due credit: I think I first heard an idea along the lines "GC is an
optimisation for leaking" from
[Alexis Beingessner](https://twitter.com/Gankro).)-->
<a class="header" href="print.html#less-leaky-abstractions" id="less-leaky-abstractions"><h2>Less leaky abstractions</h2></a>
<p>Given my status, I'd be remiss to mention an alternative to the
leak-everything managed paradigm: instead using a technique that
crosses out the whole &quot;Invalid data&quot; column, one can be more precise
and cross out only the &quot;Memory unsafety&quot; cell. The <a href="https://www.rust-lang.org/">Rust programming language</a> does this.</p>
<p>Rust doesn't have C-style manual memory management, but rather
RAII/scope-based resource management similar to C++, allowing types to
have destructors for automatic clean-up. It does not literally have a
<code>free</code> function users must remember to call (removing most of the
&quot;manual&quot;), but the <a href="http://doc.rust-lang.org/std/mem/fn.drop.html"><code>drop</code></a> function serves the role of explicit
<code>free</code>, allowing one to explicitly cause the destructor to be run on a
value, thus invalidating it. In contrast to both C and C++, the
language prevents use of such data at compile time to avoid memory
unsafety.</p>
<p>However, a programming model that's not &quot;leak everything&quot; doesn't mean
it is &quot;leak nothing&quot;: the revised table for Rust (and anything
similar) still has its memory leak cell.</p>
<table><thead><tr></tr></thead><tbody>
<tr><td> Used           </td><td> 👍 </td><td> Impossible </td></tr>
<tr><td> Not used            </td><td> Memory leak </td><td> 👍 </td></tr>
</tbody></table>
<p>I'm not including this section because I think it's a great promotion
of Rust (being allowed to have invalid data that one can't use doesn't
exactly sound world-shaking<sup class="footnote-reference"><a href="print.html#moves">4</a></sup>...), but because that is the hole
which this article is filling. The similarity of the phrases &quot;memory
leak&quot; and &quot;memory safety&quot; regularly tricks people who have read &quot;Rust
is memory safe&quot; into thinking Rust is (just) preventing memory leaks,
leading to legitimate doubts about what Rust offers instead of, say,
modern C++ in the space of low-level systems languages.  <strong>Rust
disallows memory unsafety, but memory leaks are possible</strong>.</p>
</div>
<div class="footnote-definition" id="moves"><sup class="footnote-definition-label">4</sup>
<p>It's pretty useful, in that it allows move semantics to
work, but that's an article for another time, perhaps.</p>
<a class="header" href="print.html#stdmemforget" id="stdmemforget"><h3><code>std::mem::forget</code></h3></a>
<p>Finally, returning to the title, Rust has the <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>forget</code></a>
function, which throws away a value without actually running the
destructor while still marking it invalid as if freed normally, thus
possibly leaking memory. For a long time, this was marked as <code>unsafe</code>,
that is, Rust was implicitly including memory leaks as something the
programmer must opt-in to, like the risk of memory unsafety. However,
this was not correct in practice, as things like reference cycles and
thread deadlock could cause memory to leak. Rust <a href="https://github.com/rust-lang/rfcs/blob/master/text/1066-safe-mem-forget.md">decided</a> to
make <code>forget</code> safe, focusing its guarantees on just preventing memory
unsafety and instead making only best-effort attempts
towards preventing memory leaks (like essentially all other
languages, memory safe and otherwise).</p>
<a class="header" href="print.html#not-all-is-lost" id="not-all-is-lost"><h3>Not all is lost!</h3></a>
<p>Like modern C++, the efforts Rust makes are pretty good, with
RAII/scope-based resource management (specifically destructors) being
a powerful tool for managing memory and <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html#locks">beyond</a> (and
<a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">beyonder</a>), especially when combined with Rust's
move-by-default semantics. The point about not being a guarantee is
that (a) it's not trivial to make a useful <em>formal</em> definition of
memory leak (at the very least, usefulness varies depending on the
context), and (b) there are relatively rare edge-cases that seem to be
impossible to statically prevent without non-trivial cost. The
<a href="http://doc.rust-lang.org/stable/nomicon/leaking.html">wash-up</a> in Rust's standard library is all values have to be
<em>memory safe</em> to leak, but they can still consider being leaked
incorrect. In other words, one may get unwanted behaviour if a value
is leaked, but the consequences will be more far controlled than a
segfault or memory corruption.</p>
<p>{% include comments.html c=page.comments %}</p>
</div>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
